        Autonomous robust control techniques for dynamic
                       target tracking
                             Guillermo Julio Cesar Betancourt Vera



      To cite this version:
    Guillermo Julio Cesar Betancourt Vera. Autonomous robust control techniques for dynamic tar-
    get tracking. Robotics [cs.RO]. Université de Technologie de Compiègne, 2021. English. �NNT :
    2021COMP2619�. �tel-03438755�




                                   HAL Id: tel-03438755
                 https://tel.archives-ouvertes.fr/tel-03438755
                                      Submitted on 21 Nov 2021




    HAL is a multi-disciplinary open access               L’archive ouverte pluridisciplinaire HAL, est
archive for the deposit and dissemination of sci-     destinée au dépôt et à la diffusion de documents
entific research documents, whether they are pub-     scientifiques de niveau recherche, publiés ou non,
lished or not. The documents may come from            émanant des établissements d’enseignement et de
teaching and research institutions in France or       recherche français ou étrangers, des laboratoires
abroad, or from public or private research centers.   publics ou privés.


   Par Guillermo Julio Cesar BETANCOURT VERA



          Autonomous robust control techniques
               for dynamic target tracking



  Thèse présentée
  pour l’obtention du grade
  de Docteur de l’UTC




Soutenue le 28 juin 2021
Spécialité : Automatique et Robotique : Unité de recherche
Heudyasic (UMR-7253)
                                                     D2619


   UNIVERSITÉ DE TECHNOLOGIE DE COMPIÈGNE

              HEUDIASYC, UMR 7253

       AUTONOMOUS ROBUST
     CONTROL TECHNIQUES FOR
     DYNAMIC TARGET TRACKING

                 Thesis presented by

       Guillermo Julio Cesar Betancourt Vera

             to obtain the degree of Doctor

                       28/06/2021


         Spécialité : Automatique et Robotique




                Committee members:

   Referees: Sihem Tebbani          Professor at L2S
             Nicolas Marchand       DR CNRS at GIPSA-Lab
 Examiners: Reine Talj              HDR CNRS at HDS
             Didier Theilliol       Professor at CRAN
             Franck Ruffier         DR CNRS at ISM
             Lounis Adouane         Professor at HDS
Supervisors: Pedro Castillo         HDR CNRS at HDS
             Rogelio Lozano         DR CNRS at HDS


              Compiègne, France 2021




“Once you have tasted flight, you will forever walk the earth
   with your eyes turned skyward, for there you have been,
                  and there you will always long to return.”
                                        — Leonardo da Vinci




  To my lovely family. . .




Acknowledgements
I would like to deeply thank Pedro Castillo and Rogelio Lozano for giving me the opportunity
to pursue my PhD under their supervision on an interesting interdisciplinary topic that
included robots, dynamics, control, etc. This thesis would not have been possible without
their continuous support, patience, advise, and availability. I can hardly express my gratitude
in words to Pedro and Rogelio for letting me work in such an amazing lab that has been unique
in many aspects. The availability of several advanced robots and equipments in our lab gave
me an exceptional opportunity to work with many state-of-art platforms and to evaluate
different aspects of my work in real world experiments. Thanks to them for all the time their
spent to read and correct my articles and thesis and all their fruitful guidelines, without which
this thesis would never have reached its current state.
I want to express also my gratitude to the institutions that supported this work from the
beginning. To the Mexican Consejo Nacional de Ciencia y Tecnlogía (CONACYT) for the
scholarship program that supported me during my PhD studies in France. A big thank you to
the Heudiasyc (Heuristic et DIAgnostique des SYstèmes Complexes) laboratory and the Ècole
Doctorale Sciences pour l’Ingenieur at the Université Technologie de Compiègne (UTC) that
made this work possible with their PhD programs.
I would like to thank my examiners Professor Sihem Tebbani and the DR CNRS Nicolas
Marchand that have honored me by accepting to read my thesis. Your insightful comments
were undoubtedly a great asset for this thesis. My thanks are also for the HDR CNRS Reine
Talj, Professors Didier Theilliol and Lounis Adouane as well the HDR CNRS Franck Ruffier for
accepting to be part of my jury and giving very helpful commentaries of my thesis.
I have enjoyed each moment of my PhD life thanks to the amazing atmosphere at our lab.
Every working day was full of interesting scientific and non-scientific discussions with such an
awesome multifaceted group of people. I would like to immensely thank Guillaume Sanahuja,
Gildas Bayard, Thierry Monglon, Alexis Offermann, Cristino de Souza, Hernan Abaunza and
Belem Rojas with whom I had the opportunity to discuss, life, music, tv, science, games,
religion, and many other interesting topics. A big thanks specially to Guillaume and Gildas
for FL-AIR, an invaluable framework that helped me a lot to apply my methods on real and
simulated robots. Their passion for robots and technology, their sense of humor and this
endless knowledge on C++ have been an inspiration and a pleasure for me.
Thanks to Professor Pedro Gil and Vicente Balaguer for your support, knowledge and the great
scientific discussions we had during our meetings. I hope to continue collaborating with you.



                                                                                                i


Acknowledgements


I would like to thank Sabine Vidal, Brigitte Azzimonti and Nathalie Alexandre from the ad-
ministrative service of the laboratory and Sylvie Carlier from the administrative service of the
Ècole Doctorale Sciences pour l’Ingenieur at the Université Technologie de Compiègne (UTC),
for taking care of the administrative aspects of my PhD.
I would like to thank a number of valuable friends outside my doctoral study, who has made
living in France a very enjoyable and pleasant experience for me. My especial thanks to Nicolas
Abdelnour, Louise le Masne, Maxime Juston, Garance Verrier, Aurélien Quelin, Laure Tangre,
Hénoïk Willot, Santiago Venegas and Emeric Ostermeyer with whom I shared many great
memories. Life in Compiègne could not be better thanks to your companionship, availability
and sens of humor. I would also like to thank my roommates and friends Alexis Pagnoux,
Alexis Nauton, Mokossia N’guessan, Quentin Duchemin, Maxime Beaugendre, Lola Lejeune,
Matěj Křístek, Pierre Kidzié and Anna Tailliez for all the unforgettable moments that we spent
together at home. A huge thanks for the amazing conversations that I had with each one of
you, for teaching me the french culture, for being so patience when I was learning french and
for the unforgettable and uncountable hours of music and sport sessions. All my gratitude to
all of you. I could say that I found my second family with all of you.
My especial thanks to Ricardo Sanz for always proposing me such amazing hikes. I passed
a wonderful time walking and discussing about everything with you. You made mountains
became really important to me and that gave me peace and energy. My thanks to Oscar
Beltran, my cheerful and supportive friend with whom I shared many ups and downs of PhD
life. Thanks a lot for always believing on me and for being such a good friend when I needed it.
Thanks to Jesus Solis, for the unmemorable discussions about science, technology and life.
Even with a huge distance and seven hours of time difference, you made possible to helped
me with my Linux issues. You are truly good friends that I can see as my brothers.
Last, but far from least, I would have never reached the place where I am now without the
endless support, love and encouragement of my parents, Abraham and Alma. I am immensely
thankful for their confidence in me, which has allowed me to discover many aspects of life
independently. I would also like to deeply thank to my brothers Jesús, Abraham and Juan for
all their back up and the nice moments we have spent together.

Compiègne, June 28, 2021                                                                    J. B.




ii


Abstract
This thesis will approach the problem of tracking moving targets by means of an aerial drone.
More precisely, a quadrotor configuration was taken into consideration for the development
of aerial navigation algorithms, since this kind of platform is mechanically simple, versatile
for performing aggressive maneuvers, and easily available for experimentation.

The goal of this thesis is to develop control and navigation algorithms capable of robustly
tracking dynamic targets. The contributions herein reported aim at presenting a unified and
accessible analysis of control strategies for solving the stabilization and tracking problems. In
addition, this thesis introduces autonomous and semi-autonomous navigation algorithms for
tracking static and dynamic targets. Finally, for giving robustness with respect to a class of per-
turbations, a robust control architecture based on disturbance observer has been developed.

Control approaches for aerial vehicles: The first part of this work consisted on developing
quadrotor controllers with the aim of robustly tracking trajectories and performing precise
navigation tasks. It is well-known that, stabilizing and tracking control problems of a quadrotor
vehicle has been studied through the last decades. Nevertheless,choosing the best control
technique to solve these problems is still not an easy task. Therefore, the following control
strategies were introduced:

–   Nonlinear and linear backstepping.
–   Simple nonlinear bounded control.
–   Virtual control based on hyperbolic functions.
–   Quaternion-based backstepping control.
–   Finite time convergence based on sliding mode control.

Autonomous navigation algorithms: The next part of this thesis was focused on developing
semi-autonomous and autonomous algorithms that allows to detect and track a mobile target,
as well to generate desired trajectories such that, the controllers previously developed can
track.

A path planning algorithm for quadcopters based on model predictive control was developed
for the autonomous trajectory generation. The algorithm was solved in real time as a result of
an online optimization of a cost function. Then, the optimal trajectories were tracked using a
simple nonlinear bounded control.




                                                                                                iii


Abstract


Then, concerning the detection and tracking of a ground mobile target, an autonomous visual
servoing navigation algorithm was proposed. The algorithm considers that the ground vehicle
mimics a car driver such that its movements can be described as a vector field. In addition the
ground robot is detected using properties from the well-known optical flow algorithm. Thus,
the quadrotor tracks the ground vehicle using the quaternion-based backstepping control.

Lastly, a semi-autonomous virtual control architecture for controlling robots remotely was
developed in cooperation with the team of virtual reality at the Heudiasyc Lab. The architecture
is composed by a world-in-miniature located in a virtual environment and, a real aerial robot
located in a fly arena. The real aerial robot tracks the desired positions and velocities, coming
from the virtual environment, using a quaternion-based backstepping control.

Robust control scheme: The last part of this thesis was dedicated to the conception of a
robust control architecture capable to counter-acted model uncertainties and a external
perturbations such as wind gust and loss of effectiveness in rotors. This architecture can be
seen as follows:

A robust control architecture based on disturbance estimator was introduced to give robust-
ness to the closed-loop system with respect to nonlinear uncertainties and small external
disturbances. The architecture performed experimental tests enhancing a simple feedback
controller.

Then, improving the previously discussed architecture, a novel robust fault tolerant control
scheme was obtained. The scheme has in addition a rotors fault observer to detect and
estimate the loss of effectiveness in actuators. The robust controller can estimate and counter-
acted rotors faults in non hover and hover positions.

Ultimately, a bounded robust control architecture was developed from the disturbance ob-
server and optimal control properties. Besides estimating and compensating unknown dy-
namics, this scheme improves its robustness by solving the physical constraints of the motors.
The architecture was experimentally proved with several wind gust and loss of effectiveness in
two rotors.




iv


Résumé
Cette thèse étudie la problématique du suivi de cibles mobiles à l’aide d’un drone aérien. Plus
précisément, une configuration quadrotor a été utilisée pour le développement d’algorithmes
de navigation aérienne. En effet, ce type de plateforme est simple mécaniquement, polyvalent
pour effectuer des manœuvres aggressives, et facilement disponible pour l’expérimentation.

L’objectif de cette thèse est de développer des algorithmes de contrôle et de navigation ca-
pables de suivre de manière robuste une cible dynamique. Les contributions rapportées
ici présent une analyse unifiée et accessible des stratégies de contrôle pour résoudre les
problèmes de stabilisation et de suivi. Cette thèse introduit également des algorithmes de
navigation autonome et semi-autonome pour le suivi d’une cible statique et dynamique. Enfin,
pour donner de la robustesse vis-à-vis d’une classe de perturbations, une architecture de
contrôle robuste basée sur l’observateur de perturbations a été développée.

Techniques de contrôle des véhicules aériens : La première partie de ce travail a consisté
à développer des contrôleurs de quadrotor dans le but de suivre de manière robuste des
trajectoires et de réaliser des tâches de navigation précises. En effet, les problèmes de contrôle
de stabilisation et de suivi d’un véhicule quadrotor ont été étudiés au cours des dernières
décennies. Néanmoins, choisir la meilleure technique de contrôle pour résoudre ces pro-
blèmes n’est pas une tâche facile. Par conséquent, les stratégies de contrôle suivantes ont été
introduites :

–   Backstepping linéaires et non linéaires.
–   Contrôle borné non linéaire.
–   Contrôle virtuel basé sur des fonctions hyperboliques .
–   Contrôle backstepping basé sur des quaternions.
–   Convergence en temps fini basé sur le contrôle du mode glissant.

Algorithmes de navigation autonomes : La partie suivante de cette thèse s’est concentrée sur
le développement d’algorithmes semi-autonome et autonome qui permettent de détecter et de
suivre une cible mobile, ainsi que de générer des trajectoires désirées afin que les contrôleurs
précédemment développés puissent suivre.




                                                                                                v


Résumé


Un algorithme de planification de trajectoire pour quadrotors basé sur un modèle de contrôle
prédictif a été développé pour la génération autonome de trajectoires. L’algorithme a été
résolu en temps réel grâce à une optimisation en ligne d’une fonction de coût. Ensuite, les
trajectoires optimales ont été suivies à l’aide d’un simple contrôle borné non linéaire.

Ensuite, concernant la détection et le suivi d’une cible mobile au sol, une algorithme de
navigation d’asservissement visuelle autonome a été proposé. L’algorithme considère que
le véhicule terrestre imite un conducteur de voiture afin que ses mouvements soient décrits
comme un champ vectoriel. De plus, le robot au sol est détecté en utilisant les propriétés de
l’algorithme de flux optique bien connu. Ainsi, le quadrotor suit le véhicule au sol en utilisant
la commande backstepping basée sur des quaternions.

Enfin, une architecture de contrôle virtuel semi-autonome permettant de contrôler des robots
à distance a été développée en coopération avec l’équipe de réalité virtuelle du laboratoire
Heudiasyc. L’architecture est composée d’un monde en miniature situé dans un environne-
ment virtuel et d’un robot aérien réel situé dans une arène de vol. Le vrai robot aérien suit les
positions et les vitesses désirent, provenant de l’environnement virtuel, à l’aide d’un contrôle
backstepping basé sur le quaternion.

Schéma de contrôle robuste : La dernière partie de cette thèse était consacrée à la conception
d’une architecture de contrôle robuste capable de contrer les incertitudes du modèle et les
perturbations externes telles que les rafales de vent et la perte d’efficacité des rotors. Cette
architecture peut être vue comme suit :

Une architecture de contrôle robuste basée sur un estimateur de perturbations a été introduite
pour donner de la robustesse au système en boucle fermée vis-à-vis des incertitudes non
linéaires et des petites perturbations externes. L’architecture a effectué des tests expérimentaux
améliorant un contrôleur de rétroaction simple.

Ensuite, en améliorant l’architecture discutée précédemment, un nouveau schéma de contrôle
robuste et tolérant aux pannes a été obtenu. Le schéma dispose en outre d’un observateur de
défauts de rotors pour détecter et estimer la perte d’efficacité des actionneurs. Le contrôleur
robuste peut estimer et contrecarrer les défauts des rotors en position non stationnaire et en
position stationnaire.

Enfin, une architecture de contrôle robuste bornée a été développée à partir de l’observa-
teur de perturbations et des propriétés de contrôle optimales. En plus de l’estimation et la
compensation de dynamiques inconnues, ce schéma améliore sa robustesse en résolvant
les contraintes physiques des moteurs. L’architecture a été prouvée expérimentalement avec
plusieurs rafales de vent et une perte d’efficacité dans deux rotors.




vi


Contents
Acknowledgements                                                                                           i

Abstract                                                                                                 iii

List of Figures                                                                                          xi

List of Tables                                                                                          xvii

Glossary                                                                                                xix

Glossary                                                                                                xix


I Chapter 1                                                                                               1

1 Introduction                                                                                            3

Introduction                                                                                              3
   1.1 Problem statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          4
   1.2 Thesis objective . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       5
   1.3 State of the art . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     6
   1.4 Thesis outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      15


II Chapter 2                                                                                             17

2 Modeling quadcopter vehicle approaches                                                                 19
   2.1 Force and moment in a rotor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           20
   2.2 Classical modeling approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           21
        2.2.1 Euler-Lagrange approach . . . . . . . . . . . . . . . . . . . . . . . . . . . .            21
        2.2.2 Newton-Euler approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . .            25
   2.3 Quadrotor quaternion model based on Euler-Lagrange . . . . . . . . . . . . . .                    25
        2.3.1 Quadrotor quaternion dynamical model . . . . . . . . . . . . . . . . . . .                 27
        2.3.2 Decoupling the vehicle dynamics . . . . . . . . . . . . . . . . . . . . . . .              31
   2.4 Modeling approaches conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . .             33

                                                                                                         vii


Contents


III Chapter 3                                                                                              35

3 Control approaches for aerial vehicles                                                                    37
       3.1 Comparison of stabilization and tracking control algorithms . . . . . . . . . . .                38
            3.1.1 Nonlinear Backstepping algorithm . . . . . . . . . . . . . . . . . . . . . . .            39
            3.1.2 Control algorithm based on nested saturation . . . . . . . . . . . . . . . .              41
            3.1.3 Linear backstepping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         43
            3.1.4 Fully actuated approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         45
            3.1.5 Numerical and experimental results . . . . . . . . . . . . . . . . . . . . . .            51
            3.1.6 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      59
       3.2 Quaternion-based backstepping control . . . . . . . . . . . . . . . . . . . . . . .              60
            3.2.1 Experimental test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       64
       3.3 Finite-time convergence using Sliding Mode Control . . . . . . . . . . . . . . . .               67
            3.3.1 x c (t ) and y c (t ) components . . . . . . . . . . . . . . . . . . . . . . . . . . .    67
            3.3.2 Sliding mode control design . . . . . . . . . . . . . . . . . . . . . . . . . .           69
            3.3.3 Numerical and experimental results . . . . . . . . . . . . . . . . . . . . . .            72
       3.4 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      77


IV Chapter 4                                                                                                79

4 Autonomous navigation algorithms                                                                          81
       4.1 Path planning algorithm using MPC . . . . . . . . . . . . . . . . . . . . . . . . . .            82
            4.1.1 Experimental results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        86
       4.2 Vision algorithm for target localization: a case study for
           autonomous vehicles surveillance . . . . . . . . . . . . . . . . . . . . . . . . . . .           88
            4.2.1 Experimental tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        95
       4.3 Semi-autonomous navigation using an immersive virtual reality environment . 101
            4.3.1 Virtual control scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
            4.3.2 DrEAM’s experimental fatigue tests results . . . . . . . . . . . . . . . . . . 107
            4.3.3 DrEAM real-time validation with robots . . . . . . . . . . . . . . . . . . . 109
       4.4 Quadcopter autonomous navigation conclusions . . . . . . . . . . . . . . . . . . 116


V Chapter 5                                                                                                119

5 Robust control scheme based on disturbance estimator                                                     121
       5.1 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
            5.1.1 Proposed solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
       5.2 Robust control scheme for disturbance rejection . . . . . . . . . . . . . . . . . . 123
            5.2.1 Experimental results for disturbance rejections . . . . . . . . . . . . . . . 126
       5.3 Enhancing robust control architecture for LoE in rotors . . . . . . . . . . . . . . 133
            5.3.1 Numerical and practical validation . . . . . . . . . . . . . . . . . . . . . . 136
            5.3.2 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149

viii


                                                                                     Contents


  5.4 Enhancing robust control architecture for handling rotor’s constraints . . . . . 152
      5.4.1 Experimental results of bounded control . . . . . . . . . . . . . . . . . . . 154
  5.5 Robust control architecture conclusions . . . . . . . . . . . . . . . . . . . . . . . 160


VI Chapter 6                                                                              161

6 Conclusions                                                                              163

Conclusions                                                                                163

A Publications                                                                             165


Bibliography                                                                               167




                                                                                             ix




List of Figures
 1.1 Example of a target tracking problem: a pursuer drone follows an intruder
     quadrotor while flying in a restricted area. . . . . . . . . . . . . . . . . . . . . . .           5

 2.1 Propeller forces and torques acting on a quadrotor. . . . . . . . . . . . . . . . . .             20
 2.2 Coordinate systems acting in the aerial vehicle where f i denotes the force applied
                    ~t h symbolizes the total thrust force and θ, φ, ψ are the Euler
     of each motor, F
     angles on each axis. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      21
 2.3 Quadcopter free body diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . .            27
 2.4 Illustration of the Cross product of two vectors . . . . . . . . . . . . . . . . . . .            32

 3.1 Longitudinal position performance when comparing the four control algorithms. 52
 3.2 θ angle response when applying four controllers into the PVTOL dynamics. θd
     denotes the desired angle computed in (3.43). . . . . . . . . . . . . . . . . . . . .             52
 3.3 Vertical position behavior when comparing the four control algorithms. . . . .                    53
 3.4 Vehicle’s performance evolution in the x −z plane when applying the four control
     algorithms into the PVTOL dynamics. From figure x r i for i : 1, 2, 3 describes the
     desired way-point. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        53
 3.5 u 1 behavior when applying the controllers (3.11), (3.26), (3.36) and (3.48). . . .               54
 3.6 Torque control u 2 response when applying the four control algorithms. . . . . .                  54
 3.7 Quadcopter configuration evolving its longitudinal plane. . . . . . . . . . . . . .               55
 3.8 Longitudinal behavior when applying experimentally the four control algorithms
     into the aerial vehicle. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      56
 3.9 θ angle response when the four control algorithms where applied in real time.
     θd describes the desired angle. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         56
 3.10 Vertical position comparing the four control algorithms. . . . . . . . . . . . . . .             57
 3.11 Vehicle’s performance evolution in the x − z plane when the four control algo-
      rithms are applied in real time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       57
 3.12 Thrust control u 1 response for the four control algorithms applied to the aerial
      vehicle. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   58
 3.13 Torque control response, u 2 , obtained during the flight tests. . . . . . . . . . . .           58
 3.14 Performance of the quadcpter during the flight test . . . . . . . . . . . . . . . . .            64
 3.15 Quadcotper position tracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         65

                                                                                                       xi


List of Figures


      3.16 Quadcopter attitude quaternion performance when tracking the desired pose
           trajectory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   65
      3.17 Performance of the control input forces . . . . . . . . . . . . . . . . . . . . . . . .          66
      3.18 Performance of the rotational controller . . . . . . . . . . . . . . . . . . . . . . .           66
      3.19 Quadcopter attitude axis-angle representation . . . . . . . . . . . . . . . . . . . .            67
      3.20 Finite time convergence of the quadcopter to the flying target at t̄ = 5s . . . . .              73
      3.21 Performance of the x, y, z axes of the quadrotor when converging in finite time.                 73
      3.22 Tracking performance of the attitude system of the quadrotor. . . . . . . . . . .                74
      3.23 Control inputs of the quadrotor. . . . . . . . . . . . . . . . . . . . . . . . . . . . .         74
      3.24 Performance of the x and y axes of the quadcopter. Left column of the picture
           represents the experiment when t̄ = 5s and the right column for t̄ = 3s. . . . . .               75
      3.25 3D performance of the quadcopter. Left image corresponds when t̄ = 5s and
           right one when t̄ = 3s. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      76
      3.26 Attitude behavior of the quadcopter when tracking a desired trajectory with
           t̄ = 5s and t̄ = 3s as desired finite-time convergence. . . . . . . . . . . . . . . . .          76
      3.27 Performance of the control inputs when considering t̄ = 5s and t̄ = 3s as desired
           finite-time convergence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        77

      4.1 Control-scheme diagram. P    ~r defines the control trajectory obtained from the
          algorithm MPC, P  ~d denotes the desired final values. The Re-Planner based on
          MPC generates the optimal feasible trajectory, and ~η, ~  ξ state for the vehicle’s
                  u n represent the saturation nominal controller, ~
          states. ~                                                 u ζ expresses a compen-
          sate parameter from a disturbance observer and ζ possible external perturbations. 82
      4.2 Evolution of the path tracking in x, y, z−axis with wind and manual disturbances. 87
      4.3 Flight test when the quadcopter follows the helical trajectory in ascending phase
          in presence of wind and manual disturbances. . . . . . . . . . . . . . . . . . . . .              87
      4.4 Flight test when the quadcopter follows the helical trajectory in descending
          phase in presence of wind and manual disturbances. . . . . . . . . . . . . . . . .                88
      4.5 Proof of concept of the problem: The driver commands the vehicle in urban
          set, picking up the next contour A, then B, then C to plan smoothly ahead, as
          if navigating in smooth vector fields; then, facilitating tracking with airborne
          monocular camera, since height can be regulated efficiently, and assuming target
          remains in the FoV. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       89
      4.6 Experimental test-bed showing the AR Drone 2.0 as the quadrotor, and the Jump-
          ing Sumo as the mobile robot (with a chess board on top for image processing).                    90
      4.7 Frames when searching for the target . . . . . . . . . . . . . . . . . . . . . . . . .            91
      4.8 Image position of the mobile robot frame and the camera frame. . . . . . . . . .                  92
      4.9 Kinematic of a differential robot as an abstract representation of an AGV. . . . .                92
      4.10 Three steps Velocity Fields design method based on differential geometry prop-
           erties of the desired trajectory:(a) parametric curve of motion objective, (b) main
           directional components of the field, (c) calculation of the velocity vectors. . . .              93

xii


                                                                                     List of Figures


4.11 Positions x and y of the centroid using the optical flow data and the kalman filter.
     The z position is measured using the Optitrack camera system. . . . . . . . . . .             96
4.12 Velocities of the target in the image plane. . . . . . . . . . . . . . . . . . . . . . .      97
4.13 Control inputs for the quadcopter vehicle. . . . . . . . . . . . . . . . . . . . . . .        97
4.14 Desired velocity field components of the ground robot. . . . . . . . . . . . . . .            98
                              ~t and its estimated velocity. . . . . . . . . . . . . . . . .
4.15 Position of the centroid p                                                                    98
4.16 Cartesian position trajectories and errors of the mobile robots. . . . . . . . . . .          99
4.17 Performance of both robots in the x y plane. These signals are provided by the
     Optitrack system. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   99
4.18 Control inputs of the flying and ground vehicles. . . . . . . . . . . . . . . . . . . 100
4.19 Left: stress when piloting a drone. Right: frustration after crashing the vehicle [1]. 101
4.20 Virtual control scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4.21 Real world environments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.22 DREAM’s virtual environment and flight arena . . . . . . . . . . . . . . . . . . . . 105
4.23 Different states of the virtual drone; (a) - cannot be taken , (b) - can be taken and
     (c) - has been taken. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
4.24 Navigation task: start point (S), checkpoint (C) and the final point (A) keeping
     the heading of the vehicle pointing to the target. . . . . . . . . . . . . . . . . . . 108
4.25 Graphics results from the NASA-TLX questionnaire. From graphs 0 means low
     and 6 high demand or impact on the presented criteria. . . . . . . . . . . . . . . 108
4.26 Scenario of the first experiment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
4.27 3D performance of the virtual drone and the real vehicle when scenario 1 is
     validated in real time. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
4.28 Yaw angle behavior of the drones (real and virtual). . . . . . . . . . . . . . . . . . 111
4.29 x-position performance of the virtual drone and the real vehicle obtained from
     the first scenario. Observer the good behavior of the real drone when imitates
     the virtual drone trajectory. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
4.30 Performance of the robots (virtual and drone) in the y axis. . . . . . . . . . . . . 112
4.31 z-state behavior of the first scenario. Observe that the robots (virtual and real)
     change their altitude for crossing the windows. . . . . . . . . . . . . . . . . . . . 113
4.32 Performance of the velocities of vehicle during the first scenario. Note that it is
     increased mainly in the x and y axes. . . . . . . . . . . . . . . . . . . . . . . . . . 113
4.33 Scenario of the second experiment. . . . . . . . . . . . . . . . . . . . . . . . . . . 114
4.34 3D behavior of the virtual and the real aerial vehicles when performing the
     second scenario. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
4.35 Performance of the aerial robots in the x axis. Observe the good performance
     when the real robot imitates the virtual robot. . . . . . . . . . . . . . . . . . . . . 115
4.36 y- state behavior of the aerial robots (virtual and real) when the user turns the
     pillars three times. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
4.37 z performance of the vehicles obtained during the second scenario. Observe
     that the last two laps the user change also the altitude during the trajectory. . . 116
4.38 Behavior of the heading of the virtual and real drone respectively. . . . . . . . . 116

                                                                                                   xiii


List of Figures


      5.1 Block diagram of the control structure. ~      u n and ~u ζ correspond to the the nominal
          control action and the control rejection part, respectively, ~       ξd is the desired refer-
          ence. ~u R represents the proposed controller ζ represents external disturbances.
           . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
      5.2 Wind-gust scenario. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
      5.3 Vehicle’s performance in 3D against wind disturbance. . . . . . . . . . . . . . . . 127
      5.4 Performance of the vehicle in x−axis, y−axis and z−axis. . . . . . . . . . . . . . 128
      5.5 Estimation of the wind disturbance. . . . . . . . . . . . . . . . . . . . . . . . . . . 128
      5.6 Lateral weight disturbance applied to an aerial system. . . . . . . . . . . . . . . . 129
      5.7 Vehicle’s performance in 3D against the weight disturbance. . . . . . . . . . . . 129
      5.8 Performance of the quadrotor against the later weight disturbance. . . . . . . . 130
      5.9 Estimation of the weight disturbance. . . . . . . . . . . . . . . . . . . . . . . . . . 130
      5.10 Partial rotor failure in a quadcopter. . . . . . . . . . . . . . . . . . . . . . . . . . . 131
      5.11 Vehicle’s performance in 3D against a rotor failure. . . . . . . . . . . . . . . . . . 131
      5.12 Performance of the quadrotor against a rotor’s fault. . . . . . . . . . . . . . . . . 132
      5.13 Estimation of the rotor failure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
      5.14 Control actions of the motors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
      5.15 Block diagram of the enhanced control architecture. . . . . . . . . . . . . . . . . 135
      5.16 Quadrotor position performance when using a feedback controller and the
           proposed architecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
      5.17 Scenario 1.- Performance of the quadrotor subject to a LoE of 30% in M 1 . . . . . 138
      5.18 Scenario 1.- Performance of the rotor fault estimator M̂ ζi , i = 1, · · · , 4. . . . . . . 138
      5.19 Scenario 1.- Control action’s behavior of each of the rotors when using ~            u n and
           ~
           u R controllers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
      5.20 Position performance of the vehicle subject to a critical failure in M 1 . . . . . . . 139
      5.21 Scenario 2.- Performance of the rotor fault estimator M̂ ζi , i = 1, · · · , 4. . . . . . . 140
      5.22 Scenario 2.- Rotors control action’s performances when a critical fault in motor
           M 1 is applied. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
      5.23 Performance of the rotor faults estimator M̂ ζi and the disturbance estimations
           (5.11) of the attitude system of the quadrotor . . . . . . . . . . . . . . . . . . . . . 141
      5.24 Scenario 1.- Control rotors performance when using the linear controller (top
           graph) and the proposed scheme. . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
      5.25 Scenario 1.- Performance of the quadrotor position subject to a sequence of
           rotors failures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
      5.26 Scenario 2.- Position performance of the vehicle when using the linear controller
           and the proposed architecture, and a rotor fault is induced in a non hover position. 143
      5.27 Scenario 2.- Performance of the quadrotor position subject to a rotor fault while
           moving to a desired position ~
                                        ξd (t f ). . . . . . . . . . . . . . . . . . . . . . . . . . . 143
      5.28 Scenario 2.- Rotors faults estimations M̂ ζi , i = 1, · · · , 4. . . . . . . . . . . . . . . . 144
      5.29 Scenario 2.- Rotors control action’s performances, when a LoE of 30% in M 1 is
           applied during a non hover position. . . . . . . . . . . . . . . . . . . . . . . . . . 144

xiv


                                                                                         List of Figures


5.30 Scenario 3.- Performance of the vehicle when applying a motor fault of 50% and,
     two different controllers are used. . . . . . . . . . . . . . . . . . . . . . . . . . . .          145
5.31 Scenario 3.- Performance of the quadcopter position subject to a critical rotor
     fault of 50% in M 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      146
5.32 Scenario 3.- Rotors faults estimations M̂ ζi , i = 1, · · · , 4. . . . . . . . . . . . . . . .     146
5.33 Scenario 3.- Rotors control action’s performances, when a critical fault of 50% in
     M 1 is applied. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      147
5.34 Scenario 4.- Position performance of the vehicle when using the linear controller
     and the proposed architecture, and a critical rotor fault is induced. . . . . . . .                148
5.35 Scenario 4.- Rotors faults estimations M̂ ζi , i : 1, · · · , 4. . . . . . . . . . . . . . . . .   148
5.36 Scenario 4.- Rotors control action’s performances, when a critical fault of 60% in
     M 1 is applied. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      149
5.37 Control inputs ~ u n and ~
                              u R of the first scenario. . . . . . . . . . . . . . . . . . . . .        151
5.38 Control inputs ~ u n and ~
                              u R of the second scenario. . . . . . . . . . . . . . . . . . .           151
5.39 Control inputs ~ u n and ~
                              u R of the third scenario. . . . . . . . . . . . . . . . . . . .          152
5.40 Block diagram of the control structure. ~   u n and ~u ζ correspond to the the nominal
     control action and the control rejection part, respectively, ξd is the desired
     reference. ~ξ,~η mean the position and attitude states. ~         u R and ~u R∗ represent the
     proposed controller and the set of its optimal and bounded values, respectively.
     The quadratic problem block deals with the motors constraints and ζi represents
     external disturbances. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .         154
5.41 Set-up of the wind-gust scenario. . . . . . . . . . . . . . . . . . . . . . . . . . . . .          155
5.42 Scenario 1.- System performance during flight tests. . . . . . . . . . . . . . . . .               155
5.43 Scenario 1.- Performance of the quadrotor position subject to wind-gust. . . . .                   156
5.44 Scenario 1.- Attitude Performance of the quadrotor system subject to wind-gust.                    156
5.45 Scenario 1.- Attitude disturbance estimations. . . . . . . . . . . . . . . . . . . . .             157
5.46 Scenario 1.- Performance of the motor control actions. . . . . . . . . . . . . . . .               157
5.47 Scenario 2.- 3D state performances in flight tests. . . . . . . . . . . . . . . . . . .            158
5.48 Scenario 2.- Performance of the attitude disturbance estimation. . . . . . . . . .                 159
5.49 Scenario 2.- Behavior of motor control actions. . . . . . . . . . . . . . . . . . . .              159




                                                                                                         xv




List of Tables
 3.1 Parameters values used in the control laws in (3.11), (3.22), (3.36) and (3.48) used
     in simulation and experimental validation. . . . . . . . . . . . . . . . . . . . . .          51
 3.2 Performance indices of the z−axis . . . . . . . . . . . . . . . . . . . . . . . . . . .       59
 3.3 Performance indices of the x−axis . . . . . . . . . . . . . . . . . . . . . . . . . . .       59
 3.4 Qualitative comparison of the control algorithms. The best result is denoted
     with 1 and the worst with 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    60
 3.5 Control gains parameters used in experimental tests . . . . . . . . . . . . . . . .           64
 3.6 Control parameters used in experimental and numerical tests for t̄ = 5s . . . . .             72

 4.1 Experimental parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
 4.2 Experimental parameters for the control law (4.29) and the ground vehicle con-
     trol (4.32). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
 4.3 Data results of MLE, MCT and MYE indexes . . . . . . . . . . . . . . . . . . . . . 109
 4.4 Results from the one sample t-Test. . . . . . . . . . . . . . . . . . . . . . . . . . . 109

 5.1 Gain parameters used in the experimental tests . . . . . . . . . . . . . . . . . . . 126
 5.2 Performance indices of the three scenarios. . . . . . . . . . . . . . . . . . . . . . 149
 5.3 Total Variation (TV) of the control inputs. . . . . . . . . . . . . . . . . . . . . . . . 150




                                                                                                  xvii




Glossary
      ADRC     Active Disturbance Rejection Control
      AGV      Autonomous Ground Vehicle
      CAVE     Cave Automated Virtual Environment
      CoG      Center of Gravity
      CoM      Center of Mass
      DOBC     Disturbance Observer Based Control
      DoF      Degrees of Freedom
      DrEAM    Drone Exocentric Advanced Metaphor
      Fl-AIR   Framework libre AIR
      FoV      Field of View
      FTC      Fault Tolerant Control
      GESO     Generalized Extended State Observer
      HSC      Hyperbolic Saturation Controller
      LB       Linear Backstepping
      LoE      Loss of Efficiency
      MAS      Multi-rotor Aerial Systems
      MPC      Model Predictive Control
      NLB      Nonlinear Backstepping
      NS       Nested Saturation
      PI       Proportional Integrator
      PID      Proportional Integral Derivative
      PIO      Proportional-Integral Observer
      PVTOL    Planar Vertical Take-off and Landing
      qLPV     quasi-Linear Parameter Varying
      SMC      Sliding Mode Control
      UAV      Unmanned Aerial Vehicle
      UAVs     Unmanned Aerial Systems
      UDE      Uncertainty and Disturbance Observer
      VTOL     Vertical Take-Off and Landing
      WIM      World In Miniature




                                                      xix




Chapter 1 Part I




                   1




1 Introduction


 In the past decade Unmanned Aerial Vehicles (UAVs) have enjoyed considerable success in
 many applications such as search and rescue, monitoring, research, exploration, or mapping.
 Robotics research has advanced significantly the past years and it can now offer many elab-
 orate solutions in artificial vision, path planning, decision-making, obstacle avoidance and
 environment modeling − all these works aiming at endowing mobile machines with auton-
 omy [2]. The research and development in the field of Unmanned Aerial Systems (UAVs) is
 experiencing an increasing quantity of investment all around the world. Small UAVs are often
 used as experimental platforms to research on state estimation, control, robotic collaboration,
 etc; since their dynamic maneuvering and natural instability pose important challenges that
 are not present with other robotic platforms. In addition, the maneuverability of UAVs is
 combined with a low payload capability, which in turn requires the development of algorithms
 with constrained computation requirements. This fact has resulted in many research focused
 on testing and demonstrating the possibilities of several sensors on these platforms.

 Nowadays, UAVs can take off, fly and land almost without any human intervention. The work
 developed in this thesis is focused on quadrotors or quadcopters vehicles. These robots are
 composed basically by four motors, an Inertial Measurement Unit (IMU) for obtaining the
 orientation of the vehicle, a position sensor such as a GPS and a Central Processing Unit
 (CPU) where the control algorithm is executed [3]. Furthermore, a quadcopter is capable of
 handling complex tasks in cramped and crowded environments, as well as it has a simple
 control mechanism compared to the other types of UAVs [4]. Due to the cost reduction, in the
 last years, potential applications of quadcotpers have emerged for civil and military uses, such
 as airborne surveillance [5], automated search and rescue [6], military information gathering,
 military offensive actions, electrical transmission line inspection [7] and automated forest fire
 surveillance [8], to cite a few. A common point to most of these applications is that they are
 defined with respect to a reference frame, where a target needs to be tracked.

 For instance, in the airborne surveillance or in the automated search and rescue applications, a
 target must be defined to be tracked and this one can be static, slowly moving, or maneuvering
 at high speeds.


                                                                                                3


Introduction


As a consequence of the aforementioned, there has been increasing interest in the quadrotor
applications such as target-tracking, object detection and landing to drone station [9, 10, 11].
Especially, target-tracking is an essential task for quadrotors, as it has been proven to be an
effective tool in search and rescue surveillance [12], following and providing aerial based video
of sports events [13]. Also, it has become a relevant field for the correct development of many
multidisciplinary applications, such as traffic supervision, autonomous robot navigation,
mapping, and aerial photography.



1.1 Problem statement
The target tracking problem has an ever-growing number of civilian applications, ranging
from traditional applications such as air traffic control and building surveillance to emerging
applications such as supply chain management and wildlife tracking. For such tasks, and
due the simplicity and versatility of multirotors, in recent years, a large part of the scientific
community have focused their attention in these kind of vehicles in front of other types of
UAVs [14]. Target tracking for UAV generally falls into two categories; cooperative tracking
and non-cooperative tracking, respectively. In the cooperative tracking system, real time
between the UAV and the target is required, such as a convoy [15]. Compared with cooperative
tracking, non-cooperative tracking has less limitations. Instead of real-time interaction, in the
non-cooperative tracking system, the UAV is equipped with a camera so that the information
of the target can be obtained using vision-based method. For a successful tracking system, the
target needs to be kept within the camera view and distinguished from the environment in
real time by the onboard computer. Then the visual information derived from the processing
of images is used to control the motion of UAV to track the target and keep it at the center of
the image frame.

Autonomously tracking moving target using multirotors, as illustrated in Figure 1.1, is not an
easy task and many challenges have to emerge in different stages. However, when using a
quadrotor vehicle, this problem can be divided into three process; 1) taking off, 2) detection of
the moving target, and 3) tracking the moving target. Since the quadrotors are dynamically
unstable, under-actuated, and nonlinear systems, it is very challenging to design a controller
for a quadrotors to track a moving target especially under the varying speed of the moving
target and under the environment effects. In the process of tracking a moving target using a
quadrotor, there are still several challenges: (1) the completion with high precision and relia-
bility of the target tracking problem using a quadrotor, (2) the non-linearity and uncertainties
in the quadrotor system and (3) the external perturbations that can occur when tracking a
moving target.




4


                                                                          1.2. Thesis objective




Figure 1.1 – Example of a target tracking problem: a pursuer drone follows an intruder quadro-
tor while flying in a restricted area.

The necessity of implementing novel and reliable autonomous navigation control methods
for tracking moving targets, exploring the capabilities of robust control techniques and their
applicability, defines the research framework from which this thesis has been developed. This
thesis has a strong experimental and theoretical basis and the main research problems tackled
during its realization have been: 1) a mathematical model of the aerial vehicle needs to be built
such that it accurately describes the real vehicle but at the same time provides mathematical
simplicity in order to aim at 2) the development of control algorithms that will deal with
the stabilization and tracking problem, 3) Then, navigation methods must be designed to
follow dynamic targets even in the presence of external disturbance, and consequently, 4) a
robust control technique must to be exposed in order to overcome these external/internal
perturbations.


1.2 Thesis objective
For tracking target tasks, there is a need for the aerial vehicle to anticipate the movements
of the mobile target in order to be ‘a step ahead’. This brings the interest to the level of the
decision process: a target that is evasive is going to actively attempt to hide behind obstacles
and use this advantage to continue evading. In order to anticipate to the movements of this
target, the aerial vehicle must be able to predict such situations and to react or plan before
they even happen in order to maintain the continuity of the target tracking.

One of the main difficulties when designing a control system for solving the target tracking
problem is, undoubtedly, the good choice of the controller in the presence of disturbances.
It should be remarked that disturbances are not necessarily external to the system itself, but
they can be originated when sensing and/or actuating. Therefore, even if small, they can arise
at any time.

                                                                                               5


Introduction


This thesis will approach the problem of tracking moving targets by means of an aerial drone,
in our case a quadrotor vehicle. The goal of this thesis is to develop control and navigation
algorithms capable to robustly tracking dynamic targets. As a result, the following control
techniques must be addressed: autonomous navigation algorithms for the detection and
trajectory tracking of the moving target, control laws for stabilizing the quadrotor and tracking
desired trajectories with finite time convergence and, an enhancing control algorithm for
dealing with unknown model dynamics and external perturbations while satisfying motor’s
constraints.

The objectives of this thesis can be summarized as follows:


    • Develop a control based navigation method that allows the quadrotor vehicle to detect
      and track a moving target.

    • Develop a path planning algorithm based on model predictive control, capable of
      generating optimal trajectories based on target’s position.

    • Develop control algorithms for stabilizing a quadrotor while tracking desired trajectories
      with finite time convergence.

    • Develop a robust control architecture capable of dealing with external disturbances and
      undesired dynamics such as rotors fault.



1.3 State of the art

Quadrotor control techniques

In control systems for multirotor aerial vehicles there are two different types of control, de-
pending on the loop to which the controller is applied; the position controller and the attitude
controller. In fact, there is no direct actuation control per se. Attitude control is the con-
cept of pointing a craft in the desired direction. More specifically, it involves controlling the
orientation of the robot on its three Euler angles (θ, φ, ψ) and controlling the robot’s thrust
in the z-axis of the robot frame of reference. This is performed due to the underactuation
characteristics of the robot. Then, the outputs of this control are sent to a mixing-of-motors
algorithm to generate the reference signals for the actuators of the MAVs. In these cases, the
attitude control algorithm must take into account the number of motors and their respective
control signal. In contrast, position control is the controller that gives the Euler angles as
references to the attitude controller in order for the MAV to move in a desired trajectory [16].

For the last 10 years, attitude and position were popularly controlled by monitoring the altitude
(z-axis) using feedback linearization followed by a linear/nonlinear controller to achieve the
desired altitude. The values of the control torque can be found by replacing the controlled
altitude in the attitude expression. This method for designing the control torque will be
denoted classical approach in this work.

6


                                                                            1.3. State of the art


In addition, adaptive control has been studied to solve the problems of stabilization and
tracking of the dynamics. In [17] a novel trajectory tracking scheme by combining two inner
feedback linearization loops to stabilize the nominal quadrotor was presented. Moreover, a
robust adaptive tracking control scheme based on a self-tuning regulator has been presented
in [18]. This tracking method is implemented in the inner loop and a classical proportional
integrator (PI) controller was employed in the outer loop such that the robustness of the whole
system is guaranteed. Similarly, in [19] the altitude and attitude control laws for the quadrotor
based on the passivity method were introduced; the simulation results demonstrate high
efficiency and robustness with respect to the plant parametric uncertainty.

Furthermore, a time-varying backstepping technique is presented in [20], where a 3D control
tracking law is studied and applied experimentally on a quadrotor. This control law is imple-
mented by assuming that only the position and orientation parameters of the vehicles are
known; whereas the linear and angular velocities are estimated using Luenberger observers.
Later on, this work was improved in [21] by considering a non-linear time-varying version
of the backstepping technique. This work takes all the non-linearities of the dynamics into
account; resulting in a higher stability validated theoretically with numerical simulations.

Moreover, dynamic inversion is a new control technique developed in [22, 23] for the stabiliza-
tion and dynamics tracking of a quadrotor vehicle. The tracking controller is composed of two
loops; the dynamic inversion is implemented in the inner loop, where an internal dynamics
stabilization is applied to the outer loop. The control objectives are enclosed in the form of
constraint differential equation, and the resultant control law is obtained by inverting the
constraint dynamics using Moore-Penrose Generalized Inverse (MPGI). Computer simulations
were performed to exhibit the performance of the offered control technique in nominal and
perturbed conditions. In addition to the dynamic inversion controllers, an integral backstep-
ping controller with sliding mode control approach for a quadrotor was proposed in [24]. In
this approach the control of the UAV is performed in the altitude and position control. The
altitude control produces translational force, which is used to calculate virtual controls for the
x and y movements and desired angles for pitch and roll. The proposed controller was tested
in a Qball-X4 prototype. In the same sense, a hierarchical control was addressed in [25] based
on sliding-mode and adaptive control techniques to deal with slow and fast time-varying wind
conditions respectively. Simulations results show the validity of the proposed control strategy
while tracking a time-parametrized straight-line and sinusoidal trajectory.

Recently, a new fashion to design the torque control of the vehicle is considering the vehicle
model fully actuated by means of a virtual input. In this thesis, we will call the aforementioned
as virtual approach. In this context, there are some works exploiting the differential flatness
of the quadrotor model and then, with a trajectory generation algorithm, compute high-
performance flight trajectories that are capable of moving a quadrotor from a large class
of initial states to a given target point that will be reached at rest [26, 27, 28]. For example,
in [29] a control scheme based on a virtual control input using a backstepping approach
with Nussbaum function, a priori-bounded control torque for the rotational subsystem was
designed to track the desired orientations generated by the translational subsystem.

                                                                                                7


Introduction


In the same sense, a robust cost controller derived by Lyapunov stability theorem was ad-
dressed in [30]. The designed robust controller guarantees that the closed-loop system con-
verge asymptotically stable and its robustness with respect to parameter uncertainties. Besides,
in [31] the tracking control problem was solved using a two step approach. First, a transla-
tional control scheme that tracks the desired position trajectory is constructed assuming the
translational dynamics to be fully actuated. The magnitude of the translational control input is
used as the magnitude of the control thrust. Second, the unit vector representing the direction
of the translational control input used as the desired thrust direction.

The application of quaternions for controlling aircraft systems was introduced in [32], where
the authors used quaternion products to rotate control vectors between different reference
frames. It was remarked that quaternions are not affected by some undesired effects that are
inherent to Euler angles such as Gimball locks, singularities, and discontinuities, the authors
also emphasized that quaternion operations require less computational resources than com-
puting rotation matrices from other approaches. Later on, quaternion-based techniques were
also applied to quadrotor vehicles such as [33], where the authors proposed a quaternion
high-order sliding mode algorithm to control attitude trajectory on spacecraft, while [34] also
introduced a quaternion sliding mode control for spacecraft, but with adaptive properties
that consider actuator saturation scenarios. A comparison of several quaternion-based con-
trol algorithms for quadrotors was introduced by [35], where proportional-derivative (PD),
linear quadratic regulartor LQR, and backstepping position and attitude controllers were
compared with simulations. More recent contributions have explored other properties of
quaternion-based dynamic systems. For example, [36] and [37] proposed fractional sliding-
mode controllers using quaternions to stabilize the quadrotor attitude dynamics, while also
considering finitetime convergence of the system dynamics based on a fractional-order system.
In [38], researchers estimated quadrotor position and attitude information during aggressive
trajectories by only employing cameras and inertial sensors, quaternion operations were used
in the proposed algorithm.

Furthermore, a trajectory tracking control law with finite-time convergence on the nonlin-
ear manifold SE(3) is more desirable since most of the existing finite-time control law only
stabilizes attitude. The closed-loop systems under finite-time control usually demonstrates
faster convergence rate, higher tracking precision, better disturbance rejection properties and
robustness against uncertainties [39, 40, 41]. A continuous finite-time controller based on
homogeneity was developed for robot manipulators in [42]. Following the same ideas, in [43] a
finite-time attitude stabilizing result based on homogeneous method was presented. Latter on,
this work was improved in [44] but in this case, the attitude was represented using Modified
Rodriguez Parameters. A finite-time stabilization law with almost global convergence was
developed for a rigid body using rotation matrices for representing attitude in [45, 46] but the
method was not extended for the position dynamics.




8


                                                                              1.3. State of the art


Autonomous navigation algorithms

Planning algorithms

Trajectory planning problems for quadrotors were not widely studied using these approaches.
This problem is mostly characterized as an optimization problem subject to constraints as
velocity, bounded input, etc [47], [48]. Nevertheless, the path planning for autonomous navi-
gation have been studied in many fields, including robotics, aerial vehicles, aquatics vehicles
and space aircraft [49], [50], [51]. Yang et al. [52] treated the problem of time-optimal control
of a quadcopter by using a nonlinear programming method coupled with a genetic algorithm.
They succeeded to generate in simulation minimum time point-to-point trajectories under
various technological constraints. Cowling et al. [52] presented an optimal trajectory planner
with a linear control scheme to follow a reference trajectory. Authors exploited the differential
flatness of the quadcopter to address the optimization problem within the output space.

In addition, in [53] the authors proposed a model predictive control based on trajectory track-
ing system for small unmanned helicopters. It is based on a linear model predictive controller
and the simulations results show a good robustness for parameter uncertainty. In [54] au-
thors addressed the stabilization with motion planning problem of a standard quadcopter.
They showed that the system presents a flat output and exploited this fact in the treatment
of the motion generation problem. Recently in [55] the authors introduce an architecture
approach based on MPC for path planning in aerial vehicles. The approach considers the
tactical formulation and reformulation of optimization parameters and constraints based on
self-assessment and feasibility information from the MPC framework. The applicability of
chosen approach has been demonstrated in simulative set-up for several planning scenarios.

A linear and nonlinear model predictive control scheme were presented in [56] to control a
quadcopter platform with the goal to track various reference trajectories. The closed loop
stability analysis of the linear and nonlinear control schemes were presented to show the
similarities, as well as to highlight the differences. In [57] the authors develop a framework
for real time, full-state feedback, unconstrained, nonlinear model predictive control that
combines trajectory optimization and tracking control in a single, unified approach. The
performance of the approach was validated on two different hardware platforms, an AscTec
Firefly hexacopter and the ball balancing robot Rewero. More recent works as [26] present a
trajectory generation algorithm that allows the fast computation of high-performance flight
trajectories to move the quadcopter from a large class of initial states to a given target location.
The algorithm was computed in a ground station and not on-board. In [58] the authors have
been developed by solving an optimal control the minimum-energy paths trajectories. Only
simulations were developed to validate the strategy established.




                                                                                                  9


Introduction


Aerial visual servoing

Regulation of visual relative position and yaw with a quadrotor, assuming 2D ground target,
has been studied for landing [59], and saturated visual servoing [60], using spherical projection
[61], also assuming that the target remains in the FoV, though [62] addressed how to handle
constraints to enforce that, improving the control loop with a backstepping scheme in [63].
Moreover, simplified control design can be obtained with the virtual camera approach, [64],
or exploiting the conventional perspective projection, [65], which represents image plane
velocity at predefined height. In contrast, most approaches use the well-known eye-in-hand
Image-Based Visual Servoing of [66], to derive an orthodox visual servoing of a ground target
by quadrotors, [67]. However, neither approaches consider any physical constraint of the
mobile robot and the quadrotor capabilities or limitations. Due to the complexity of airborne
visual tracking, multiple processing units are considered to switch and balance computational
load, [68]. Optical flow is a cautious alternative to provide damping at image plane, [69], given
that it is not a derivative, similar to [68].

Advanced control schemes have been proposed, such as fractional control with conventional
vision, [70], however the power of such scheme is not exploited due to its assumptions, which
are based on conventional ideal conditions. The difficulty to implement the scheme arises
since it considers attitude acceleration measurements, thus chattering is introduced in the
second derivative of position control, unlike [71] where complex disturbance are compensated
with continuous fractional control. Path tracking is also considered in [72] by formulating a
constraint quadratic program problem given the field of view and maximum acceleration,
however the numerical solution may not guarantee smooth enough trajectories, which may
demand a high battery consumption attempting to reduce L 2 norm.

Furthermore, a fuzzy engine is proposed to smooth out and produce allowable quadrotor
trajectories from monocular camera, [73], however neglecting the physics of quadrotor and
mobile robot, similar to [74], where a hybrid scheme is proposed with a mobile manipulator,
with dual-task planning. More general sensory data are considered for drones to propose
obstacle evasion and target, nevertheless assuming in addition perfect knowledge of obstacles
and target for intersection planning in looking-ahead trajectories, [75], even in civil cluttered
flying conditions, [76], all based on potential fields and civil aviation rulings, [77]. For missile
drones, the look-ahead scheme is more critical, [78], similar to heavy oil tankers, [79], to avoid
obstacles and converge to the target. In addition, it is customary to assume monocular camera
based on the virtual camera approach that aligns the image plane collinear to the ground
plane of the vehicle.




10


                                                                              1.3. State of the art


Semi-autonomous navigation

In extreme or unsafe environments (space exploration, tele-surgery, mine excavation, high
pressure, high temperature, biological contamination and so on), traditional methods in-
evitably expose operators to danger on-site. Teleoperation systems are a promising solution
when it is physically dangerous or impossible for an operator to be in a piece of a equipment
or its neighborhood. Despite the concept of teleoperation was proposed decades ago [80],
it has not been widely implemented in real applications. One of the major impediments is
associated with the user’s limited situational awareness [81]. It is defined as “the perception of
the elements in the environment within a volume of time and space, the comprehension of
their meaning, and the projection of their status in the near future” [82].

New remote interaction solutions such as voice or video conferencing have reached a high
level of sophistication and widespread use as an aid for the solution of the teleoperation
problem. While the feeling of being present in a remote environment is clearly available with
these systems, a complete immersion cannot be realized without the possibility of physical
interaction with the remote environment. Haptic solutions, as an extension of visual and
auditory modalities, refer to both kinesthetic and tactile information and include position,
velocity, force, torque, vibration, etc. Using a teleoperation system with haptic feedback,
the users can thus truly immerse themselves into a distant environment, i.e., modify it, and
execute tasks without physically being present but with the feeling of being there. Several
possible teleoperation schemes using haptic feedback to steer single or multiple robots have
been proposed in the last decade [83, 84, 85, 86, 87, 88].

Within the robotics field, there has been great enthusiasm on multi-rotor vehicles due their
characteristics: hovering capability, maneuverability and small size. Most of the applica-
tions designed for these vehicles concern, inspection and surveillance of places where can
result inaccessible by humans. The possibility of letting aerial robots interacting with the
environment, opens an additional wide set of potential applications for aerial robots like, i.e.,
maintenance, construction, cooperative grasping and transportation. Most of them require
the physical interaction of the robots with the surrounding objects and uncertain and un-
known environments that could make the fully-autonomous control of the vehicle practically
unreliable. Thus, the teleoperation intervention becomes advisable to handle this kind of
issues. In [89, 90, 91, 92] a bilateral teleoperation for Vertical Take off Landing (VTOL) vehicles,
based on impedance controllers with haptic feedback and considering time-varying delays
were carried out. Main results consist in providing the stability of the teleoperation loop with
respect to bounded external forces (i.e. operator and environment forces). Simulation and
experimental results were showed to verify the effectiveness and performance of the proposed
schemes.

One important feature in a teleoperation system is the visual feedback of the remote environ-
ment. It comes often from one or more monocular cameras mounted on the robot, which lead
to several problems as the limited field of view (FoV), lack of visualization and poor visibility.



                                                                                                11


Introduction


New different aerial drones teleoperation, considering in a different manner the visual feed-
back, have been developed based on graphic interfaces [93, 94, 95, 96, 97, 98]. For instance,
several simulations and experimental tests for the inspection of buildings using interfaces
based on the head and gestures positions, and a wearable exoskeleton interface were pre-
sented in [93, 99]. The main strength of the proposed interaction methods is the ability to
perform multi-modal interactions. In [100] an experimental study of gaze-based control
modes for unmanned aerial vehicles with ten participants performing a simple flying task was
performed. Several experimental tests were carried out. Furthermore, an approach based on
Non-Invasive BCI device with expressive manner on face in remote presence using quadcopter
control with the Emotive EPOC headset was implemented in [101]. Electroencephalogram
signals were used in experimental tests to tele-operate the vehicle. A disadvantage for all of
these interfaces is that the recognition algorithms must be precise and that the user needs to
be close to the drone’s camera in order to recognize the gestures or visual markers. In other
words, it is required to have the vehicle in the line of sight (LoS).

Recent advances in the field of Virtual Reality (VR) have allowed to use this technology im-
proving the teleoperation systems [102, 103]. For example, in [104] an immersive Augmented
Reality (AR) environment for conduction remote maintenance via a robot has been proposed.
The AR environment has been designed to enhance the operator’s situational awareness of
the robot as well as the maintenance tasks so as to reduce the cognitive load on the operator.
However, neither simulation nor experimental tests were presented. In [105] a ground control
station for drones based in an immersive virtual environment was developed. The environ-
ment simultaneously informs the operator about the position and condition of the vehicles.
Hence, only simulation results were developed. Furthermore in [106] an interface based in a
mixed reality environment and natural language for controlling UAVs was developed. Real
experimental tests were carried out using a set of known virtual landmarks. Finally in [107] a
wearable interface for drone teleoperation is presented. This interface was constituted from a
data glove to allow the user to control the drone trajectory by hand motion and a haptic system
used to augment their awareness of the environment surrounding the robot. Nevertheless,
simulations and experimental tests were performed in line of sight.


Disturbance rejection robustness

With the increasing requirement of autonomous flight under different conditions, controlling a
quadcopter stills an important challenge, for example, the position and attitude controls of the
quadcopter are extremely sensitive to external disturbances, such as wind gusts. And therefore,
the design of robust regulators become more and more attractive to outdoor missions and
practical applications. In particular, robustness issues may be critical for quadcopter control
since they can be subjected to undesired nonlinear dynamics and external disturbances. In
order to weaken the effect of wind gusts, some authors have proposed complex control tech-
niques to achieve stability. To deal with this problem, in [108, 109, 110] adaptive controllers
with different structures were proposed and verified by simulations and experiments on test
bench.

12


                                                                            1.3. State of the art


Disturbance Observer Based Control (DOBC) has been demonstrated to deal with distur-
bances without adding a significant computational requirement. These techniques are based
on observing the inputs and the outputs of the plant and, based on the theoretical response
that should be obtained, attributing everything inexplicable to a disturbance [111]. Such
behavior can range from external disturbance to modeling errors and nonlinearities. Never-
theless, the provenance of the disturbance is not relevant for these methodologies. Among the
most used DOBC techniques are the following: Disturbance Observer (DOBC) [112], which
uses the theoretical transfer function to observe the theoretical input and the difference is
the disturbance; Active Disturbance Rejection Control (ADRC) [113], which approximates the
plant to a integrator chain and all the other behavior is disturbance; Generalized Extended
State Observer (GESO) [114], which uses an observer with the model and assumes that the dis-
turbance is constant, and the Uncertainty and Disturbance Observer (UDE) [115], which uses
the model and the known plant state in order to obtain an approximation of the disturbance.

In addition to this, some works have been proposed to deal with variable delays [116] or
even Networked control systems [117] in order to add uncertainties that could arise into
the system and as well as improving the robustness in minimum phase systems [118, 119].
Likewise, these techniques have been successfully validated in multitude of real problems
such as robotic manipulators [120], positioning of UAVs [121] or the magnetic levitator [122].
Among the presented techniques is worth to mentioning the UDE. In the state of art of this
technique, there are many examples that have been validated experimentally when dealing
with the quadrotor system. For instance, in [123], a comparison between the UDE and the
classic PID to highlight the advantages and disadvantages of each one of the controllers is
presented. Furthermore, a quadrotor slung load control, where the UDE compensates the
variable mass, was proposed in [124]. And finally, in [125], the authors present a study of the
UDE for controlling a quadrotor using the quaternion formalism.


Dealing with rotors failures

Fault Tolerant Control (FTC) techniques [126] are used to deal with failures that could arise
from the system, preventing the performance degradation and making the control system
safe and reliable. These techniques can be classified into passive and active [127]. In the first
case, the controller works itself to minimize the effect of the failures but, it is not capable to
overcome them. Nevertheless, in the second case, when the fault occurs, a self-reconfigurable
controller is applied in order to maintain the desired performance of the system. These kinds
of techniques generally use the following methodology [128]: the identification of the plant in
regular operation, control tuning for the regular operation, detection and identification of the
possible fault and, the control law reconfiguration.

For instance in [129], the authors proposed an active FTC based on a Gain-scheduled PID
combined with an observer capable to detect and identify faults on a quadrotor.




                                                                                               13


Introduction


A passive FTC was proposed in [130, 131] using a Sliding Mode Control (SMC) combined
with a heuristic controller that was optimized for different possible faults scenarios and in
[132] an extra sensor observer for thrust fault was presented. Recently, works on active FTC
for quadcopter vehicles subjected to actuator partial faults can be found in [133, 134, 127].
In [133], [134] the faults were injected when the vehicle is flying at hover position. To the
best of our knowledge, only a few experimental validation for a quadcopter flying in a non-
hover position have been validated, see [127] and [135]. In [127], the authors developed a
Fault Detection (FD) and accommodation algorithm using nonlinear adaptive estimation
techniques. In addition, three observers were considered for the FD: a nonlinear adaptive
observer and a linear Proportional-Integral Observer (PIO) applied to a Planar VTOL and a
quasi-Linear Parameter Varying (qLPV) for a quadcopter.


Dealing with rotor’s constraints

Despite several works found in the literature proposing robustness into the system, few of
them bounds the control inputs for limiting the energy applied into the system. This is,
because in some cases bounding, the control input the robustness is only guaranteed in a
small range of external disturbances.

Bounding the control input is a challenge when implementing theoretical control results in
real systems because, if the control signal exceeds the control inputs limits, it may lead to
undesirable behavior of the system and damage its performance. The anti-windup technique
is frequently used in wide range of applications to solve this problem. For example, the
analysis of the aircraft control system with input saturation conducted in [136] has shown
existence of hidden oscillations, which were compensated by an anti-windup scheme. In [137]
the anti-windup approach was proposed and then applied for the aircraft control problem
in [138, 139]. This anti-windup algorithm was based on the property of convergence for
marginally stable linear plants with saturated inputs. Furthermore, in [140] an iterative thrust-
mixing scheme based on the LQR approach, to compute the desired single rotor thrusts and a
prioritizing motor-saturation, was validated in real-time tests. In [141], a cascade integration
of Incremental Nonlinear Dynamic Inversion (INDI) for the attitude and position control
of micro aerial vehicles is addressed. Wind tunnel experiments show that the vehicle can
enter and leave the 10 m/s wind tunnel flow with only 21 cm maximum position deviation on
average. In most of all these works, the desired collective thrust and body torques need to be
converted into four single rotor thrusts, which can then be applied by knowing the mapping
from motors commands to rotor thrusts, denoted as thrust mapping.




14


                                                                             1.4. Thesis outline


1.4 Thesis outline
This thesis is structured into four Chapters. Chapter II provides an introduction to the classi-
cal modeling quadrotor approaches. Fundamental concepts regarding the Euler-Lagrange,
Newton-Euler and quaternion formalism are revisited.

A unified and accessible analysis, placing popular control algorithms into a proper context are
addressed in Chapter III. The chapter is divided as follows: a comparison between popular and
virtual control algorithms and a meticulous analysis is introduced in this chapter. Furthermore,
a quaternion-based backstepping control is developed in the chapter. Finally, the finite-time
convergence using sliding mode control is revisited. Experimental and numerical simulations
results are provided to verify the performance of each control technique.

Part IV establishes some autonomous and semi-autonomous navigation algorithms that are
combined with the controllers developed in Chapter III. This chapter is divided as follows: a
path planning algorithm using model predictive control for the trajectory generation, a visual
servoing control for the tracking and target detection and finally, a virtual control architecture
for controlling robots remotely using a immersed virtual environment. Experimental results
are provided in order show the good performance of the proposed algorithms as well their
limitations.

Finally, Chapter V takes a slightly different perspective, as it provides a comprehensive and
unified guide to understand disturbance rejection based observers from the theoretical and
experimental point of view. This chapter is divided into three sections: the introduction
of a robust control scheme for counteracting undesired dynamics, the enhanced robust
architecture for counteracting loss of effectiveness in rotors, and a robust bounded control
to handle motors constraints while counteracting external perturbations. Several numerical
and experimental results are exposed to demonstrate the good performance of the developed
architectures.




                                                                                               15




Chapter 2 Part II




                    17




2 Modeling quadcopter vehicle ap-
  proaches

 Before stepping into the quadrotor control and navigation design, the mathematical model of
 the vehicle must be studied. The aim of this chapter is to present popular modeling approaches
 that exploit the whole properties of the vehicle. Considering all the parameters that fulfill
 the complete dynamic model of an aerial robot, e.g., the aeroelastic flutter effect, internal
 dynamics of the rotors, etc, are particularly important for control purposes. However, it comes
 when a whole set of changing variables that sometimes becomes unmanageable. Therefore, it
 is interesting to consider also simplified models constituted by a minimum number of states
 and inputs, but retaining the main features that must be considered when designing control
 laws for a real aircraft.
 Most of the work developed for representing the dynamics of aerial vehicles are based on the
 Euler angles convention. This method is intuitive and easy to implement when simplifications
 are considered, e.g. non acrobatic maneuvers (slow movements, small angles). However,
 when more difficult tasks or applications are involved, the mathematical representation of
 the robot using this approach encounters some problems such as, complicated non-linear
 mathematical expressions, singularities, and gimbal lock.
 Other option for representing the rotation of rigid bodies is the quaternion algebra. This kind
 of formalism has considerable advantages in comparison with the Euler angles method. For
 instance: lack of discontinuities and gimbal lock, and provision of mathematical simplicity.
 Moreover, quaternion multiplication makes less computational overhead in comparison to
 Euler angles because of its vector representation. In addition, quaternions need less memory
 space in comparison to Euler angles.
 The models for the aerial vehicle developed in this thesis assume the following:

     • The structure is supposed rigid.
     • The structure is supposed symmetrical.
     • The CoG and the body fixed frame origin are assumed to coincide.
     • The propellers are supposed rigid.
     • Thrust and drag are proportional to the square of propeller’s speed.

                                                                                             19


Chapter 2. Modeling quadcopter vehicle approaches


This chapter is organized as follows: Section 2.1 introduces the elemental forces of a quadrotor
aircraft. In Section 2.2 some of the classical modeling approaches based on Euler angles are
presented. An explanation of the quaternion-based modeling methodology is detailed in
Section 2.3 and finally, some conclusions are discussed in Section 2.4.



2.1 Force and moment in a rotor
According to blade element theory, which is used to model airfoil and rotor performances, the
forces and moment developed on a uniform wing are determined by the lift and drag forces
and a pitching torque [142]. For a given rotor i with angular velocity ωi , the linear velocity at
each point along the propeller is proportional to the radial distance from the rotor shaft. Thus
the following equations can be stated [143]:

                                           f i = C T ρ A p r 2 ω2i
                                                                                               (2.1)
                                          τi = CQ ρ A p r 3 ω2i

where f i represents the total thrust produced by rotor i = 1, · · · , 4, acting perpendicularly to
the rotor plane neglecting blade flapping effect, τi describes the rotor torque, r denotes the
rotor radius, ρ symbolizes the air density and A p = πr 2 . C T and CQ are non-dimensionalised
thrust and rotor torque coefficients, which can be computed using blade element theory [144],
see Figure 2.1.




               Figure 2.1 – Propeller forces and torques acting on a quadrotor.


It is a common practice to consider the aerodynamic parameters from (2.1) as constants,
k T ≈ C T ρ A p r 2 , kQ ≈ CQ ρ A p r 3 . Taking into account a quadrotor symmetrical configuration,
the total torque and thrust force produced on the vehicle by the propellers are computed as

                                                τθ      l k T ω21 − ω21 − ω23 + ω24
                                                        ¡                      ¢
                               0
                  ~t h =              , ~
                                          τ =  τφ  = l k T ω21 + ω21 − ω23 − ω24  ,
                                                             ¡                      ¢
                  F            0                                                               (2.2)
                                               
                         
                          P4         2                       P4         2      2
                           i =1 k T ωi         τψ              i =1 kQ ωi (−1)

where τx , τ y and τz denote the total torque components produced on each axis of the body
reference frame, and F ~t h represents the total thrust force vector, acting in the vertical axis of
the quadrotor.

20


                                                                2.2. Classical modeling approaches


2.2 Classical modeling approaches
In this section the three most popular techniques for modeling aerial vehicles will be intro-
duced: the Euler-Lagrange, the Newton-Euler and the Euler-Lagrange based on quaternion
formalism.


2.2.1 Euler-Lagrange approach

The model is obtained by representing the aircraft as a rigid body evolving in a 3 − D space
due to the main thrust and three torques: pitch, roll and yaw as depicted in Figure 2.2.

Let the generalized coordinates of the aerial vehicle be expressed by

                                      ~ = (x, y, z, ψ, θ, φ) ∈ R6
                                      p                                                         (2.3)

where ~ξ = (x, y, z) ∈ R3 denotes the position of the center of mass of the quadcopter relative to
a fixed inertial frame I , and~η = (ψ, θ, φ) ∈ R3 are the Euler angles, ψ is the yaw angle around
the z−axis, θ is the pitch angle around the modified y−axis, and φ is the roll angle around the
modified x−axis, which represent the orientation of the quadcopter.




Figure 2.2 – Coordinate systems acting in the aerial vehicle where f i denotes the force applied
               ~t h symbolizes the total thrust force and θ, φ, ψ are the Euler angles on each
of each motor, F
axis.

Defining the Lagrangian
                                    L(~  ~˙ ) = T t r ans + Tr ot −U ,
                                      p, p                                                      (2.4)

where T t r ans = m ~˙T ~                                            1~ T ~
                  2 ξ ξ is the translational kinetic energy, Tr ot = 2 Ω I Ω means the rotational
kinetic energy, U = m~   g~
                          ξ represent the potential energy of the rotorcraft, ~
                                                                              Ω signifies the angular
velocity, I the inertia matrix, and ~
                                    g = [0 0 − g ] depicts the acceleration vector due the gravity.



                                                                                                  21


Chapter 2. Modeling quadcopter vehicle approaches


 The angular velocity vector ~
                             Ω resolved in the body frame is related to the generalized velocities
 ˙
~η by means of the kinematic relationship [145]

                                             ~η˙ = Wv−1~
                                                       Ω,                                       (2.5)

where
                          − sin θ                          φ̇ − ψ̇ sin θ
                                                                          
                                      0    1
                 Wv =  cos θ sin ψ cos ψ 0 , ~
                                               Ω = θ̇ cos φ + ψ̇ cos θ sin φ                  (2.6)
                                                                          

                       cos θ cos ψ − sin ψ 0        ψ̇ cos θ cos φ − θ̇ sin φ
                       T
Therefore Tr ot = 12~η˙ J~η˙ with J = J(~η) = WvT I Wv and
                                                                  
                                             I xx     0        0
                                        I = 0       Iyy       0 
                                                                  

                                               0      0       Iz z

Note, the matrix J = J(~η) acts as the inertia matrix for the full rotational kinetic energy of
the quadcopter expressed in terms of the generalized coordinates ~η. Then, the dynamics
equations describing the behavior of the full aerial vehicle are obtained from Euler-Lagrange
equations with external generalized forces

                                                       ~ξ
                                                      " #
                                       d ∂L ∂L         F
                                               −    =     ,                                     (2.7)
                                            ~˙
                                       d t ∂p    ∂~
                                                  p    ~
                                                       τ

where F       ~t h ∈ R3 is the translational force applied to the quadcopter due to main thrust
       ~ξ = R F
                                                ~t h = [0 0 u 1 ]T with u 1 = °F~t h °. R denotes the
                                                                              °      °
directed out of the top of the vehicle with F
rotational matrix R(ψ, θ, φ) ∈ SO(3) representing the orientation of the quadcopter relative to
a fixed inertial frame:

                                                                                   
                             CθCψ      C ψ S θ S φ −C φ S ψ    S φ S ψ +C φC ψ S θ
                        R = C θ S ψ   C φC ψ + S ψ S θ S φ    C φ S ψ S θ − S φC ψ            (2.8)
                                                                                   

                              −S θ            Cθ Sφ                   CθCφ

where C θ and S θ stand for cos θ and sin θ, respectively. Developing (2.7), the Euler-Lagrange
equation for the translation and attitude motion can be written as

                                            ¨ ~
                                          m~ξ=F  ξ − m~g                                        (2.9)
                                            ¨
                                          J~η =~         ˙ ~η˙
                                               τ − C(~η,~η)                                    (2.10)

            ˙ = J̇ − 1 ∂ (~η˙ T J) refers to the Coriolis term, which contains the gyroscopic and cen-
where C(~η,~η)       2 ∂~η
trifugal terms associated with the~η dependence of J. Expanding (2.10) is not an easy task and
in several works, the full inertia matrix J is considered as diagonal and the Coriolis matrix is ne-
glected.




22


                                                                               2.2. Classical modeling approaches


                                                                      ˙ is neglected. Thus, to
Let us consider the case where the J is considered diagonal and C(~η,~η)
simplify, it is possible to define

                                                     τ̃θ
                                                        

                                              ~
                                              τ̃ =  τ̃φ  = J−1 (~
                                                                          ˙
                                                                  τ − C(~η,~η)).                                         (2.11)
                                                    τ̃ψ

Finally, we obtain from (2.9) and (2.10) considering (2.11)

                                      m ẍ = −u 1 sin θ,                             θ̈ = τ̃θ
                                      m ÿ = u 1 cos θ sin φ,                        φ̈ = τ̃φ                            (2.12)
                                      m z̈ = u 1 cos θ cos φ − mg ,                  ψ̈ = τ̃ψ

where x and y are coordinates in the horizontal plane, z is the vertical position, and τ̃ψ ,τ̃θ ,
and τ̃φ are the yawing moment, pitching moment, and rolling moment, respectively.
For the case when the Coriolis and the inertial matrix for the~η dynamics in (2.7) are considered,
therefore, rewriting the attitude dynamics yields

                                                      ∂~            ~
                                                 "         #
                                              d        Ω      ~T I ∂Ω =~
                                                  ~ T
                                                  Ω I        −Ω        τ,
                                              dt      ∂~η˙         ∂~η

       ∂~                   ~
then    Ω
       ∂~η
             = Wη , ~
                    ΩT I ∂Ω˙ = [b 1 b 2 b 3 ] with
                           ∂~η


              b 1 = −I xx (φ̇S θ − ψ̇S θ2 ) + I y y (θ̇C θ S φC φ + ψ̇C θ2 S θ2 ) + I zz (ψ̇C θ2C φ2 − θ̇C θ S φC φ ),
                                                                              2
              b 2 = I y y (θ̇C φ2 + ψ̇C θ S φC φ ) − I zz (ψ̇C θ S φC φ − θ̇S φ ),
              b 3 = I xx (φ̇ − ψ̇S θ ).

                             ~
differentiating ~
                ΩT I ∂Ω˙ ,
                            ∂~η

                                                                         ³
       ḃ 1 = −I xx φ̈S θ + φ̇θ̇C θ − ψ̈S θ2 − 2ψ̇θ̇S θ C θ + I y y θ̈C θ S φC φ − θ̇ 2 S θ S φC φ − θ̇ φ̇C θ S φ2
                      ¡                                        ¢
                                                                               ´       ³
                                       2
            + θ̇ φ̇C θ C φ2 + ψ̈C θ2 S φ                  2
                                         − 2ψ̇θ̇S θ C θ S φ + 2ψ̇φ̇C θ2 S φC φ + I zz ψ̈C θ2C φ2 − 2ψ̇θ̇S θ C θ C φ2
                                                                                              ´
            −2ψ̇φ̇C θ2 S φC φ − θ̈C θ S φC φ + θ̇ 2 S θ S φC φ + θ̇ φ̇C θ S φ2
                                                                               − θ̇ φ̇C θ C φ2 ,
                   ³                                                                                       ´
       ḃ 2 = I y y θ̈C φ2 − 2θ̇ φ̇S φC φ + ψ̈C θ S φC φ − ψ̇θ̇S θ S φC φ + ψ̇φ̇C θ C φ2 − ψ̇φ̇C θ S φ   2
                   ³                                                                                      ´
                                                                 2
            − I zz ψ̈C θ S φC φ − ψ̇θ̇S θ S φC φ − ψ̇φ̇C θ S φ                          2
                                                                   + ψ̇φ̇C θ C φ2 − θ̈S φ  − 2θ̇ φ̇S φC φ ,

       ḃ 3 = I xx φ̈ − ψ̈S θ − ψ̇θ̇C θ .
                   ¡                       ¢


Similarly,
                                                 −ψ̇C θ
                                                                                       
                                              0                              0
                                        ~
                                       ∂Ω 
                                           = 0 −ψ̇S θ S φ           −θ̇S φ + ψ̇C θ C φ 
                                                                                        
                                       ∂~η
                                              0 −ψ̇S θ C φ           −ψ̇C θ S φ − θ̇C φ


                                                                                                                            23


Chapter 2. Modeling quadcopter vehicle approaches

                ~
then ~
     ΩT I ∂∂~Ω
             η
               = [h 1 h 2 h 3 ], where

h 1 = 0,
                                         ³                                 ´       ³                                 ´
                                                                         2
h 2 = −I xx ψ̇φ̇C θ − ψ̇2 S θ C θ − I y y ψ̇θ̇S θ S φC φ + ψ̇2 S θ C θ S φ   − I zz ψ̇2 S θ C θ C φ2 − ψ̇θ̇S θ S φC φ ,
           ¡                     ¢

                                      2
h 3 = I y y (−θ̇ 2 S φC φ − ψ̇θ̇C θ S φ                                                                    2
                                        + ψ̇θ̇C θ C φ2 + ψ̇2C θ2 S φC φ )I zz (−ψ̇2C θ2 S φC φ + ψ̇θ̇C θ S φ − ψ̇θ̇C θ C φ2 + θ̇ 2 S φC φ ),

such that
                                                            τθ
                                                                            
                                                                    ḃ 1 − h 1
                                                           τφ  = ḃ 2 − h 2  .
                                                                            

                                                           τψ       ḃ 3 − h 3

Then, regrouping all the terms developed above and using (2.10), thus, J is expressed as

                                                   2
                          I xx S θ2 + I y y C θ2 S φ + I zz C θ2C φ2
                                                                                                                
                                                                       C θ C φ S φ (I y y − I zz )   −I xx S θ
            J(~η) =            C θ C φ S φ (I y y − I zz )                                   2
                                                                          I y y C φ2 + I zz S φ         0              (2.13)
                                                                                                                
                                                                                                                 
                                         −I xx S θ                                   0                 I xx ,

and                                                                                      
                                                             c 11        c 12        c 13
                                                       ˙
                                                 C(~η,~η) = c 21
                                                            
                                                                         c 22        c 23 
                                                                                          
                                                                                                                       (2.14)
                                                             c 31        c 32        c 33

where
                                                2
     c 11 = I xx θ̇S θ C θ + I y y (−θ̇S θ C θS φ + φ̇C θ2 S φC φ) − I zz (θ̇S θ C θ C φ2 + φ̇C θ2 S φC φ ),
                                                           2
     c 12 = I xx ψ̇S θ C θ − I y y (θ̇S θ S φC φ + φ̇C θ S φ                            2
                                                             − φ̇C θ C φ2 + ψ̇S θ C θ S φ )
                           2
           + I zz (φ̇C θ S φ − φ̇C θ C φ2 − ψ̇S θ C θ C φ2 + θ̇S θ S φC φ )
     c 13 = −I xx θ̇C θ + I y y ψ̇C θ2 S φC φ − I zz ψ̇C θ2 S φC φ ,
                                                2
     c 21 = −I xx ψ̇S θ C θ + I y y ψ̇S θ C θ S φ + I zz ψ̇S θ C θ C φ2 ,
                                                                                                                       (2.15)
     c 22 = −I y y φ̇S φC φ + I zz φ̇S φC φ ,
                                                                 2
     c 23 = I xx ψ̇C θ + I y y (−θ̇S φC φ + ψ̇C θ C φ2 − ψ̇C θ S φ                   2
                                                                   ) + I zz (ψ̇C θ S φ − ψ̇C θ C φ2 + θ̇S φC φ ),
     c 31 = −I y y ψ̇C θ2 S φC φ + I zz ψ̇C θ2 S φC φ ,
                                                    2
     c 32 = −I xx ψ̇C θ + I y y (θ̇S φC φ + ψ̇C θ S φ                                2
                                                      − ψ̇C θ C φ2 ) − I zz (ψ̇C θ S φ − ψ̇C θ C φ2 + θ̇S φC φ ),
     c 33 = 0.

Although (2.9) and (2.10) were developed taking into account a multicopter with four rotors,
these equations are also valid for other aerial configurations as long as the forces and torques
are rewritten.




24


                                   2.3. Quadrotor quaternion model based on Euler-Lagrange


2.2.2 Newton-Euler approach

The general motion of a rigid body in space is a combination of translational and rotational
motions. Consider a rigid body moving in inertial space, undergoing both rotations and
translations, see Figure 2.2. Following same ideas as in section 2.2.1, let us define now an earth
fixed frame I and a body frame B . The center of mass and the body frame are assumed to
coincide. Using Euler angles parametrization, the airframe orientation in space is given by a
rotation matrix R from B to I . Using the Newton-Euler formalism [146, 147, 148, 149], the
dynamics of a rigid body under external forces applied to the center of mass and expressed on
earth fixed frame is
                         ~˙                                    ~t h (t ) − m~
                          ξ(t ) = ~
                                  v (t ),       v˙ (t ) = R(t )F
                                               m~                           g,
                                                                                            (2.16)
                         Ṙ(t ) = R(t )~  ˆ ),
                                        Ω(t      I~Ω˙ = −~ Ω(t ) × I ~      τ(t )
                                                                     Ω(t ) +~

where ~ ˆ ) introduces the skew-symmetric matrix of ~
        Ω(t                                         Ω(t ), and I represents the constant
inertia matrix.

Considering the total forces and torques from (2.2), and introducing them into (2.16), it follows
that,
                                      m ẍ = − sin θu 1 ,
                                      m ÿ = cos θ sin φu 1                                       (2.17)
                                      m z̈ = cos θ cos φu 1 − mg

                           θ̈            τθ                                 θ̇
                                                                    
                                               c 11         c 12   c 13
                                   −1 
                          φ̈  = J  τφ  − c 21         c 22   c 23   φ̇  .               (2.18)
                                                                      

                          ψ̈            τψ     c 31         c 32   c 33 ψ̇

Equations (2.17) and (2.18) describes the translational and rotational dynamics, respectively.
Remark that making the same assumptions as before, an inertial diagonal matrix and that the
Coriolis matrix is neglected, it is possible to obtain the same equations as in (2.12).


2.3 Quadrotor quaternion model based on Euler-Lagrange
For consistency reasons, and for building the mathematical background for following the
proposed modeling, it is essential to understand quaternions and their associated algebra
[150]. Quaternions were proposed by Hamilton in the nineteen century as a three-dimensional
version of complex numbers (one real and one imaginary part). However, they can be also
written as a vector with 4 scalar components, q 0 , q 1 , q 2 , q 3 , where q 1 , q 2 , q 3 correspond to
the distance along the quaternion bases vector of i , j , k and q 0 is considered the scalar part
of the quaternion.

They are also known as a 4−dimensional hyper-complex number, since they can be repre-
sented as one real plus three imaginary numbers, q , q 0 + q 1 i + q 2 j + q 3 k, where i , j , k ∈ I,
such that i 2 = j 2 = k 2 = i j k = −1 and q 0 , · · · , q 3 ∈ R.

                                                                                                      25


Chapter 2. Modeling quadcopter vehicle approaches


Another common representation of a quaternion is using one scalar number and a vector as
q , q0 + ~
         q , with ~
                  q = [q 1 q 2 q 3 ]T . In literature, one of the well-known expression to denote
a quaternion relays on the representation given by the French bankern Olinde Rodriguez.
He expanded the Euler’s Formula to include 3−dimentional rotations using quaternions.
This expression is known nowadays as the Euler-Rodrigues formula which is the exponential
mapping of the axis-angle representation ~       n , ς of a rotation defined as
                                          1
                                q = exp 2 ς~n = cos (ς/2) +~
                                                           n sin (ς/2)                (2.19)
            ° °
notice that °q ° = 1, thus q can be called a unit quaternion. Operations with quaternions
are not solved with standard mathematical tools, therefore, the basisc quaternion operations
must be defined.

Quaternion algebra

Product
Consider two quaternion p and q that are in H. The quaternion product can be expressed as

                      p ⊗ q = (p 0 + p 1 i + p 2 j + p 3 k)(q 0 + q 1 i + q 2 j + q 3 k)
                                                                                           (2.20)
                                          ~ −~
                             = (p 0 q 0 − p           ~ ×~
                                                    ~+p
                                             q , q0 p    q ).

Remark that p ⊗ q 6= q ⊗ p.
Conjugate
The conjugate of a unit quaternion expresses an inverse rotation over the same axis, and is
defined as
                                       q ∗ := q 0 − ~
                                                    q                                (2.21)

Norm
The norm of a quaternion is defined as
                             ° °2
                             °q ° = N 2 (q) = q 2 + q 2 + q 2 + q 2
                                               0     1     2     3
                                                                                           (2.22)
                                                    = q ⊗ q∗

Inverse
For any non-null quaternion there exists an inverse quaternion such that
                                                        q∗
                                               q −1 := ° °                                 (2.23)
                                                       °q °

Vector rotation
Considering p~ ∈ R3 as a 3D vector in a first reference frame (e.g. the earth coordinates), and
~0 as the same vector but now with respect to a new reference frame (e.g. a vehicle’s moving
p
                   ~ can be transformed into p
coordinates), then p                             ~0 using a double quaternion product as

                                                ~ ⊗ q = q∗ ⊗ p
                                    ~0 = q −1 ⊗ p
                                    p                        ~⊗q                           (2.24)




26


                                   2.3. Quadrotor quaternion model based on Euler-Lagrange


Derivative
The derivative of any unit quaternion can be defined as follows

                                                         θ            θ
                                                        µ ¶          µ ¶
                           q(t ) = q 0 (t ) + ~
                                              q (t ) = cos   +~u sin
                                                         2            2
                                                                                              (2.25)
                                                             ∆t            ∆t
                                                            µ ¶           µ ¶
                         q(∆t ) = q 0 (∆t ) + ~
                                              q (∆t ) = cos       +~u sin
                                                              2            2

where q(∆t ) is a quaternion that represents an infinitesimal change in the angle while keeping
the same unit vector ~u . Thus the derivative of a unit quaternion can be expressed as

                                                             ~
                                                             u
                                     d               q(1 + ( 2 )∆θ)
                                        q(t ) = lim
                                     dt        ∆t →0       ∆t
                                                            u ∆θ
                                                     1 q(t )~                                 (2.26)
                                              = lim
                                               ∆t →0 2    ∆t
                                                1
                                              = q(t ) ⊗ ~
                                                        ω(t ).
                                                2

where ~ ω(t ) = θ̇~
                  u corresponds to the angular velocity vector associated with the quaternion
q(∆t ).


2.3.1 Quadrotor quaternion dynamical model

Let us consider that the center of mass of the quadcopter is aligned with the origin of the body.
The vector ~ ξ goes from the origin of the inertial frame to the body frame and it is described
                  ˙                       ˙
   ~              ξ = [ẋ ẏ ż]T , where ~
as ξ = [x y z]T , ~                       ξ defines the translational velocity seen from the inertial
frame. Inspired on the Lagrangian methodology, the translational kinetic energy is defined as
           ˙T ˙
           ξ ~
E kt = 12 m~  ξ and the potential energy U p = mg e z where the mass of the vehicle is described
by m, e z is a unitary vector with the form e z = [0 0 1]T and g is the term associated with the
gravitational acceleration.




                           Figure 2.3 – Quadcopter free body diagram


                                                                                                 27


Chapter 2. Modeling quadcopter vehicle approaches


Thus, using (2.7) the Euler-Lagrange equation for the translational system is expressed as
                                           Ã   !
                                        d ∂L T     ∂L T
                                                 −       ~t h
                                                        =F                                     (2.27)
                                             ˙
                                        d t ∂~
                                             ξ      ∂~
                                                     ξ

where L T = E kt −U p is the Lagrangian of the system, ~ ξ ∈ R3 are the generalized coordinates
and F ~t h are the external forces acting on the quadcopter, respectively. Then, developing (2.27)
it follows that                                    
                                          m ẍ      0
                                                       ~
                                        m ÿ  −  0  = F                                 (2.28)
                                               
                                                            th
                                      m z̈      −mg
The external forces acting on the quadrotor are the lift forces, which are produced by the rota-
                                                                                  ~t h = [0 0 u 1 ]T .
tion of the motors and propellers and its expression is defined as before stated, F
Remark that if the quadrotor changes its orientation (e.g., tracking a desired reference), the
weight vector, [0 0 − mg ]T is always pointing downward, this means that the vector needs
to be expressed in the inertial frame. However, the lift force changes its orientation as the
vehicle does it. This implies that the lift force needs to be defined in the body frame. Then,
considering the aforementioned, the external forces can be expressed as a function of the
attitude of the vehicle as
                                       ~ξ = q ∗ ⊗ F
                                       F           ~t h ⊗ q                                  (2.29)

where q = [q 0 q 1 q 2 q 3 ]T is the quaternion which defines the attitude performance of the
quadrotor. Using the quaternion algebra [150], the translation dynamic model (2.28) can be
rewritten as                                                       
                                 m ẍ        (−q 0 q 2 + q 1 q 3 )u 1
                               m ÿ  =     (q 0 q 1 + q 2 q 3 )u 1 .               (2.30)
                                                                   

                               m z̈       (q 02 − q 12 − q 22 + q 32 )u 1 − mg

For the rotational part, the Lagrangian can be written considering the kinetic rotational energy
as
                                                 1 T
                                         L r ot = ~Ω I~
                                                      Ω                                    (2.31)
                                                 2
where ~Ω is the angular velocity referred in the body frame. Remembering that the quaternion
used in this analysis has the constraint c = q T ⊗ q − 1 = 0, then, the Euler-Lagrange equation
for the attitude system is represented by

                                  d ∂L r ot     ∂L r ot      ∂c
                                     µ      ¶
                                              −          τ+λ
                                                        =~                                     (2.32)
                                       ˙
                                  d t ∂~
                                       Ω          ~
                                                 ∂Ω          ∂~
                                                              Ω

with λ representing the Lagrange multiplier. Using the property (2.26), the Lagrangian de-
scribed by the equation (2.31) can be rewritten as follows

                               L r ot = 2(G(q) ⊗ q̇)T ⊗ I ⊗ (G(q) ⊗ q̇)
                                                                                               (2.33)
                                      = 2q̇ T ⊗ (G T (q) ⊗ I ⊗G(q)) ⊗ q̇




28


                                      2.3. Quadrotor quaternion model based on Euler-Lagrange


or
                                 L r ot = 2(−G(q) ⊗ q̇)T ⊗ I ⊗ (−G(q) ⊗ q̇)
                                                                                                (2.34)
                                      = −2q T ⊗ (G T (q̇) ⊗ I ⊗G(q̇)) ⊗ q

where                                                                   
                                            −q 1       q0     q3    −q 2
                                    G(q) = −q 2      −q 3    q0     q1 
                                                                        

                                            −q 3       q2    −q 1    q0

which are two equivalent equations that will help us to get the Euler-Lagrange equation. Thus,
the expression ∂L~r ot in (2.32) can be rewritten using (2.34) as
                 ∂Ω
                                    ∂L r ot
                                            = −4(G T (q̇) ⊗ I ⊗G(q̇)) ⊗ q
                                     ∂q
                                                                                                (2.35)
                                           = −2G T (q̇) ⊗ I ⊗ (2G(q̇) ⊗ q)
                                           = −2G T (q̇) ⊗ I ~
                                                            Ω,

                   ∂L r ot
then, developing      ˙      in (2.32) using (2.33)
                    ∂~
                     Ω
                                     ∂L r ot
                                             = 4(G T (q) ⊗ I ⊗G(q)) ⊗ q̇
                                      ∂q̇
                                                                                                (2.36)
                                            = 2G T (q) ⊗ I ⊗ 2G(q) ⊗ q̇
                                            = 2G T (q) ⊗ I ~
                                                           Ω.

Finally, the temporal derivative of (2.36) is expressed as

                                 d ∂L r ot                                  ˙
                                                           Ω + 2G T (q) ⊗ I ~
                                           = 2G T (q̇) ⊗ I ~                Ω.                  (2.37)
                                 d t ∂q̇

For getting into the final dynamic model of the quadrotor, the analysis of the generalized
torques must be carried out. Considering the D’Alambert’s principle but on its rotational form:
                                                                             ~ can be described
the virtual work of a rigid body around an angle γ of an axis $ and a torque T
as follows
                                                   ~ )δγ
                                         δW = ($ · T                                      (2.38)

Notice that if k$k = 1, thus, it can be referred as a quaternion and the infinitesimal rotation
can be represented as
                                          q + δq = q ⊗ q δ                                (2.39)

subject to |q| = 1, |q δ | and |δq | << 1. Multiplying the conjugate q ∗ in both sides of (2.39), then

                                      q ∗ ⊗ q + q ∗ ⊗ δq = q ∗ ⊗ q ⊗ q δ
                                                                                                (2.40)
                                        [1 0] + q ∗ ⊗ δq = q δ .

Using the definition of the temporal derivative of a quaternion as stated in (2.25) and if
infinitesimal change are considered, δq can be expressed as



                                                                                                   29


Chapter 2. Modeling quadcopter vehicle approaches

                                                    µ ¶¸T
                                           δγ        δγ
                                     ·    µ ¶
                                 δq = cos     $ sin                                    (2.41)
                                           2         2

and the following approximation is valid
                                                  δγ
                                             ·       ¸
                                         qδ = 1 $      .                               (2.42)
                                                  2

Then using (2.42) in (2.40)
                                                       δγ
                                                  ·       ¸
                                               ∗
                                  [1 0] + q ⊗ δq = 1 $                                 (2.43)
                                                       2
which implies that q ∗ ⊗ δq is associated with the complex component of q δ and therefore the
following expression is considered valid
                                              δγ
                                         ō        = q ∗ ⊗ δq .                        (2.44)
                                              2

The virtual work can be rewritten using (2.44) in (2.39)

                                     δW = 2(q ∗ ⊗ δq ) ⊗~
                                                        τ                              (2.45)

According to the quaternion algebra [150], the expression (2.45) can be rewritten as

                                          τ> (G(q) ⊗ δq )
                                    δW = 2~                                            (2.46)

Thus, the virtual work is described as follows

                                   δW = (2G T (q) ⊗~
                                                   τ) ⊗ δ q                            (2.47)

Therefore, the generalized torques are

                                          ~ = 2G(q) ⊗~
                                          T          τ                                 (2.48)

Using (2.35), (2.36) and (2.48) in (2.32) and multiplying by G(q)

                          Ω + 2G(q) ⊗G T (q) ⊗ I ~
     4G(q̇) ⊗G T (q̇) ⊗ I ~                      Ω = 2G(q) ⊗G T (q) ⊗~
                                                                     τ + λ ⊗G(q) ⊗ q   (2.49)

Knowing that G(q̇) ⊗G T (q̇) = 1, G(q) ⊗G T (q) = 1 and that G(q) ⊗ q = 0, then

                                            ˙ + 2I ~
                                         2I ~
                                            Ω           τ
                                                   Ω = 2~                              (2.50)

Observe that the expression (2.50) has the form of the Newton’s equation that describes the
dynamics of a rigid body subject an external torques.

Thus, the rotational dynamic model of the quadrotor can be rewritten as
                                              1
                                        q̇ = − q ⊗ ~
                                                   Ω
                                              2                                        (2.51)
                                        ˙ = −~
                                       I~
                                        Ω     Ω× I~  τ
                                                  Ω +~



30


                                 2.3. Quadrotor quaternion model based on Euler-Lagrange


Therefore, the whole quadcopter dynamic model can be described using (2.30) and (2.51) as
                                    ˙                ˙
                                     ~                  ~
                                                                
                                     ξ                  ξ
                                    ¨ 
                                   ~              ~t h
                                                   F
                                   ξ =  q ⊗ m ⊗ q +~
                                                                
                                                           ∗
                                                           g                             (2.52)
                                    q̇         − 12 q ⊗ ~
                                                           Ω
                                                             
                                                                
                                    ~
                                    Ω˙      I −1
                                                 ¡
                                                     ~     ~
                                                  −Ω × I Ω +~τ
                                                               ¢




2.3.2 Decoupling the vehicle dynamics

As can be verified in (2.52), the dynamics of the quadcopter are completely coupled by means
of the orientation of F~t h depending on the vehicle’s attitude q. Nevertheless, using an ap-
propriate approach and some properties of unit quaternions, the quadcopter can be easily
controlled despite its underactuated nature.

Let us assume that (2.51) is stabilized using a control action ~  τ, then the quaternion attitude
will converge to q 0 = 1 + [0 0 0] while the axis-angle orientation δ and its angular velocity ~
                                  T
                                                                                                 Ω
will converge to zero. Given a desired attitude trajectory defined by a desired quaternion q d
and its angular velocity ~
                         Ωd , (2.51) can be defined in terms of the quaternion error q e , q d∗ ⊗ q
as
                                                   qe ⊗ ~
                                  " # "                         #
                                                 1
                                    q˙e          2      Ωe
                                    ˙ = I −1 ¡−~               ¢ ,                          (2.53)
                                    ~
                                    Ω e           Ωe × I ~   τ
                                                         Ωe +~

if ~
   τ is correctly designed in terms of the attitude error, then, q e → q 0 implying that q → q d .

                                                               ~t h ⊗ q ∗ can be easily designed
                                                      ~ξ = q ⊗ F
From (2.30) and considering the desired force (2.29), F
                 ˙
          ξ and ~
such that ~     ξ converge to zero. If a position error is defined as ~         ξ −~
                                                                           ξe = ~  ξd , where ~
                                                                                              ξd
represents a desired position for the vehicle, then the translational dynamics error can be
written as                            "˙ # " ˙ #
                                       ~ξe        ~
                                                  ξe
                                        ¨  =    ~ξ                                    (2.54)
                                       ~ξe
                                                F
                                                   −~g
                                                   m

                                                        ~ξ , the error position will converge to
Consequently, if an adequate controller is designed for F
zero, meaning that the quadcopter can be stabilized at any desired position.

From (2.54), it yields that the translational model can be seen as a virtual fully actuated system
where F  ~ξ can be designed to point at any direction. Let us define a desired force vector U~ ∈ R3
with respect to the frame I , which stabilizes the system (2.54). Given the direction and
magnitude of such force vector, the attitude can be controlled using ~   τ such that the direction
   ~                   ~
of F ξ is aligned with U , orientating the quadcopter thrust in the required direction to control
the translational dynamics. Therefore, the desired quaternion q d is derived from the shortest
rotation between these both vectors.




                                                                                                 31


Chapter 2. Modeling quadcopter vehicle approaches


Recalling the Euler-Rodrigues formula from (2.19), q d is defined as
                                           1
                                 q d = exp 2 ς~n = cos(ς/2) +~
                                                             n sin(ς/2),                   (2.55)

where ~                                                                             ~ , respec-
                                                                           ~t h and U
        n and ς denote the axis and the angle of shortest rotation between F
tively. Defining~υ and ~
                       µ as normalized vectors of F         ~ where, notice that~υ = [0 0 1]T is
                                                   ~t h and U
constant. The cross and the scalar products between these two vectors are defined as, see
Figure 2.4

                                   ~                µ ~υ sin(ς)~
                                             µ)~υ = ~
                                   µ ×~υ = S(~                 n,                          (2.56)
                                    ~       µ ~υ cos(ς).
                                    µ ·~υ = ~                                              (2.57)




                 Figure 2.4 – Illustration of the Cross product of two vectors


Remark from (2.55), the Euler-Rodrigues formula uses the half angle, thus the well-known
trigonometry half angles formulas are required
                                    s                                     s
                           ³ς´          1 + cos(ς)             ³ς´            1 − cos(ς)
                     cos         =±                      sin         =±                    (2.58)
                            2                2                  2                  2

Thus, the desired attitude that aligns the thrust vector to the control direction can obtained
from (2.55) using (2.56), (2.57) and (2.58) as

                                                    q               
                                                           µ ~υ
                                                         1+~
                                                           2
                                      q t = ± q                                           (2.59)
                                                                    
                                                                     
                                                       µ ~υ
                                                     1−~
                                                       2 S(~µ)~υ
where
                                                                  µ2
                                                                     
                                               0      −µ3
                                        µ) =  µ3
                                      S(~              0          −µ1 
                                                                     

                                              −µ2      µ1          0

32


                                                          2.4. Modeling approaches conclusions


Notice that since~υ is always aligned with the vertical axis of the body frame B and the direction
of (2.59) is defined by a cross product, then q t rotates the vehicle in the x y plane. An additional
rotation around the z−axis can be added by introducing

                                           qd , q t ⊗ q z ,                                   (2.60)

where q z represent the desired rotation over the z−axis.


2.4 Modeling approaches conclusions
The aim of this chapter was to give an introduction to the main mathematical concepts for
getting into the dynamic modeling of a quadrotor vehicle, using one of the three existing
approaches in literature: Newton-Euler, Euler-Lagrange and quaternion formalism. Even
this kind of UAVs are inherently underactuated, an approach using the quaternion formalism
was introduced such that its dynamic equations can be analyzed and treated as a virtual fully
actuated system.

Most robotics research works, particularly in UAVs, have been relied on Euler angles con-
vention. However, the presence of important non-linearities, undesired effects, e.g. gimball-
lock, and an inherent complexity when multiple rotations and transltations are present, may
hamper the development in the performance of the control algorithms and its applications.
Nevertheless, although the quaternion formalism can seem to be less intuitive and difficult to
conceptualize, their application can really simplify dynamic models, and help in the design of
better controllers.




                                                                                                  33




Chapter 3 Part III




                     35




3 Control approaches for aerial vehicles


 Controlling a quadcotper vehicle has been extensively studied in the past decade with the
 recent increase on the power computation for embedded systems. These systems are now
 able to perform the computations needed for a variety of control techniques, with lower cost
 of sensors and actuators. These types of control algorithms are applied to the position and
 the attitude ofUAVs. This chapter is devoted to present a brief overview evaluation of popular
 control algorithms for Multi-rotor Aerial Systems (MAS).

 The main objective of this chapter is to provide a unified and accessible analysis, placing the
 classical and quaternion models of the quadcopter as well the study of its control methods into
 a proper context. In addition to provide the basis for beginner users working in aerial vehicles,
 this chapter contributes in presenting a comprehensive analysis of the implementation for
 the nonlinear and linear backstepping, nested saturation, virtual fully actuated controllers as
 well the sliding mode control and the quaternion-based nonlinear backtepping approaches.
 These techniques are selected and compared to evaluate the performance of the aircraft by
 simulations and experimental studies.

 The content of this chapter is organized as follows: In section 3.1, a brief overview for con-
 trolling the attitude and translation system of the quadrotor is presented. Four control laws
 are developed with their respective analysis of stability. Then, a quaternion-based backstep-
 ping control is addressed in section 3.2 to demonstrate the advantages of using this kind of
 controller on aerial vehicles. Finally in section 3.3, the finite-time convergence is discussed.




                                                                                               37


Chapter 3. Control approaches for aerial vehicles


3.1 Comparison of stabilization and tracking control algorithms
In this section, we present a comparison between the well-known control algorithms relying
on the Euler Angles, to solve the stabilization and tracking control problems. The aim of this
section is to introduce the main control algorithms used in the literature for controlling a
quadrotor vehicle and show their properties and capabilities.

Typically in the literature, when controlling a quadrotor vehicle, it is assumed the z−axis
can be controlled by some linear or nonlinear controller using specifically F T h . Usually, this
controller is based on a feedback linearization technique as presented in [151, 152, 153]. This
classical procedure is often used because the idea is to guarantee the vehicle keeps at hover,
and later control their displacement in the plane x or y making an under-actuated subsystem.


Control of altitude and yaw angle

Following aforementioned ideas, the controller for the z−axis is often proposed as
                                                    m
                                         u1 =               (g + r 1 )                                  (3.1)
                                                cos θ cos φ

where r 1 is always designed to achieve z → z d , for instance r 1 = −k 1 (z − z d ) − k 2 ż, where k 1 , k 2
represent positive constants and z d denotes the desired altitude. Then rewriting (2.12) using
(3.1) and assuming cos θ cos φ 6= 0, that is, θ, φ ∈ (−π/2, π/2), it yields

                                                                tan θ
                                         m ẍ = −(r 1 + mg )                                            (3.2)
                                                                cos φ
                                         m ÿ = (r 1 + mg ) tan φ                                       (3.3)
                                            z̈ = −k 2 ż − k 1 (z − z d )                               (3.4)

Note from (3.4), ∃ a time T large enough such that for t > T , the altitude error (z − z d ) → 0
such that z ≈ z d can be considered the equilibrium state of (3.4). Thus we can rewrite (3.2)
and (3.3) as follows

                                                          tan θ
                                                ẍ ≈ −g
                                                          cos φ                                         (3.5)
                                                ÿ ≈ g tan φ

For simplifying the analysis, let us consider J = I 3×3 . Thus, system (2.12) can be expressed
using (3.1) and (3.5) as
                                             tan θ
                                    ẍ ≈ −g           θ̈ ≈ τ̃θ
                                             cos φ
                                                                                          (3.6)
                                    ÿ ≈ g tan φ     φ̈ ≈ τ̃φ
                                                               ψ̈ ≈ τ̃ψ




38


                                      3.1. Comparison of stabilization and tracking control algorithms


where τ̃ψ = −a ψ1 ψ̇ − a ψ2 (ψ − ψd ) is the proposed control torque to stabilize the yaw angle
and τ̃φ , τ̃θ will be defined later. The control gains a ψ1 , a ψ2 are positive constants chosen to
ensure stable, well-damped response of the quadrotor. From (3.6) it follows that if ψd and z d
are constants, then ψ and z converge. Therefore, ψ̇ and ψ̈ → 0, which implies that ψ → ψd .


3.1.1 Nonlinear Backstepping algorithm

Backstepping is suitable for strict-feedback systems that are also known as lower triangular
and it does not require that the resulting input-output dynamics be linear. The main idea is to
use some of the state variables as “virtual controls" or “pseudo controls", and depending on
the dynamics of each state, design intermediate control laws. The Backstepping design is a
recursive procedure where a Lyapunov function is derived for the entire system (3.6).


Control of lateral position and roll angle

Define the error e 1 as e 1 = y 1 − y 1d , where y 1d is the reference. Let us propose the following
                                 ky
positive function V1 = 21 e 12 , with k y 1 > 0 denoting a constant, then taking the derivative with
respect to time and proposing y 2v = y 2d − e 1 as a virtual control input, it follows that

                                V̇1 = k y 1 e 1 (y 2 − y 2v − e 1 ) = −k y 1 e 12 + k y 1 e 1 (y 2 − y 2v )

where ẏ 1d = y 2d . Define the error e 2 = y 2 − y 2v thus, the previous yields V̇1 = −k y 1 e 12 + k y 1 e 1 e 2 .
                                               k y2 2
Propose the second positive function V2 =       2 e 2 with k y 2 > 0 constant. Taking its derivative
                                    v        v     ky
with respect to time and proposing δ1 = − ẏ 2 + k y1 e 1 + e 2 representing a second virtual control
                                                      2
input, implies that
                                      V̇2 = −k y 2 e 22 − k y 1 e 1 e 2 + k y 2 e 2 (δ1v − g tan φ1 )

Defining the error e 3 = δ1v − g tan φ1 , V̇2 yields

                                              V̇2 = −k y 2 e 22 − k y 1 e 1 e 2 + k y 2 e 2 e 3

                                                              k y3 2
Propose the third positive function V3 =                       2 e3,    with k y 3 > 0 constant. Differentiating V3 and
                            k y2
defining δ2v   = δ̇1v   +   k y 3 e 2 + e 3 , it follows that


                               V̇3 = k y 3 e 32 − k y 2 e 3 e 2 + k y 3 e 3 (δ2v − g (1 + tan2 φ1 )φ2 )

Defining the error e 4 = δ2v − g (1 + tan2 φ1 )φ2 , then the above yields

                                              V̇3 = −k y 3 e 32 − k y 2 e 3 e 2 + k y 3 e 3 e 4




                                                                                                                    39


Chapter 3. Control approaches for aerial vehicles

                      ky
Proposing V4 = 24 e 42 as positive function, with k y 4 > 0 defining a constant, and computing its
derivative, it appears that

                                 V̇4 = k y 4 e 4 (δ̇2v − g (1 + tan2 φ1 )(τ̃φ + 2φ22 tan φ1 ))


Proposing a control law given by

                                                1               k y3
                                τ̃φ =                   (δ˙2v +      e 3 + e 4 ) − 2φ22 tan φ1                                 (3.7)
                                        g (1 + tan φ1 )
                                                  2             k y4

implies that V̇4 = −k y 4 e 42 − k y 3 e 4 e 3 .


Finally, define the following candidate Lyapunov function with the form VT = V1 +V2 +V3 +V4 .
Therefore
                             V̇T = −k y 1 e 12 − k y 2 e 22 − k y 3 e 32 − k y 4 e 42 ≤ 0.

Expressing (3.7) with respect to the state variables, it follows that

                      1       ³...
      τ̃φ =                    y d − 4 ÿ 2d − k̄ y 1 ẏ 2d + k̄ y 2 (y 2 − y 2d ) + k̄ y 3 (y 1 − y 1d ) − k̄ y 4 g tan φ1
              g (1 + tan2 φ1 ) 2                                                                                               (3.8)
                              −4g (1 + tan2 φ1 )φ2 − 2φ22 φ1
                                                                           ¢


where

                                 k̄ y 1 = k̄ y 4 = k φ + 6,              k̄ y 2 = 2k φ + 4
                                                  k y3 k y1                      k y1       k y2       k y3                    (3.9)
                                 k̄ y 3 = k φ +               + 1,        kφ =          +          +
                                                  k y4 k y2                      k y2       k y3       k y4


Control of forward position and pitch angle

From (3.6) and (3.8), we obtain φ → 0, then from (3.5) and (3.6) we get

                                                              ẍ ≈ −g tan θ
                                                                                                                              (3.10)
                                                              θ̈ = τ̃θ

Using a procedure similar to the one proposed for the roll control, we obtain

                      1      ³...
      τ̃θ =                   x d − 4ẍ 2d − k̄ x1 ẋ 2d + k̄ x2 (x 2 − x 2d ) + k̄ x3 (x 1 − x 1d ) − k̄ x4 g tan θ1
              g (1 + tan θ1 ) 2
                        2
                                                                                                                              (3.11)
                             −4g (1 + tan2 θ1 )θ2 − 2θ22 θ1
                                                                      ¢




40


                            3.1. Comparison of stabilization and tracking control algorithms


where

                          k̄ x1 = k̄ x4 = k θ + 6,           k̄ x2 = 2k θ + 4
                                          k x3 k x1                  k x1       k x2       k x3    (3.12)
                          k̄ x3 = k θ +               + 1,    kθ =          +          +
                                          k x4 k x2                  k x2       k x3       k x4


3.1.2 Control algorithm based on nested saturation

The goal for controllers based on saturation functions is to impose a bound in the control input.
The control algorithm is conceived from a linear systems (chain of integrators) nevertheless,
it was also demonstrated that it can be applied for nonlinear systems. Their procedure, in
contrast to the backstepping approach, starts in the last state (where the control input is
located) until the first one. The stability analysis is assured using a series of positive functions.

The first methodology was proposed in [154] designing the controller with nested saturation
functions for linear systems and applied to nonlinear systems. Nevertheless after analysis, it
can be observed that the controller structure using saturation functions imposes bounds on
each state of the system, such that, some inequalities can be applied, for example tan θ ≈ θ
and cos φ ≈ 1, see [155, 147]. From this assumption, the longitudinal and lateral parts of (3.6)
can be rewritten as follows
                                     ẋ 1 = x 2  ẏ 1 = y 2
                                            ẋ 2 ≈ −g θ1      ẏ 2 ≈ g φ1
                                                                                                   (3.13)
                                            θ̇1 = θ2         φ̇1 = φ2
                                            θ̇2 ≈ τ̃θ        φ̇2 ≈ τ̃φ


Roll control (φ, y)

A controller stabilizing the lateral system of (3.13) can be denoted by

                                             τ̃φ = −σa (φ2 + σb (·))                               (3.14)

where σi defines a generalized saturation function such that |σi (·)| ≤ i for positive constant
i : a, b, c, d . The argument in σb (·) will be defined later to assure convergence of the states. Let
us define a positive function V1 = 12 φ22 , then its derivative is defined by

                               V˙1 = φ2 φ˙2 = φ2 τ̃φ = −φ2 σa (φ2 + σb (·))                        (3.15)

if ¯φ2 ¯ ≥ b ⇒ V˙1 ≤ 0. Then, ∃ t 1 such that for t ≥ t 1 ¯φ2 (t )¯ ≤ b, implying that ¯φ2 + σb (·)¯ ≤ 2b.
   ¯ ¯                                                    ¯       ¯                    ¯           ¯

Choosing a ≥ 2b, then (3.14) can be rewritten ∀ t > t 1 as

                                               τ̃φ = −φ2 − σb (·).                                 (3.16)




                                                                                                      41


Chapter 3. Control approaches for aerial vehicles


Define ν1 = φ1 + φ2 , then, ν̇1 = −σb (·). Propose a positive function V2 = 12 ν21 and imposing
σb (·) = σb (ν1 + σc (·)) then, its derivative is determined by

                                      V˙2 = ν1 ν̇1 = −ν1 σb (ν1 + σc (·))                              (3.17)

if |ν1 | ≥ c ⇒ V˙2 ≤ 0. Then, ∃ t 2 ≥ t 1 such that for t ≥ t 2 |ν1 (t )| ≤ c and |ν1 + σc (·)| ≤ 2c. Choosing
b ≥ 2c, then (3.16) can be rewritten ∀ t > t 2 as

                                           τ̃φ = −φ2 − ν1 − σc (·).                                    (3.18)


Define ν2 = ν1 + φ1 − y 2 /g = φ2 + 2φ1 − y 2 /g , thus ν̇2 = −σc (·). Propose the positive function
V3 = 12 ν22 with σc (·) = σc (ν2 + σd (·)), then its derivative is described by

                                      V˙3 = ν2 ν̇2 = −ν2 σc (ν2 + σd (·))                              (3.19)

if |ν2 | ≥ d ⇒ V˙3 ≤ 0. Then, ∃ t 3 ≥ t 2 such that ∀t ≥ t 3 |ν2 (t )| ≤ d and |ν2 + σd (·)| ≤ 2d . Choosing
c ≥ 2d , then (3.18) can be rewritten ∀ t > t 3 as

                                        τ̃φ = −φ2 − ν1 − ν2 − σd (·).                                  (3.20)

                            y     y
Define ν3 = φ2 + 3φ1 + 3 g2 + g1 then ν̇3 = −σd (·). Propose V4 = 12 ν23 and σd (·) = σd (ν3 ), taking
the derivative of V4 , it follows that

                                       V˙4 = ν3 ν̇3 = −ν3 σd (ν3 ) ≤ 0                                 (3.21)

The previous implies that ν3 → 0, then from (3.19) it follows that ν2 → 0. From (3.17) implies
that ν1 → 0, similarly from (3.15), φ2 → 0. From definition of ν1 it follows that φ1 → 0. From
definition of ν2 this implies that y 2 → 0. And finally, from definition of ν3 it can be deduced
that y 1 → 0.

Rewriting τ̃φ , it yields

                                                                     y2 y1
                 µ       µ            µ                 µ                  ¶¶¶¶
        τ̃φ = −σa φ2 + σb φ1 + φ2 + σc φ2 + 2φ1 + y 2 σd φ2 + 3φ1 + 3 +                                (3.22)
                                                                     g  g


Pitch control (θ, x)

As before, we assume that the control strategy will insure a very small bound on | θ | such that
tan(θ) ≈ θ. Therefore, using a procedure similar to the one proposed for the roll control, it is
possible to express the pitch control as follows

                                                                        x2 x1
                 µ        µ            µ                   µ                  ¶¶¶¶
        τ̃θ = −σe θ2 + σ f θ1 + θ2 + σg θ2 + 2θ1 + x 2 + σh θ2 + 3θ1 − 3 −                             (3.23)
                                                                        g  g




42


                               3.1. Comparison of stabilization and tracking control algorithms


3.1.3 Linear backstepping

This controller is conceived using the same procedure proposed in the nonlinear backstepping
methodology, but instead of using the nonlinear system, a linear system is required. This
methodology is useful for beginners with the goal to better understand its procedure. The
obtained control law is quite different to the one obtained with the nonlinear system. For
our study, it is assumed that the vehicle is moving with small angles, therefore the nonlinear
system (3.10) can be represented as (3.6).


Forward position control

Rewriting first equation in (3.6)
                                                     ẋ 1 = x 2                                              (3.24)

propose V1 = 21 x 12 , then V̇1 = x 1 x 2 . if x 2 → −k 1 x 1 with k 1 is a positive constant, then V̇1 = −k 1 x 12 .
Define the following error with the form

                                                  ζ2 = x 2 − x 2v                                            (3.25)

with x 2v = −k 1 x 1 = α1 defining the first virtual input. Rewriting (3.24) and the second equation
of (3.6) with (3.25) and using x 1 = ζ1

                                                 ζ̇1 = ζ2 + α1
                                                                                                             (3.26)
                                                 ζ̇2 = −g θ1 − α˙1

                                                        ζ2 2
Define a positive definite function V2 = V1 +           2 , then


                                    V̇2 = V̇1 + ζ2 ζ̇2 = V̇1 + ζ2 (−g θ1 − α˙1 )                             (3.27)

if (−g θ1 − α˙1 ) → −k 2 ζ2 with k 2 is a positive constant, then, V̇2 = V̇1 − k 2 ζ22 . Define the error

                                                 ζ3 = −g θ1 − α2                                             (3.28)

with α2 = k 2 ζ2 − α̇1 denoting the second virtual input. Rewriting (3.26) with the previous
equation, it follows that

                                                 ζ̇1 = ζ2 + α1
                                                 ζ̇2 = −g θ1 − α̇1                                           (3.29)
                                                 ζ̇3 = −g θ2 − α̇2

                                                          ζ23
Define the positive definite function V3 = V2 +           2 , then


                                    V̇3 = V̇2 + ζ3 ζ̇3 = V̇2 + ζ3 (−g θ2 − α̇2 )                             (3.30)



                                                                                                                 43


Chapter 3. Control approaches for aerial vehicles


if (−g θ2 − α̇2 ) → −k 3 ζ3 , with k 3 is a positive constant, then V̇3 = V̇2 − k 3 ζ23 . Define the error

                                                   ζ4 = −g θ2 − α3                                    (3.31)

where α3 = (g θ2 )v = k 3 ζ3 − α̇2 is the third virtual input. Rewriting (3.29) with ζ̇4 , it follows that

                                                   ζ̇1 = ζ2 + α1
                                                   ζ̇2 = −g θ1 − α̇1
                                                                                                      (3.32)
                                                   ζ̇3 = −g θ2 − α̇2
                                                   ζ̇4 = −g u 2 − α̇3

                                                                          ζ24
Propose the candidate Lyapunov function V4 = V3 +                         2 , then


                                  V̇4 = V̇3 + ζ4 ζ̇4 = V̇3 + ζ4 (−g u 2 − α̇3 )                       (3.33)

Propose the control input
                                                          1
                                                  τ̃θ =     (k 4 ζ4 − α̇3 )                           (3.34)
                                                          g
with k 4 > 0 is a constant. Then

                           V̇4 = V̇3 − k 4 ζ24 = −k 1 ζ21 − k 2 ζ22 − k 3 ζ23 − k 4 ζ24 < 0           (3.35)

The above implies system (3.32) goes to zero implying that (3.6) is globally asymptotically
stable. Rewriting (3.34) with respect to the state variables, it follows that

                                                k̄ 1      k̄ 2
                                    τ̃θ = −          x 1 − x 2 + k̄ 3 θ1 + k̄ 4 θ2                    (3.36)
                                                 g         g

where

                               k̄ 1 = k 1 k 2 k 3 k 4
                               k̄ 2 = k 1 k 2 (k 3 + k 4 ) + k 3 k 4 (k 1 + k 2 )
                                                                                                      (3.37)
                               k̄ 3 = k 1 (k 2 + k 3 + k 4 ) + k 2 (k 3 + k 4 ) + k 3 k 4
                               k̄ 4 = k 1 + k 2 + k 3 + k 4


Lateral position control

For controlling the lateral position of the system (3.6), and using a similar procedure as the
one developed for the pitch control, the backstepping roll control input can be obtained as

                                          k̄ φ1           k̄ φ2
                                  τ̃φ =           y1 +            y 2 + k̄ φ3 φ1 + k̄ φ4 φ2           (3.38)
                                            g              g




44


                             3.1. Comparison of stabilization and tracking control algorithms


3.1.4 Fully actuated approach

In this approach, the goal is to transform the underactuated system into a virtual fully actuated
system. This can be done by imposing a desired attitude R d that will be related with the
virtual control input U ~ . This allows us to use control inputs τφ , τθ to only control the attitude
system, i.e., R → R d . Motivated by the works developed by [156, 157], simple smooth bounded
controllers that can easily be implemented in VTOL aircraft with parallel motors for tracking
set-points and time-varying trajectories are proposed.

The methodology is explained as follows; propose a vector control input, U      ~ , containing the
virtual control laws to stabilize the translational states in the VTOL vehicle. These virtual
control inputs will be related to the desired orientation matrix, R d , of the vehicle and with its
main control input, F~t h = [0 0 u 1 ]T , as follows

                                                  ~ = u1 Rd ~
                                                  U         ez                                       (3.39)

In our case of study, the virtual control laws will be designed for the vertical, horizontal and
longitudinal axis of the quadrotor, with the form U ~ = [U x ,U y ,U z ]T , ~
                                                                            e z = [0 0 1]T and similarly
R d ∈ R3×3 , is defined as
                                                                                              
                      S θ d C ψd       C ψd S θd S φd −C φd S ψd    S θd C φd C ψd + S φd S ψd
               R d = C θd S ψd        C φd C ψd + S θd S φd S ψd   S θd C φd S ψd − S φd C ψd  .
                                                                                              

                       −S θd                    C θd S φd                    C θd C φd

with θd , ψd φd representing the desired attitude. Next step is to rewrite the original transla-
tional dynamic system, in our case it is represented by equations (2.12). Thus the new system
is described as
                                              ¨ ~
                                             m~
                                              ξ=F t h R − mg~
                                                            ez                                       (3.40)

where ~ ξ = [x y z]T , R ∈ R3×3 has the same form of R d except that replacing the desired angles
with φ θ ψ. Notice from (3.39) that, u 1 is the main control input. Therefore, using (3.39) into
first equation of (3.40)
                                 ¨
                              m~ ξ = u 1 R~                   e z − u1 Rd ~
                                                  e z + u1 Rd ~
                                          e z − mg~                       ez
                                      = u 1 (R − R d )~       e z + u1 Rd ~
                                                      e z − mg~           ez

Define ~
       ω = u 1 (R − R d )~
                         e z , thus
                                              ¨
                                             m~
                                              ξ=~
                                                ω − mg~   ~.
                                                      ez +U                                          (3.41)
                                                                     .
The desired orientation can be found using (3.39) and considering ψd = 0, then

                                                       Ux
                                                           µ    ¶
                                        θd   = arctan                                                (3.42)
                                                       U
                                                       z               
                                                          Uy
                                       φd    = arctan  q                                            (3.43)
                                                                 
                                                                  
                                                           2    2
                                                         U x +U z

                                                                                                        45


Chapter 3. Control approaches for aerial vehicles


                          ~ ° = ku 1 R d ~
                         ° °
Notice from (3.39) that °U               e z k gives an orthogonal vector as resultant of the right
side of the equation, therefore                q
                                              u1 =      U x2 +U y2 +U z2 .                      (3.44)

Define the control objective                      °               °
                                                   ξ(t ) − ~
                                              lim °~       ξd (t )° = 0.                        (3.45)
                                                  °               °
                                             t −→∞

where ξ~d = [x d y d z d ]T are the longitudinal and lateral references. Denoting the tracking error
   ~ = [~
as p       ~2 ]T such that
        p1 p
                                                            ˙ ˙
                                             ξ − ξ~d
                                       p~1 = ~              ξ −~
                                                      p~2 = ~   ξd                            (3.46)

Differentiating (3.46) and by means of (3.41)

                                             ~˙1 = p
                                             p     ~2
                                                   ~
                                                   ω         ~ ¨
                                                             U                                  (3.47)
                                             ~˙2 =
                                             p          e z + −~
                                                     − g~      ξd .
                                                   m         m
      ¨
where ~
      ξd means the desired acceleration.


Control based on hyperbolic functions

               ~ in (3.47) as
Let us propose U

                                                                                ¨
                            ~ = m(−σ1 (K 1 p
                            U                       ~2 ) − σ2 (K 2 p
                                           ~1 + K 2 p                      e z +~
                                                                   ~2 ) + g~    ξd )            (3.48)

where K 1 , K 2 ∈ R3×3 are diagonal positive matrices constant, σi means a saturation function
with the form σ(ς) = σ̄ tanh(ς) and σ̄ means a bounded constant. Hence, the bounded control
~ in (3.48) makes system (3.47) globally asymptotically stable.
U

Proof: First, to prove the asymptotic convergence of solution p       ~(t ) to the origin, observe from
(3.39) and (3.41) that kω̄k ≤ 2F̄ t h . This implies that the closed-loop system using (3.47) and
(3.48) satisfies the Lipschitz condition1 , and hence has a unique solution over [0, T ] with T ≥ 0.
Moreover, if T is bounded, then p    ~(t ) is bounded ∀ t ∈ [0, T ]. This proof is inspired in [159].

                     ω(t )k = 0 then lim °p             ~(0), that is, for every ²1 , for every p
                                           ~(t )° = 0 ∀ p                                       ~(0),
                                         °      °
Furthermore, if lim k~
                    t −→∞                      t −→∞
there exists ²2 , T²1 , T²2 > 0 and T²1 ≥ T²2 such that

                               ω(t )k < ²2 , ∀t ≥ T²2 ⇒ °p~(t )° < ²1 , ∀t ≥ T²1 .
                                                        °      °
                              k~                                                                (3.49)

Inspired by the work developed by [157], let us propose the following candidate Lyapunov
function
                                2 Z (k 1i p 1i +k 2i p 2i )                1 T
                                                                                 ~2
                                                                            ~ K1 p
                                                            σ1i (ςi )d ςi + p
                              X
                         p) =
                     V1 (~                                                          (3.50)
                              i =1 0                                       2 2


     1 See [158], Theorem 3.1 and page 446



46


                               3.1. Comparison of stabilization and tracking control algorithms


                                                                                                ~2 , σ1 and ς
                                                                                           ~1 , p
where k 1i , p 1i , k 2i , p 2i , σ1i and ςi for i = 1, 2 are the elements of, K 1 , K 2 , p
respectively. The time derivative of V1 (~      p ) along (3.47) and (3.48) is

                   T
      V̇1   =   ~˙1 K 1 σ1 (K 1 p
                p               ~1 + K 2 p      ~˙2T K 2 σ1 (K 1 p
                                         ~2 ) + p                ~1 + K 2 p              ~˙2
                                                                                 ~2T K 1 p
                                                                          ~2 ) + p
                                ~2 )K 2 σ1 (K 1 p
                       ~1 + K 2 p
            = −σ1 (K 1 p                                 ~2 ) − σ2 (K 2 p
                                                ~1 + K 2 p                              ~1 + K 2 p
                                                                        ~2 )K 2 σ1 (K 1 p        ~2 )
               ~
               ωT                                                   ~
                                                                    ωT
                +             ~1 + K 2 p
                  K 2 σ1 (K 1 p                        ~2 )K 1 p
                                        ~2 ) − σ2 (K 2 p       ~2 +       ~2 .
                                                                       K1 p
               m                                                     m
                                                  °2
                                              ~2 )° + λmax (K 2 ) °σ1 (K 1 p
                                     ~1 + K 2 p
            ≤ −λmi n (K 2 ) °σ1 (K 1 p                                              ~2 )° °σ2 (K 2 p
                                                                           ~1 + K 2 p              ~2 )°
                            °                                       °                   °°             °

                                                   ~
                                                   ωT
                             p 2T σ2 (K 2 p
                −λmi n (K 1 )~            ~2 ) +                            ~1 + K 2 p
                                                           ~2 + K 2 σ1 (K 1 p
                                                      (K 1 p                         ~2 )).               (3.51)
                                                   m

Using Young’s inequality 1 , the second term of (3.51), satisfies

                                                          ° λmax (K 2 ) °                        °2
                                      ~2 )° °σ2 (K 2 p
                             ~1 + K 2 p
        λmax (K 2 ) °σ1 (K 1 p                       ~ 2 )° ≤                    ~1 + K 2 p
                                                                        °σ1 (K 1 p          ~ 2 )°
                    °                     °°
                                                                   2                                        (3.52)
                                                                λmax (K 2 ) °             °2
                                                              +             °        ~2 )
                                                                             σ2 (K 2 p    °
                                                                     2

Furthermore, there exists ν > 0 such that °σ2 (K 2 p         ~2 )° ≤ νλmax (K 2 ) °p~2 °, for all p ~2 , then the
                                                   °             °                ° °

third term of (3.52) satisfies
                                               °2
                                                               p 2T σ2 (K 2 p
                                           ~2 )° ≤ νλmax (K 2 )~
                                  °σ2 (K 2 p                                ~2 )
                                  °
                                                                                                          (3.53)

Substituting (3.53) into (3.52), yields
                                                                  °2
                                                              ~2 )°
                                                     ~1 + K 2 p
                                          ° °σ1 (K 1 p
                                             °
                                                                       νλmax T                            (3.54)
                         ~2 ) σ2 (K 2 p
                ~1 + k 2 p
       °σ1 (K 1 p                     ~2 ) ≤                                ~2 σ2 (K 2 p
                                                                                       ~2 )
       °                     °°
                             ° °          °                          +      p
                                                       2                 2

From (3.54), the derivative V̇1 in (3.51) satisfies

                                                   V̇1 ≤ −W1 (~  ω)
                                                              p ,~                                        (3.55)

where

                                            °2                          ωk
                                                                       k~
                               ~1 + K 2 p
             ω) = c 1 °σ1 (K 1 p                    ~2T σ2 (K 2 p
                                        ~2 )° + c 2 p           ~2 ) −                   ~2 ° + c 3 )
                      °                                                                 ° °
      W1 (~
          p ,~                                                             (λmax (K 1 ) °p                (3.56)
                                                                        m
                                       2λ     (K )−νλ2     (K )
with c 1 = 2λmi n (K 2 )−λ
                        2
                          max (K 2 )
                                     , c 2 = mi n 1 2 max 2 , c 3 = λmax (K 2 )σ̄1 with σ̄1 ≥ kσ1 (·)k. In order
to ensure c 1 , c 2 , c 3 > 0, the matrices K 1 , K 2 are chosen as follows:

                         2λmi n (K 2 ) > λmax (K 2 );         2λmi n (K 1 ) > νλmax (K 2 )2               (3.57)

(3.55) is used to get (3.49). Let the ball B²1 = {~          ~° ≤ ²1 }, and show that p
                                                   p ∈ R3 | °p                          ~(t ) approaches
                                                            ° °

B²1 after the time T²1 . Let α1 = minkp~k=²1 V1 (~  p ), then α1 > 0. Take β1 ∈ (0, α1 ) and define the
set Ωβ1 = {~             p ) ≤ β1 }, then Ωβ1 is in the interior of B²1 . As V1 (~
             p ∈ B | V1 (~                                                       p ) is continuous and
V1 (0) = 0, there exists γ1 such that 0 < γ1 < ²1 and β2 = maxkp~k=γ1 V1 (~   p ) < β1 .


                                                                                                               47


Chapter 3. Control approaches for aerial vehicles


Let the ball βγ1 = {~            ~° ≤ γ1 }, and take α2 = minkp~k=γ1 V1 (~
                    p ∈ Ω β1 | ° p                                         p ), then we have 0 < α2 <
                               ° °

β2 < β1 < α1 . Consequently, let the ball βγ2 = {~ p ∈ Bγ1 | p  ~ ≤ γ2 } where γ2 satisfies 0 < γ2 < γ1
                                                              ° °
                                                              °  °
and 0 < minkp~k=γ2 V1 (~p ) ≤ maxkp~k=γ2 V1 (~p ) < α2 , then from the above construction we have

                                         Bγ2 ⊂ Bγ1 ⊂ Ωβ1 ⊂ B²1                                        (3.58)

                              p ) satisfies
and the Lyapunov function V1 (~

                                         p ) < min V1 (~
                                 max V1 (~             p)
                                kp~k=γ2       kp~k=γ1
                                                                                                      (3.59)
                                                           p ) < β1 < α1 .
                                                 < max V1 (~
                                                  kp~k=γ1

                                                ~(t ) approaches Bγ2 after the finite time T²1 . Then,
In view of (3.58) it is sufficient to show that p
the proof is completed.                                                                             
As the quadrotor is composed of mechanical and electrical parts, constraints are needed in
order to respect the limits of its actuators and mechanical movements. Using (3.44) and (3.48)
it yields
                   u 12 = U x2 +U y2 +U z2
                                                                                                      (3.60)
                   u 12 ≤ (σ11 + σ21 )2 m 2 + (σ12 + σ22 )2 m 2 + (σ13 + σ23 + g )2 m 2 .

In order to ensure u 1 ≤ ū 1 , where ū 1 is a thrust bounded constant defined by the properties of
the actuators, and from (3.60), then the following condition is necessary

                                             g − σ̄13 − σ̄23 > 0,                                     (3.61)
                                                                                         ū 12
                        (σ̄11 + σ̄21 )2 + (σ̄12 + σ̄22 )2 + (σ̄13 + σ̄23 + g )2 ≤                 .   (3.62)
                                                                                        m2
Equation (3.43) can be rewritten as
                                                                       ¶−1
                                            −σ̄11 − σ̄21
                                             µ
                                  θd = tan                                   ≤ θ̄d .                  (3.63)
                                           −σ̄13 − σ̄23 + g

Rewriting (3.61) as
                                                                   g
                                             −σ̄13 − σ̄23 < −
                                                                   2                                  (3.64)
                                                                 g
                                              |σ̄13 + σ̄23 | <     ,
                                                                 2

and equation (3.62) by
                                                                                       |ū 12 |
                        |σ̄11 + σ̄21 |2 + |σ̄12 + σ̄22 |2 + |σ̄13 + σ̄23 + g |2 ≤                 ,   (3.65)
                                                                                       |m 2 |

such that equation (3.63) is rewritten as
                                          |σ̄11 + σ̄21 | −1
                                     µ                    ¶
                                 tan                        ≤ θ̄d .                                   (3.66)
                                       |σ̄13 + σ̄23 + g |




48


                             3.1. Comparison of stabilization and tracking control algorithms


Developing the third term of (3.65)

                                                                                                            ū 12
             |σ̄11 + σ̄21 |2 + |σ̄12 + σ̄22 |2 + |σ̄13 + σ̄23 |2 + 2|σ̄13 + σ̄23 ||g | + |g |2 ≤                    .   (3.67)
                                                                                                            m2

Assumption 1. As the virtual control U z has to compensate the weight of the vehicle (mg ) to
track a desired altitude (z −→ z d .), then, it is possible to say that U z > U x and U z > U y .

Based on the Assumption 1 and considering that the vehicle is moving in the x−axis, thus,
using (3.64) into (3.67) we obtain

                                            g          g                 |ū 2 |
                         |σ̄11 + σ̄21 |2 + | |2 + 2| ||g | + |g |2 ≤ 12
                                            2          2                |m |
                                                          g 2            ū 2
                                       |σ̄11 + σ̄21 |2 +      + 2g 2 ≤ 12
                                                           4            m
                                                                                                                        (3.68)
                                                               9         ū 2
                                             |σ̄11 + σ̄21 |2 + g 2 ≤ 12
                                                               4        m
                                                                        s
                                                                             ū 12 9
                                                       |σ̄11 + σ̄21 | ≤           − g 2.
                                                                            m2 4

Rewriting equation (3.63) with (3.68)
                                            r
                                                ū 12
                                                m2
                                                          − 94 g 2
                                                                          ≤ tan(θ̄d )                                   (3.69)
                                          |σ̄13 + σ̄23 | + g

From the last equation                                           r                   
                                                                       ū 12
                                                         − 94 g 2    m2
                                    |σ̄13 + σ̄23 | ≥              −g.                                                 (3.70)
                                                                  
                                                      tan(θ̄d ) 


Now, for φd , it is possible to rewrite equation (3.43) using the inequalities (3.68) and (3.70)

                                          |σ̄12 + σ̄22 |
                           vÃ
                           u r              !2 Ãr                       !2 ≤ tan φ̄d
                                  2                      2
                               ū 1                   ū 1
                           u
                           t
                               m2
                                    − 49 g 2 +        m2
                                                           − 49 g 2 − g

                                                                                                                        (3.71)
                                                         |σ̄12 + σ̄22 |
                                      s                                                         ≤ tan φ̄d
                                                         ū 2
                                                     µ                  ¶ µ 2               ¶
                                                                           ū
                                          tan2 θ̄d          1
                                                                − 94 g 2 + 12 − 94 g 2 −g 2
                                                         m2                    m

                                                                  tan2 θ̄d

Then,                                     v                                      
                                            u       ³ 2         ´ ³ 2
                                                     ū 1           ū 1
                                                                                ´
                                                           9             9
                                          u tan θ̄d m 2 − 4 g + m 2 − 4 g − g 
                                            u   2             2            2  2
                 |σ̄12 + σ̄22 | ≤ tan φ̄d t                                                                            (3.72)
                                                                                 
                                                            tan θ̄d
                                                                                  
                                                                2                


                                                                                                                           49


Chapter 3. Control approaches for aerial vehicles


Following the inequalities given by (3.68), (3.70) and (3.72) it is possible to achieve the con-
straints u 1 ≤ ū 1 , θ ≤ θ̄d and φ ≤ φ̄d .

To guarantee the orientation angle θ, φ tracks its desired value θd , φd in the sense that
          ~ ) − η~d (t )° = 0, where~η = [θ φ]T and η~d = [θd φd ]T , such that
limt →∞ °η(t
        °               °


                                                        ω(t )k = 0.
                                                   lim k~                                               (3.73)
                                                 t −→∞

Then, it is possible to rewrite attitude subsystem describing the pitch movement in equation
(2.11) as in the following form

                                                         ~η˙ 1 =~η 2
                                                                                                        (3.74)
                                                        J~η˙ =~
                                                             2   τ

where ~
      τ = [τ̃θ τ̃φ ]T , and J ∈ R2x2 is a diagonal constant inertial matrix. Let us propose a control
input of the form
                                           τ̄ = −K 1 η 1 − K 2 η 2                             (3.75)

where~η 1 = (~η −~η d ) and~η 2 = (~η˙ −~η˙ d ), K 1 and K 2 are positive diagonal matrices that must be
well chosen to ensure (3.73) and ~η˙ d = [θ̇d φ̇d ]T rate is defined as

                                        U̇ x U z −U x U̇ z
                                θ̇d =
                                           U z2 +U x2
                                                                                                        (3.76)
                                        U̇ y U x2 + U̇ y U z2 −U y U̇ x U x −U y U̇ z U z
                                φ˙d =          q
                                                  U x2 +U z2 U y2 +U x2 +U z2
                                                               ¡                 ¢


with
               1
       ~˙ = − ((1 − σ1 tanh(K 1 p
       U                           ~1 + K 2 p ~2 )2 )K 1 p
                                                         ~2 + K 2 ((1 − σ1 tanh(K 1 p        ~ 2 )2 )
                                                                                    ~1 + K 2 p
              m
                                       ~˙2 ).
                               ~2 )2 ))p
            + (1 − σ2 tanh(K 2 p

Take K 22 > 4K 1 . Then, the roots of the characteristic equation of the subsystem (3.74), (3.75)
denoted by α, β are real with
                                   s                                       s               
                             K2          K 22                          K2         K 22
                    β = −      −               − K 1  < α = −          +              − K 1  < 0.   (3.77)
                             2            4                            2           4

Let γ > 0 be an arbitrary constant. Now, if γK 2 replaces K 2 and γ2 K 1 replaces K 1 , then β in
(3.77) is placed by γβ and α by γα. Hence, it can easily be shown that for the given ~            τ > 0 and
any fixed r η > 0 one can select a pair K 1 , K 2 such that °η 0 ° ≤ r η implies |η i (t )| ≤ ϑi r η exp(αt )
                                                            ° °

where 0 ≤ ϑi , i = 1, 2 depend on η i 0 , and in particular

                                                                                     τ.
                              |K 1 η 1 (t ) + K 2 η 2 (t )| ≤ (K 1 ϑ1 + K 2 ϑ2 )r η <~                  (3.78)


50


                          3.1. Comparison of stabilization and tracking control algorithms


3.1.5 Numerical and experimental results

This section presents numerical and experimental results to validate the control strategies
developed in (3.11), (3.22), (3.36), (3.48). The robot used to validate this overview of control
laws is quadcopter system emulating a PVTOL vehicle for simplifying further analysis.

The scenario consists in moving the longitudinal axis of the vehicle as following: the vehicle
starts at x(0) = −2m and z(0) = 1m, then, three set-points defined by x r 1 = 2, x r 2 = 4 and
x r 3 = 5 in meters are imposed as desired values. For better illustrating the graphs obtained in
simulation and experimental results, we denote as LB , N LB , N S, the Linear/NonLinear Back-
stepping and the Nested Saturation controllers, respectively, called also classical approaches.
The H SC means the Hyperbolic Saturation Controller based on the fully actuated approach,
named also virtual method. Parameters for numerical and practical validation are shown in
Table 3.1.

Table 3.1 – Parameters values used in the control laws in (3.11), (3.22), (3.36) and (3.48) used
in simulation and experimental validation.

                        Controller   Control parameters   Sim. Values   Exp. Values
                                            k1                1            1.31
                                            k2                1.2           1
                           LB
                                            k3                0.8           0.8
                                            k4                0.1           0.1
                                            k̄ 1             0.04          0.04
                                            k̄ 2            0.035         0.0025
                          NLB
                                            k̄ 3              0.4           0.4
                                            k̄ 4              0.1           0.1
                                            σa               0.15          0.15
                                            σb               0.22          0.22
                           NS
                                            σc                0.1           0.1
                                            σd                0.3           0.3
                                            σ11               0.5           0.5
                                            σ12               0.1           0.2
                                            σ21               0.5           0.5
                                            σ22              0.35           0.4
                          HSC
                                            k 11              5             1
                                            k 22              0.9           1.3
                                            k 11              3             0.3
                                            k 22             0.55           0.6



Numerical results

The performance of the PVTOL vehicle when using controllers (3.11), (3.22), (3.36) and (3.48)
tracking the set-points previously defined is shown in Figures 3.1 and 3.3. Note from Figure 3.1
that, the convergence using controllers without bounded functions are faster than the others
that use saturation functions.

                                                                                              51


Chapter 3. Control approaches for aerial vehicles


This performance is ‘normal’ because the saturation functions are chosen so small to guarantee
a convergence from any initial condition. To increase the speed of convergence of these
controllers, the bound of the saturation functions must be increased.

                     8



                     6



                     4



                     2



                     0



                    -2



                    -4
                             0   5   10   15   20   25   30   35    40    45



Figure 3.1 – Longitudinal position performance when comparing the four control algorithms.

Besides, as depicted in Figure 3.2, the θ angle responses for controllers NS and HSC are
bounded, even if initial conditions are far from the desired position. In addition, for the
controllers LB and NLB the angular position is bigger than for the NS and HSC controllers
and its magnitude is related to the error position. Notice that only for the HSC algorithm the
angular position tracks the imposed reference.


                   50



                     0



                   -50
                         0       5   10   15   20   25   30    35    40    45


                   50



                     0



                   -50
                         0       5   10   15   20   25   30    35    40    45


                   20



                     0



                   -20
                         0       5   10   15   20   25   30    35    40    45


                   20



                     0



                   -20
                         0       5   10   15   20   25   30    35    40    45




Figure 3.2 – θ angle response when applying four controllers into the PVTOL dynamics. θd
denotes the desired angle computed in (3.43).


52


                                   3.1. Comparison of stabilization and tracking control algorithms


Figure 3.3 is the most important graph to analyze the performance of the four controllers. In
this figure, z performance is depicted showing the advantage of using a virtual controller from
the classical one. Observe here that the controllers using classical procedure their altitude
performance is degraded when tracking the references. In practical validation, this is observed
as a drop in the altitude performance (z decreases). This drop is related to how far the desired
value is.
                   1.1

                  1.08

                  1.06

                  1.04

                  1.02

                        1

                  0.98

                  0.96

                  0.94

                  0.92

                   0.9
                             0          5        10   15            20           25   30   35         40   45



    Figure 3.3 – Vertical position behavior when comparing the four control algorithms.

Similarly, the performance of the vehicle comparing the four control algorithms in the x − z
plane is displayed in Figure 3.4. In one hand, it can be verified that when using control algo-
rithms based on classical method, the behaviour of the vehicle in the z−axis is compromized.
On the other hand, controllers based on the virtual approach compensate this error by means
of the correction term F 2 in the total thrust.

                  1.1


                 1.08


                 1.06                                                        x
                                                           x                     r2
                                                               r1

                 1.04
                                                                                            xr3
                 1.02            x(0)

                    1


                 0.98


                 0.96


                 0.94


                 0.92


                  0.9
                        -4                  -2        0                  2             4          6             8




Figure 3.4 – Vehicle’s performance evolution in the x − z plane when applying the four control
algorithms into the PVTOL dynamics. From figure x r i for i : 1, 2, 3 describes the desired
way-point.


                                                                                                                    53


Chapter 3. Control approaches for aerial vehicles


In Figures 3.5 and 3.6 the control input responses for the four controllers are depicted. Notice
from Figure 3.5 that u 1 response is different for the HSC controller with respect to the others
that decreases when the desired point is modified. Notice that for the HSC controller u 1
increases to compensate the lateral displacement. Nevertheless, in Figure 3.6 the u 2 perfor-
mance is quite different. Notice here that u 2 for the HSC controller is smaller with respect to
the others one.

                   -0.2

                   -0.4

                   -0.6

                   -0.8
                           0   5   10   15     20    25     30     35    40     45


                  -0.35

                   -0.4

                  -0.45

                   -0.5
                           0   5   10   15     20    25     30     35    40     45


                  -0.38

                   -0.4

                  -0.42

                  -0.44
                           0   5   10   15     20    25     30     35    40     45


                  -0.39


                   -0.4


                  -0.41


                  -0.42
                           0   5   10   15     20    25     30     35    40     45




     Figure 3.5 – u 1 behavior when applying the controllers (3.11), (3.26), (3.36) and (3.48).

                       1

                     0.5

                       0

                    -0.5

                      -1
                           0   5   10   15     20     25    30     35    40     45



                     0.4

                     0.2

                       0

                    -0.2

                    -0.4
                           0   5   10   15     20     25    30     35    40     45



                     0.2

                     0.1

                       0

                    -0.1

                    -0.2
                           0   5   10   15     20     25    30     35    40     45


                   0.04

                   0.02

                       0

                   -0.02

                   -0.04
                           0   5   10   15     20     25    30     35    40     45




      Figure 3.6 – Torque control u 2 response when applying the four control algorithms.


54


                             3.1. Comparison of stabilization and tracking control algorithms


Experimental results

The control algorithms (3.11), (3.26), (3.36) and (3.48) were validated in real time in a quad-
copter vehicle evolving as a PVTOL vehicle. For this, front motors ( f L 2 , f R2 ) and rear motors
( f L 1 , f R1 ) in the aerial vehicle are considered producing only a force in the front and rear side
of the vehicle, as depicted in Figure 3.7. A video with the experimental results can be seen at:
https://youtu.be/Fi4uUbQRrgw

Notice from this figure that f 1 = f L 1 + f R1 and f 2 = f L 2 + f R2 . Vertical displacement on the z axis
is produced when increasing or decreasing, by the same magnitude the speed in the motors,
while pitch moment is produced with the difference between f 1 and f 2 . This quadcopter
vehicle evolving as a PVTOL is an AR Drone 2. Its firmware was modified to work under the
software Fl-AIR - Framework libre AIR which is open source and runs a Linux-based operating
system, capable of implementing a wide range of control schemes, see [160]. An OptiTrack
motion capture system was used to estimate the vehicle’s position, while its internal Inertial
Measurement Unit (IMU) measures its orientation and angular rates.




             Figure 3.7 – Quadcopter configuration evolving its longitudinal plane.

Conditions for flight tests are the same as used in the simulation section, i.e. the initial
conditions are x(0) = −2m and z(0) = 1m while x r 1 = 2, x r 2 = 4 and x r 3 = 5 in meters are
the references. In Figures 3.8- 3.11 the state responses when applying the controllers are
illustrated. Notice from Figure 3.8, as in the simulation case, the convergence of controllers
based on saturation functions are quite slower due to the bound of these functions that helps
to maintain a relative small error with respect to the others controllers. Nevertheless, the LB
controller has a faster convergence but in this case, implying more energy and therefore a
bigger attitude response as we will see in the next figures.

The angular performance of the quadcotper system when using the four control algorithms
is depicted in Figure 3.9. Remark that for the virtual control algorithm a desired angle is
imposed and tracked satisfactorily. Similarly in this figure observe that θ-response is bigger
for those controllers that are mainly designed without saturation functions. From this figure it
is possible to make a relation between the fast convergence of controllers and their attitude
response. This means that, faster the convergence is achieved, then, bigger the attitude
response.

                                                                                                        55


Chapter 3. Control approaches for aerial vehicles



                    6


                    5


                    4


                    3


                    2


                    1


                    0


                   -1


                   -2


                   -3
                        0     10        20        30        40        50        60




Figure 3.8 – Longitudinal behavior when applying experimentally the four control algorithms
into the aerial vehicle.




Figure 3.9 – θ angle response when the four control algorithms where applied in real time. θd
describes the desired angle.

Observe in Figure 3.10, that the magnitude of the error in the z−axis is directly related to the
x−axis error. This means that if the desired x-position is far, then, the error in the vertical axis
increases. And as a consequence, the magnitude of the θ angle is affected as can be verified in
Figure 3.9. Therefore, as observed from this same figure, it is possible to use small values for
the saturation functions or furthermore reduce the control gains of the LB and NLB controllers,
however it will compromise the performance of the system reducing the convergence of the
states to the desired positions.

56


                                    3.1. Comparison of stabilization and tracking control algorithms


Moreover, a big angle response should increase the vertical error in the vehicle when using
control algorithms based on the classical approach as can be seen in Figure 3.11. Besides,
when using controllers based on the virtual approach or controllers using bounded functions,
this error is minimized as shown in Fig. 3.11. Notice the performance of the LB and NLB
controllers. Due the longitudinal error increases, the altitude response is affected in order to
fulfill the control objective. It is well known that this altitude error can be fixed re-tuning the
control gains for every new desired position, however that was out of the scope of this thesis.


                   1.4


                   1.3


                   1.2


                   1.1


                        1


                   0.9


                   0.8


                   0.7


                   0.6


                   0.5
                            0            10        20       30         40          50       60




            Figure 3.10 – Vertical position comparing the four control algorithms.



                  1.5


                  1.4


                  1.3
                                                                             xr3
                                                                       xr2
                  1.2
                                                             xr1
                             x(0)
                  1.1


                   1


                  0.9


                  0.8


                  0.7


                  0.6


                  0.5
                        -3          -2        -1   0    1          2    3     4         5    6




Figure 3.11 – Vehicle’s performance evolution in the x − z plane when the four control algo-
rithms are applied in real time.



                                                                                                 57


Chapter 3. Control approaches for aerial vehicles


In Figures 3.12 and 3.13 the control input responses are illustrated. Notice that they have
obtained similar performance as in the case of simulations results. In the next section, we
introduce a discussion in terms of the control inputs using the indices performance and
qualitative variables to expose our conclusions for the four control algorithms.




Figure 3.12 – Thrust control u 1 response for the four control algorithms applied to the aerial
vehicle.




         Figure 3.13 – Torque control response, u 2 , obtained during the flight tests.


58


                          3.1. Comparison of stabilization and tracking control algorithms


3.1.6 Discussion

We have carried out an analysis of the performance of the four control algorithms. For this
purpose, the performance indices and a qualitative comparison of the controller are obtained.
The performance indices are the Integral Square Error (ISE), the Integral Absolute Error (IAE),
the Integral time Squared Error (ITSE) and the Integral time Absolute Error (ITAE). A summary
of this analysis is presented in Tables 3.2 - 3.4.

From the steady state regime experimental results, in Table 3.2 it can be observed that the
Nested Saturation and Hyperbolic Saturation controllers achieve the best performance in
terms of the vertical error. The HSC presents less error than NS. However, the HSC algorithm
includes a bigger computational effort with respect to the other algorithms due the derivatives
of the desired angle θd . It can be analyzed from the design of the HSC controller that imposes
desired angles, therefore, this increases the time of convergence to the desired translational
values. Nevertheless, it could be an advantage because when imposing desired angles, we can
ensure converge even if the desired position are far away. Observe also from tables that the
Nested Saturation controller is quite small with respect to the other approaches due mainly
to the values of the bound of the saturation functions. The linear backstepping controller
presents a small error in the longitudinal axis and faster convergence time as can be observed
in tables. Nonetheless, according to Table 3.2 this control algorithm has a bigger vertical error
and by consequence control effort u 2 required is also bigger.

                        Table 3.2 – Performance indices of the z−axis

                      Controllers/Indices    IAE     ISE     ITAE     ITSE
                              LB             2.97    0.48    99.48    17.98
                             NLB             2.40    0.30    82.38    12.33
                              NS             1.16    0.03    35.63     1.02
                             HSC             1.09    0.04    30.04     1.35


                        Table 3.3 – Performance indices of the x−axis

                   Controllers/Indices      IAE      ISE      ITAE      ITSE
                           LB              60.21    221.56    1453      7132
                          NLB              64.53    241.37    1937      7780
                           NS              77.96    290.13    2324     10188
                          HSC              83.51    308.68   266.76    14752


Regarding the design, tuning and the implementation effort, the linear backstepping and
nested saturation algorithms are easier to tune because their structure can be seen as Pro-
portional Derivative controllers. In contrast, the NLB and the HSC are tedious to implement
since both present several complex derivatives and they have more parameters to tune. In
this context, Table 3.4 presents a behavior comparison between the four algorithms including
numerical and practical validation and other qualitative indicators.

                                                                                              59


Chapter 3. Control approaches for aerial vehicles


Table 3.4 – Qualitative comparison of the control algorithms. The best result is denoted with 1
and the worst with 4.

                                                             LB      NLB       NS     HSC
                                Converge to
                                                              1        4        3        2
                               the reference
                           Computational effort               1        3        2        3
                               Control effort                 4        3        1        1
                           Design & tuning effort             1        4        2        3
                           Real implementation                1        4        2        3


Concerning the methods to design these control laws, one of the advantages of the virtual
method is the possibility to design any control law (adaptive control, sliding mode control,
etc) in F 1 and F 2 that could significantly improve the performance of the system. Here,
the challenge will be to design control laws capable to provide desired angles respecting
the mechanical constraints of the vehicle for avoiding singularities in the control input u 2 .
The disadvantage, as previously mentioned, is the complexity of the implementation of the
algorithms due of the first and second derivative of F 1 and F 2 . In contrast, the classical method
gives the advantage of an easy fashion to get the analysis and design of the control algorithms
based on the assumption that the vertical axis is controlled. However, the control effort of the
inputs u 1 and u 2 could be larger if the desired positions are far from the initial conditions.

3.2 Quaternion-based backstepping control
In this section, a backstepping quaternion control is designed based on the proposed dynamic
model (2.52) developed in Section 2.3. According to this section and in particular, subsection
2.3.2, it is possible to decouple the whole dynamic model of the vehicle in terms of a desired
                                                                   ~ ∈ I . Let us consider the ro-
attitude q d , which is described by a desired thrust vector force U
tational dynamic model of the quadcopter represented by (2.51) as the associated quaternion
for the tracking attitude error defined by (2.53). Therefore, the thrust vector force U~ must be
established in terms of the translational system (2.54).


Backstepping position controller

Following the procedure of the bacsktepping control technique, as in the case of using Euler-
angles, let us define the tracking error define the error e x1 as e x1 = x 1 − x 1d , where x 1d is the
                                                                   αx
reference. Let us propose the following positive function V1 = 21 e x21 , with αx1 > 0 denoting
a constant, then taking the derivative with respect to time and proposing x 2v = x 2d − e x1 as a
virtual control input, it follows that

                        V̇1 = αx1 e x1 (x 2 − x 2v − e x1 ) = −αx1 e x21 + αx1 e x1 (x 2 − x 2v )

where ẋ 1d = x 2d . Define the error e x2 = x 2 −x 2v thus, the previous yields V̇1 = −αx1 e x21 +αx1 e x1 e x2 .
                                                      αx
Propose the second positive function V2 = 22 e x22 with αx2 > 0 constant.

60


                                                          3.2. Quaternion-based backstepping control


Differentiating with respect to time

                                            V̇2 = αx2 e x2 (U x − ẋ 2v )

                                                                            αx
Proposing U x = −e x2 + ẋ 2v − α1                     d           d     1
                                α2 e x 1 = −e x 2 + ẋ 2 − x 2 + x 2 − αx2 e x 1 , the, defining the Lyapunov
function VT = V1 + V2 and differentiating with respect to time, it follows that

                      V̇T = V̇1 + V̇2 = −αx1 e x21 + αx1 e x1 e x2 − αx2 e x22 − α1 e x1 e x2
                                                                                                         (3.79)
                      V̇T = −αx1 e x21 − αx2 e x22 < 0

The procedure to get the virtual control inputs U y and U z is exactly the same as for U x . Thus
without lost of generality, it is possible to define the control vector of the form
                                                                       αx
                                         −e x2 + ẋ 2d − x 2 + x 2d − αx1 e x1
                                                                            
                               Ux                                         2
                           ~ =      −e + ẏ d − y + y d − αy1 e             
                           U  U y  =      y2      2     2     2     αy2 y 1 
                                                                                                        (3.80)
                                                                    αz 1
                                       
                               Uz                  d           d
                                        −e z2 + ż 2 − z 2 + z 2 − α e z1 + gz2



where αi j are positive constants. Therefore, the thrust can be defined as
                                                  q
                                                   U x2 +U y2 +U z2
                                           u1 =                         .                                (3.81)
                                                            m

                                                                           ~ as
Then, from (2.56) and (2.57) let us define the unit vector associated with U
                                                             
                                                             Ux
                                      ~
                                      U           1
                                  ~
                                  µ= ° ° = q                U y  .                                     (3.82)
                                                             
                                      ~°
                                     °U
                                            U x2 +U y2 +U z2 U z

The desired quaternion q d can be computed using (2.59) and (2.60) as follows
                                   
                   "      #  q d 0                    s                           s
                                                           1 +~υ ~
                                                                 µ                     1 +~υT ~
                                                                                              µ
                                    
                     qd 0   q d 1 
              qd =         =
                                   ,        qd 0 =               ,        ~
                                                                            qd =                  µ)~υ
                                                                                                S(~      (3.83)
                     q~d    q d 2 
                                                             2                            2
                              qd 3

where~υ = [0 0 1]T and S(~
                         µ) is defined as

                                                                    µ2
                                                                       
                                                0          −µ3
                                         µ) =  µ3
                                       S(~                  0       −µ1  .
                                                                       

                                               −µ2          µ1       0

Consequently, choosing proper control gains αi j in (3.80) such that (3.81) aligns F  ~ξ with U~,
then, the position error will converge to zero and therefore, the translational quadrotor system
(2.54) can be stabilized in any desired position.



                                                                                                            61


Chapter 3. Control approaches for aerial vehicles


Once the desired quaternion is defined, the control of the attitude system and its stability
analysis must be addressed. For that, let us propose the following change of coordinates
                                             "             #
                                       ~1 =    1 − |q e0 |
                                       Z                                               (3.84)
                                                  ~
                                                  qe

where ~
      q e = [q e1 q e2 q e3 ]T and q e = q d∗ ⊗ q. Then computing its derivative with respect to time
                       "                                                                               #
                                  − sgn q e0 q d 0 q̇ 0 + q̇ d 0 q 0 + ~   q˙dT q̄ + ~    q˙
                                                                                     q dT ~
                                                ¡                                            ¢
                                                                                                         (3.85)
                         −~ q˙d q 0 − ~                    q + q d 0 I3 ~
                                      q d q̇ 0 + q̇ d 0 I3 ~            q˙ − S(~ q˙d )~
                                                                                      q − S(~       q˙
                                                                                               q d )~

Considering the case of regulation problem, it follows that q̇ d 0 , q̇˙d → 0, then
                                           "                               ¢#
                                         ˙ − sgn q e0 q d 0 q̇ 0 + ~    q˙
                                                                   q dT ~
                                                       ¡
                                        ~
                                        Z1                                                              (3.86)
                                                 q˙ − ~
                                             qd 0~                      q˙
                                                                   q d )~
                                                      q d q̇ 0 − S(~

From (2.51), it follows that (3.86) can be rewritten as
                             "                                                            #
                                                           ~ T   ~ T
                                                                          I
                                                   ¡                                  ¢
                      ˙
                      ~1 = 1       −sg   n(q  e0 )   q d 0 q   + q   (q 0   3 + S(~
                                                                                  q ))
                     Z                                             d                                    (3.87)
                                               q )) − q̄ d q̄ T − S(q̄ d )(q 0 I3 + S(q̄))
                           2 q d 0 (q 0 I3 + S(~

                                                            ~˙1 (1) = sgn(q e0 )~
Remark that the first element of (3.87) can be expressed as Z                   q eT and the second
                                                             T      T
element can be rewritten using the property S(a)S(b) = ba − a b I as

                  ~˙1 (2) = 1 q d 0 ~
                  Z                 q d I3 + q d 0 S(~    qT ~
                                                     q) + ~          q d )q 0 I3 − S(~      q) ~Ω
                              ¡                                                               ¢
                                                             q d − S(~               q d )S(~           (3.88)
                            2

Defining
                                 q e ) = q d 0 S(~
                               S(~                    q T q d 0 − S(~
                                                 q) + ~                           q~
                                                                    q d )q 0 I3 − ~ q dT                (3.89)

      ~˙1 is expressed as
then, Z
                                                 ~˙1 = 1 M (q e )~
                                                 Z               Ω                                      (3.90)
                                                       2
where                                                  "               #
                                                      sgn(q e 0)~ q eT
                                           M (q e ) =                    .
                                                      q e0 I3 + S(~
                                                                  qe )

                                                       ~T Z
Let us propose a positive function of the form V1 = 12 Z   ~1 and differentiating with respect to
                                                         1
time is given by
                                            1 ~T
                                       V̇1 = Z   M (q e )~
                                                         Ω                                 (3.91)
                                            2 1
The main idea behind the backstepping technique is to propose a virtual control input such
that V̇1 ≤ 0, thus, let us introduce
                                             ~                   ~1
                                             Ωv = −K 1 M T (q e )Z                                      (3.92)

then, the derivative of V1 can be expressed as
                                           1 ~T                       ~1 ≤ 0
                                    V̇1 = − Z   M (q e )K 1 M (T q e )Z                                 (3.93)
                                           2 1


62


                                                  3.2. Quaternion-based backstepping control


                              ~2 = ~
Proposing the second error as Z    Ω−~
                                     Ωv and differentiating with respect to time,

                                   ~˙2 = ~
                                   Z     ˙ −~
                                         Ω  ˙v
                                            Ω
                                                                                            (3.94)
                                   ~˙2 = I −1 (−~
                                   Z            ΩI S(~       ˙ v)
                                                         τ− I~
                                                     Ω) +~   Ω

                                         ~2 and its derivatives can be expressed as
                                  ~1 and Z
The system in terms of the errors Z

                                   ~˙1 = 1 M (q e )(~
                                   Z                Ωv + Z~2 )
                                         2                                                  (3.95)
                                   ~˙2 = I −1 (−~
                                   Z            ΩI S(~Ω) +~    ˙ v)
                                                           τ− I~
                                                               Ω

                                                  ~T Z
Proposing a Lyapunov function of the form VT = 12 Z          ~T ~
                                                      ~1 + 1 Z
                                                    1      2 2 Z 2 and its derivative with
respect to time given by

                      ~T Z
                V̇T = Z   ~˙1 + Z
                                ~T Z~˙2
                        1         2
                    1 ~T                                                                    (3.96)
                   = Z   (M (q e )~            ~2 ) + Z
                                  Ωv + M (q e )Z      ~ T (I −1 (−~
                                                                  ΩI S(~       ˙ v ))
                                                                           τ− I~
                                                                       Ω) +~   Ω
                    2 1                                 2


Choosing ~
         τ as
                                           ˙ v −K Z
                                                  ~   1        T ~
                               ΩI S(~
                             τ=~
                             ~      Ω) + I ~
                                           Ω     2 2 − M (q e ) Z 1                         (3.97)
                                                      2
then, it can be see that using (3.97) system (3.95) is stabilized and therefore, the full dynamic
quadcopter model described by (2.52) is asymptotically stable

                                1 ~T                            ~ T K2Z
                                                           ~1 − Z     ~2 ≤ 0.
                         V̇T = − Z   M (q e )K 1 M T (q e )Z                                (3.98)
                                2 1                               2


The final control input equation using the quaternion backstepping control can be expressed
in terms of states as follows

                                                      Ωx
                                                                         
           0     −Ωx        0      I xx    0     0              K 2x  0     0
    ~
    τ =  Ωz      0       −Ωx   0 I y y        0  Ω y  −  0    K 2y   0 
                                                                         

          −Ω y Ωx           0        0     0 I zz     Ωz          0   0    K 2z
                                                                                             
                                                                                   1 − |q e0 |
         Ωx
                                           
                   K          0      0          sgn(q e0 )q e1 q 0 −q 3 q 2
           1x
                                                                                               
        Ω y  −  0                    1                                        q1       
                              L 1y    0  × sgn(q e0 )q e2 q 3        q 0 −q 1              
                                           2                                      q 2 
                                                                                                
           Ωz           0      0 K 1z            sgn(q e0 )q e3 −q 2 q 1     q0
                 
                                                                                       q3
                                                                 
                                                    1 − |q e0 |
              sgn(q e0 )q e1 q 0 −q 3 q 2                        
          1                                              q1   .
        − sgn(q e0 )q e2 q 3           q 0 −q 1    
          2                                                 q 2
                                                                  
              sgn(q e0 )q e3 −q 2 q 1          q0
                                                                 
                                                            q3
                                                                                            (3.99)

with K 1i and K 2i where i ∈ [x, y, z] are positive constants, Ωi represents the angular velocity
and I stands for the inertia tensor.


                                                                                                63


Chapter 3. Control approaches for aerial vehicles


3.2.1 Experimental test

In this section, the validation of the control algorithm (3.99) based on the quadcopter quater-
nion model (2.52) is addressed. For this experimental test, an AR Drone 2 was employed
using the Fl-AIR framework open source code. The scenario consists in the following: the
vehicle is located in a random hover position ~  ξ(0) = [0, 0, 1.2m]T and thus, a circular desired
trajectory ~ξd = [a cos(t ), a sin(t ), 1.2m]T must be tracked. The desired quaternion
                                                                                    ³ ´ around
                                                                                    ξd y
the z−axis is defined by q z = [cos(ψd /2), 0, 0, sin(ψd /2)]T where ψd = arctan ξd , and the
                                                                                   x
desired quaternion is given by q d = q t ⊗ q z . The control parameters used in this test are
depicted in Table 3.5.

The performance of the vehicle when tracking a circular desired trajectory is presented in
Figures 3.14 to 3.18. Notice from Figures 3.14 and 3.15 the well behavior of the proposed
control algorithm. It can be observed that the x and y axes are well tracked with a small ² error
in the z−axis. The vehicle’s front is pointing towards the sense of the trajectory according to
the desired ψd angle.




              Figure 3.14 – Performance of the quadcpter during the flight test


               Table 3.5 – Control gains parameters used in experimental tests


                                  Parameter      x     y     z
                                      α1        0.1   0.1   0.1
                                      α2        0.8   0.8   0.8
                                      K2        0.2   0.2   0.2
                                      L1        30    30    10



64


                                                3.2. Quaternion-based backstepping control




                          Figure 3.15 – Quadcotper position tracking

The desired attitude trajectory, computed by (2.60) and (3.83), is illustrated in Figure 3.16. No-
tice the well performance of q 0 and q 3 which are related with the desired ψd angle. Moreover,
it is important to remark that, although the rotation of the vehicle completes more than one
complete tour around the z−axis, the attitude is continuous. This lack of discontinuity points
is one of the main advantages of using quaternion approaches.




Figure 3.16 – Quadcopter attitude quaternion performance when tracking the desired pose
trajectory


                                                                                               65


Chapter 3. Control approaches for aerial vehicles


Figures 3.17 and 3.18 present the performance of the designed controllers (3.80), (3.81) and
(3.99) when tracking a circular desired trajectory. Let us recall that this controller compute the
torques and forces required to stabilize the vehicle in the desired references.

                      0.5



                      0.4



                      0.3



                      0.2



                      0.1



                        0



                     -0.1
                             0   5         10            15         20            25   30



                     Figure 3.17 – Performance of the control input forces

                     0.15



                       0.1



                     0.05



                         0



                     -0.05



                      -0.1



                     -0.15
                             0   5         10            15         20            25   30



                    Figure 3.18 – Performance of the rotational controller

To better illustrate the vehicle’s rotational behavior, the equivalent Euler angles are illustrated
on Figure 3.19 and were computed using the following equation
                                                  Ã                           !
                                                      2(q 0 q 1 + q 2 q 3 )
                                     φ = arctan                        ,
                                               1 − 2(q 12 + q 22 )
                                  θ = arcsin 2(q 0 q 2 − q 1 q 3 ) ,
                                            ¡                      ¢
                                                                                            (3.100)
                                             Ã                       !
                                               2(q 0 q 3 + q 1 q 2 )
                                  ψ = arctan                           .
                                               1 − 2(q 22 + q 32 )

66


                                          3.3. Finite-time convergence using Sliding Mode Control


Note this conversion uncovers the discontinuities that are present when completing full rota-
tions (±180◦ ), also note that the yaw angle error displays sudden jumps when such rotations
are reached, this may cause undesired behaviors in experiments if left unfixed.




                    Figure 3.19 – Quadcopter attitude axis-angle representation


3.3 Finite-time convergence using Sliding Mode Control
The next method developed in this thesis concerns the convergence in finite time of an aerial
drone to a mobile target using the properties of the sliding mode control. In order to that,
the target must to remain in the field of view (FoV) of the quadrotor vehicle. Therefore, the
goal is to compute desired trajectory with finite time convergence t̄ , such that, the control
objective ~ r (t̄ ) = ~
                      ξT −~ r s can be guaranteed in finite-time convergence. Note ~            ξT = [x T y T z T ]>
represents the position of the target and ~                 ξ −~
                                                       rs = ~  ξd means the error between the quadrotor
and, a desired reference to keep a distance with the mobile target. This distance is defined by
the constant ~    ξd = [x d , y d , z d ]> . The goal of this section is to design a desired trajectory such
that the quadcopter can follow and achieve the position ~               r (t̄ ) in finite time t̄ . This trajectory
will be composed of three components x c (t ), y c (t ) and z c (t ), and represented by the position
vector ~
                                                 ¤>
         ξc (t ) = x c (t ) , y c (t ) , z c (t ) where each component x c (t ) → x T , y c (t ) → y T in finite
                    £

time t̄ , and with a constant altitude z c (t ) = z c (0) for all t ≥ 0.

3.3.1 x c (t ) and y c (t ) components

For designing the first component x c (t ) such that x c (t ) → x T in finite time t̄ let us define
the position error as %xc (t ) = x c (t ) − x T . Notice that if %xc (t ) = 0 for all t ≥ t̄ then, this will
imply that x c (t ) = x T ∀t ≥ t̄ . Computing the derivative of %xc with respect to time, it follows
that %̇xc (t ) = ẋ c (t ), %̈xC (t ) = ẍ c (t ) where its initial conditions are given by %xc (0) = x c (0) − x̄ 1 ,
%̇xc (0) = ẋ c (0) = 0, %̈xc (0) = ẍ c (0) = 0.

                                                                                                                  67


Chapter 3. Control approaches for aerial vehicles


The objective is that %xc (t ) = %̇xc (t ) = %̈xc (t ) = 0 in a finite time t̄ , thus, the following variables
and its derivatives can be stated: xc (t ) = %xc (t ) − µx (t ), ˙ xc (t ) = %̇xc (t ) − µ̇x (t ) and ¨ xc (t ) =
                                        P                             P                               P

%̈xc (t ) − µ̈x (t ) with
                                             ¢3 ¡
                      µx (t )                    c0 + c1 t + c2 t 2
                                     ¡                              ¢
                                 =       t − t̄
                                             ¢3                         ¢2 ¡
                      µ̇x (t )         t − t̄ (c 1 + 2c 2 t ) + 3 t − t̄ c 0 + c 1 t + c 2 t 2
                                     ¡                            ¡                            ¢
                                 =
                                                  ¢3           ¢2
                      µ̈x (t )       2c 2 t − t̄ + 6 t − t̄ (c 1 + 2c 2 t ) + 6 t − t̄ c 0 + c 1 t + c 2 t 2
                                          ¡             ¡                         ¡       ¢¡                 ¢
                                 =

and for derivatives i : 0, 1, 2

                                                                   i
                                                              (
                                                  i                µx (t ) for 0 ≤ t < t̄
                                                  µx (t ) =                                                      (3.101)
                                                                   0      for t ≥ t̄

Then                                                  
                                     i                 %i (t ) − µi (t ) for 0 ≤ t < t̄
                                                          xc        x
                                     X
                                               (t ) =                                                            (3.102)
                                            xc         %i (t )          for t ≥ t̄
                                                              xc


Observe that xc (0) = 0 implies that %xc (0) = µx (0), c 0 = (x̄ 1 − x c (0))/t̄ 3 . ˙ xc (0) = 0 means
                      P                                                                P

that %̇xc (0) = µ̇x (0), hence c 1 = 3c 0 /t̄ and ¨ xc (0) = 0 means that %̈xc (0) = µ̈x (0), then c 2 =
                                                  P

(3c 1 t̄ − 3c 0 )/t̄ 2 .
                                                        ...     ...       ...        ...        ...
Taking the third derivative of xc , it follows that xc (t ) = ρ xc (t ) − µ x (t ) = x c (t ) − µ x (t ). If
                                  P                     P

                           Ã                                                             !
                                    µ¯     ¯3 ¯X ¯2 ¶1/6        µ        ¯X ¯2/3    ³X ´¶
       ...                  X¨       ¯X˙                         X˙
       x c (t ) = −αx sign        +2 ¯ x ¯ +¯ x ¯        × sign        + ¯ x ¯ sign                              (3.103)
                                           ¯ ¯     ¯                     ¯    ¯
                               xc        c       c                  xc      c         xc


with a sufficiently large αx . The finite-time stability is ensured from Theorem 6.2 in [161].
The above implies that %xc (t ) = µx (t ), %̇xc (t ) = µ̇x (t ) and %̈xc (t ) = µ̈x (t ) ∀ t ≥ t r . Nevertheless,
if t r ≤ t̄ when t → t̄ and from (3.101) it follows that %xc (t ) = µx (t ) = 0, %̇xc (t ) = µ̇x (t ) = 0, and
%̈xc (t ) = µ̈x (t ) = 0, ∀ t ≥ t̄ . This means that x c (t ) = x T for all t ≥ t̄ therefore the finite-time
convergence to x T is achieved.

Propose x c = x 1c , ẋ 1c = x 2c , ẋ 2c = x 3c then it follows that

            ẋ 1c =      x 2c
            ẋ 2c =      x 3c
                                     Ã                                                                    !
                                                      µ¯    ¯3 ¯X ¯2 ¶1/6        µ        ¯X ¯2/3    ³X ´¶
                         −αx sign ¨ x + 2                ˙                         ˙
                                  X                    ¯X                         X
            ẋ 3c =                                    ¯ xc ¯ + ¯ xc ¯    × sign        + ¯ x ¯ sign        (3.104)
                                                            ¯ ¯      ¯                    ¯    ¯
                                             c                                       xc      c         xc


with                                                     (
                                                              0,      for t = 0
                                                  αx =                                                           (3.105)
                                                              αx > 0, for t > 0

αx is defined in this form to achieve ẋ 3c (0) = 0.




68


                                              3.3. Finite-time convergence using Sliding Mode Control


Following the previous procedure the y c (t ) component is obtained as

             ẏ 1c =   y 2c
             ẏ 2c =   y 3c
                                 Ã                                                             !
                                          µ¯     ¯3 ¯X ¯2 ¶1/6        µ        ¯X ¯2/3    ³X ´¶
             ẏ 3c =   −α y sign
                                  X¨       ¯X˙
                                        +2 ¯ y ¯ +¯ y ¯
                                                 ¯ ¯     ¯
                                                               × sign
                                                                       X˙    + ¯ y ¯ sign
                                                                               ¯    ¯
                                                                                                 (3.106)
                                     yc        c       c                  yc      c         yc


with                                              (
                                                      0,       for t = 0
                                           αy =                                                                       (3.107)
                                                      α y > 0, for t > 0

α y is defined in this form to achieve ẏ 3c (0) = 0.


3.3.2 Sliding mode control design

The goal in this subsection is to design a controller, based on the sliding mode properties, capa-
ble to make the quadcopter tracks the proposed trajectory ~         ξc (t ) with asymptotic convergence.
Thus, the first step is to define the tracking errors as follows
                                                                1
                          ė x1 = e x2 ;   ė x2 = − sin (θ1 ) u 1 − δx
                                                                m
                                                                 ¡ ¢ 1
                          ė y 1 = e y 2 ; ė y 2 = cos (θ1 ) sin φ1       u1 − δy               (3.108)
                                                                       m
                                                                  ¡ ¢ 1
                          ė z1 = e z2 ;   ė z2 = cos (θ1 ) cos φ1        u 1 − δz
                                                                       m

where e x1 = x 1 − x 1c ; e y 1 = y 1 − y 1c ; e z1 = z 1 − z c (0); ė x1 = e x2 = x 2 − x 2c ; ė y 1 = e y 2 = y 2 − y 2c and
ė z1 = e z2 = z 2 . Also, δx = x 3c , δ y = y 3c and δz = g .

Proposing u 1 as
                                                            m
                                          u1 =                       ¢ [δz + r 3 ]                                    (3.109)
                                                  cos (θ1c ) cos φ1c
                                                                ¡

where φ1c and θ1c are the desired angles and r 3 will be defined later to assure convergence.

Introducing u 1 into ė z2 it follows that

                                                            m
                                                   ½                               ¾
                                             ¡ ¢ 1
                        ė z2 = cos (θ1 ) cos φ1                      ¢ [δz + r 3 ] − δz
                                                           
                                                  cos (θ1c ) cos φ1c
                                                                 ¡
                                                 m
                                                 

If φ1 → φ1c , θ1 → θ1c , ψ1 → ψ1c , this will imply that

                                                   ė z1 = e z2 ; ė z2 = r 3

Defining r 3 = −K p z e z1 − K d z e z2 with K p z > 0 and K d z > 0, then e z1 , e z2 → 0.

Then, the new goal is to find φ1c and θ1c . Introducing u 1 into ė y 2 in (3.108), and considering
that τφ , τθ , τψ are designed such that φ1 → φ1c , θ1 → θ1c , ψ1 → ψ1c , then

                                   ė y 2 = tan φ1c [δz + r 3 ] − δ y
                                               ¡   ¢
                                                                                             (3.110)


                                                                                                                            69


Chapter 3. Control approaches for aerial vehicles


and φ1c can be computed as
                                                                      δy + r 2
                                                                  µ              ¶
                                                             −1
                                                φ1c = tan                                                     (3.111)
                                                                      δz + r 3
Therefore, the next subsystem is obtained

                                                 ė y 1 = e y 2 ; ė y 2 = r 2

Proposing r 2 = −K p y e y 1 − K d y e y 2 with K p y > 0 and K d y > 0 this implies that e y 1 , e y 2 → 0.

Introducing u 1 into ė x2 in (3.108) and considering that τφ , τθ , τψ are designed such that
φ1 → φ1c , θ1 → θ1c , ψ1 → ψ1c , then
                                                        ½                  ¾
                                                         1
                                 ė x2 = − tan (θ1c )         ¢ [δz + r 3 ] − δx
                                                      cos φ1c
                                                         ¡


and θ1c can be proposed as

                                                                   ¢ δx + r 1
                                                     ½              µ          ¶¾
                                                −1
                                    θ1c = tan         (−1) cos φ1c
                                                              ¡
                                                                                                              (3.112)
                                                                      δz + r 3

Hence, the following subsystem is obtained

                                                 ė x1 = e x2 ; ė x2 = r 1

and proposing r 1 = −K p x e x1 − K d x e x2 with K p x > 0 and K d x > 0, we will able to accomplish the
asymptotic convergence of e x1 and e x2 around (0, 0).

To simplify notation, define T x = δx + r 1 , T y = δ y + r 2 and T z = δz + r 3 . Therefore the desired
angular velocities φ̇1c = φ2c and θ̇1c = θ2c are

                             cos2 φ1c £
                                 ¡     ¢
                      φ2c =               Ṫ y − Ṫ z tan φ1c
                                                          ¡   ¢¤
                      
                                 Tz                                                                            (3.113)
                             cos2 (θ1c ) £
                      θ2c =              T x sin φ1c φ2c − Ṫ z tan (θ1c ) − Ṫ x cos φ1c
                      
                                                  ¡     ¢                            ¡    ¢¤
                                Tz

The initial desired angular positions and velocities are given by φ1c (0) = 0, θ1c (0) = 0 and
φ2c (0) = 0, θ2c (0) = 0.

From (2.18), (3.111) and (3.112) it is possible to represent the attitude of a quadcopter in errors
terms as follows
                            ė φ1 = e φ2            ė φ2 = f¯1 + b 1 τφ + ζ1
                            ė θ1 = e θ2            ė θ2 = f¯2 + b 2 τθ + ζ2               (3.114)
                            ė ψ = e ψ                        ¯
                                                    ė ψ = f 3 + b 3 τψ + ζ3
                                     1      2                         2


where e φ1 = φ1 − φ1c , e θ1 = θ1 − θ1c , e ψ1 = ψ1 − ψ1c , ė φ1 = e φ2 = φ2 − φ̇1c , ė θ1 = e θ2 = θ2 − θ̇1c ,
ė ψ1 = e ψ2 − ψ̇1c . Moreover f¯1 = (e θ2 + θ̇1c )(e ψ2 γ1 − β1 ) − φ̈1c , f¯2 = (e φ2 + φ̇1c )(e ψ2 γ2 − β2 ) − θ̈1c ,
                                            0
f¯3 = (e θ2 + θ̇1c )(e φ2 + φ̇1c )γ3 −  >. ζ ≤ L for i ∈ [1, 2, 3] are bounded perturbations. The
                                       ψ̈1c
                                         
                                             i   i
desired angle yaw ψ1c is considered constant, then ψ̇1c = ψ̈1c = 0.


70


                                                3.3. Finite-time convergence using Sliding Mode Control


Once the rotational errors are given in terms of the desired angles φc , θc , then the goal is to
design τφ , τθ , τψ such that e φ1 = φ1 − φ1c → 0, e θ1 = θ1 − θ1c → 0 and e ψ1 = ψ1 − ψ1c → 0 in
finite time t ∗ , where t ∗ < t̄ . In this way e φ1 , e θ1 and e ψ1 converge to zero faster, to guarantee
that the quadcopter position goes to the desired trajectory in finite time t̄ . In addition, it is also
necessary that e φ1 ≈ 0, e θ1 ≈ 0 and e ψ1 ≈ 0 ∀ 0 ≤ t < t ∗ , the previous will imply that φ1 ≈ φ1c ,
θ1 ≈ θ1c , ψ1 ≈ ψ1c for 0 ≤ t < t ∗ .

To guarantee the above stated, a new tracking trajectory and its derivatives are defined as
                                                (
                                                    i µ(t )     for     0 < t < t∗
                                    i χ(t ) =                                                       (3.115)
                                                    0         for     t = 0 and t ≥ t ∗

with i : 0, 1, 2 and µ (t ), µ̇ (t ) and µ̈ (t ) into (3.115) are given by

                                                         πt
                                        µ      µ       µ ¶¶        ¶
                      µ(t )     =     c exp − sin3 ∗ − 1                                             (3.116)
                                                         t
                                                   πt                               πt
                                                  µ ¶       µ       ¶     µ       µ ¶¶
                                         3πc                  2πt
                      µ̇(t )    =     − ∗ sin ∗ sin ∗ exp − sin3 ∗                                   (3.117)
                                         2t        t           t                    t
                                      9π2 c        πt                                 πt
                                                  µ ¶         µ       ¶     µ       µ ¶¶
                                                                2πt
                      µ̈ (t )   =             sin2 ∗ sin2               exp − sin3 ∗
                                       4t ∗2        t            t∗                   t
                                            2 ½
                                         3π c          πt                                  πt
                                                      µ ¶       µ       ¶       µ       ¶ µ ¶¾
                                                                  2πt             2πt
                                      −      2
                                                 cos ∗ sin ∗ + 2 cos ∗ sin ∗
                                         2t ∗          t           t               t       t
                                                       πt
                                             µ        µ ¶¶
                                        exp − sin3 ∗                                                 (3.118)
                                                       t

Notice from previous equations that µ(0) = µ (t ∗ ) = 0, µ̇(0) = µ̇ (t ∗ ) = 0 and µ̈(0) = µ̈ (t ∗ ) = 0.

Propose the following sliding surfaces

                                           S j = e j − χ (t ) ;       j : φ1 , θ1 , ψ1              (3.119)

Thus, using (3.119) for j : φ1 and (3.114), it follows that Ṡ φ1 = e φ2 − χ̇ (t ) and S̈ φ1 = f¯1 + b 1 τφ +
ζ1 − χ̈(t ). Notice that if S φ1 (0) = 0 it yields, Ṡ φ1 (0) = 0. Proposing τφ as
                                  ³       ³              ¯1/2       ¢´              ´
                        τφ = b 1−1 αφ sign Ṡ φ1 + ¯S φ1 ¯ sign S φ1 + χ̈ (t ) − f¯1 ,
                                                   ¯           ¡
                                                                                                    (3.120)


Using a same procedure that those propose for τθ , it follows that derivating (3.119) for j : θ1 , it
yields Ṡ θ1 = e θ2 − χ̇(t ) and S̈ θ1 = f¯2 + b 2 τθ + ζ2 − χ̈(t ). Thus, τθ can be proposed as
                                 ³        ³        ¯ ¯1/2      ¡ ¢´                 ´
                       τθ = b 2−1 −αθ sign Ṡ θ1 + ¯S θ1 ¯ sign S θ1 + χ̈ (t ) − f¯2 ,              (3.121)


Finally, for designing τψ we derivate (3.119) for j : ψ1 and then Ṡ ψ1 = e ψ2 − χ̇(t ) and S̈ ψ1 =
f¯3 + b 3 τψ + ζ3 − χ̈(t ). Propose
                                ³        ³              ¯1/2       ¢´              ´
                      τψ = b 3−1 −αψ sign Ṡ ψ1 + ¯S ψ1 ¯ sign S ψ1 + χ̈ (t ) − f¯3 .
                                                  ¯           ¡
                                                                                                    (3.122)


                                                                                                          71


Chapter 3. Control approaches for aerial vehicles


Notice in (3.120), (3.121) and (3.122), αk ≥ L i with k ∈ [φ, θ, ψ], i ∈ [1, 2, 3] in order to
compensate the bounded perturbations. Therefore it follows that S φ1 = Ṡ φ1 = 0, S θ1 = Ṡ θ1 = 0
and S ψ1 = Ṡ ψ1 = 0 in a finite time t ? . The finite-time stability of the system is guaranteed from
control theory in [161] for the “nested” 2-sliding control.


3.3.3 Numerical and experimental results

This section presents the numerical and experimental results in order to validate the control
strategies developed in (3.120), (3.121) and (3.122). As in the case of the last results, the vehicle
used to implement the control algorithms was an Ar.Drone Parrot 2.0 under the software Fl-
AIR which is open source and runs a Linux-based operating system, capable of implementing
a wide range of control schemes, see [160]. For obtaining the vehicle’s position, an OptiTrack
motion capture system was used while its internal Inertial Measurement Unit (IMU) measures
its orientation and angular rates.

For validating the proposed control law, let us take the following scenario: consider a flying tar-
get and quadcotper vehicle evolving in R2 at random position. The goal is that the quadcopter
converge near to the flying target, ~    ξd , in finite time. For simulation tests, a desired finite time
convergence of t̄ = 5s is proposed as an example for verifying the effectiveness of the control
algorithm. Moreover, for the experimental validation, t̄ = 5s and t̄ = 3s are proposed as desired
finite times convergence. Therefore, the vehicle must to track the desired nonlinear dynamics
trajectories x c (t ) and y c (t ) described by (3.103) and (3.106). Parameters for numerical and
practical validation are shown in Table 3.6.

The vehicle should arrives to the desired position with a fixed altitude z(0) = 1m in a finite
time t̄ that denotes the arriving time. Therefore, the following assumptions are established:



     1. The quadcotper is located in a random hover position.


     2. The flying target is static but its position and velocity are known.


     3. The vehicle movements are delimited to the horizontal plane x, y.



       Table 3.6 – Control parameters used in experimental and numerical tests for t̄ = 5s


                    Parameter      θ      φ      ψ        x, y              z
                        kp        50     100    100        0.8           1.7
                        kd        2.5     4      4         0.2           0.7
                        α          3      3      3     c = 0.0002    m = 0.432 kg



72


                                           3.3. Finite-time convergence using Sliding Mode Control


Numerical results

Take the initial conditions of the flying target as x T (0) = 1m, y T (0) = 1m, z T (0) = 1m and
for the quadcotper at x(0) = −3m, y(0) = −3m, z(0) = 1m. Figures 3.20 − 3.23 present the
performance of the quadrotor when converging in finite time to a desired position ~     ξd . Notice
from Figure 3.20 and 3.21 the well performance of the control algorithm in the z−axis. From
these figures, its is possible to observe that the desired trajectories ~
                                                                        ξc arrives at the desired
finite time t̄ = 5s, however as the dynamic of the trajectories were tuned faster than the
quadcotper position dynamics, an error in the x and y coordinates appears until it converge
to zero (t ≥ t̄ ).




                      1.1




                     1.05




                           1             (0)
                                                                                                 -5


                                                                                             0

                     0.95
                                                                                         5
                               -4   -3         -2   -1       0       1       2   3   4



    Figure 3.20 – Finite time convergence of the quadcopter to the flying target at t̄ = 5s


                       4
                       2
                       0
                      -2
                      -4
                           0        1           2        3       4       5       6   7                8


                       4
                       2
                       0
                      -2
                      -4
                           0        1           2        3       4       5       6   7                8


                    1.02


                    1.01


                       1
                           0        1           2        3       4       5       6   7                8




Figure 3.21 – Performance of the x, y, z axes of the quadrotor when converging in finite time.


                                                                                                          73


Chapter 3. Control approaches for aerial vehicles


The performance of desired attitude and the orientation of the vehicle are illustrated in Figure
3.22. Notice that from this figure the desired attitude performance has slight oscillations. This
is mainly due to the fact that the finite time convergence trajectory is composed by the sg n
function. Therefore, the desired angles (3.111) and (3.112) are affected as can be verified in
the figure. The performance of the control inputs are depicted in Figure 3.23. These signals
present the well-known effect “chattering” because the composition of their equations. It is
worth mentioning that, this kind of strategies has a large demand of energy, but at the same
time gives robustness.


                          10


                              0


                          -10


                          -20
                                  0       1       2   3   4   5   6       7       8



                          20


                          10


                              0


                          -10
                                  0       1       2   3   4   5   6       7       8




         Figure 3.22 – Tracking performance of the attitude system of the quadrotor.



                  -0.35

                   -0.4

                  -0.45
                          0           1       2       3   4   5       6       7       8


                    0.5

                      0

                   -0.5
                          0           1       2       3   4   5       6       7       8


                    0.5

                      0

                   -0.5
                          0           1       2       3   4   5       6       7       8




                              Figure 3.23 – Control inputs of the quadrotor.


74


                                    3.3. Finite-time convergence using Sliding Mode Control


Experimental results
The initial conditions for the practical validation were set as follows: the flying target is located
hovering in ~ ξT = [3, 2, 1.2]T m while the quadcopter starts from ~  ξ = [−2, −2 1.2]T m and the
desired safe distance ~             T
                         ξd = [1, 0] m. For this experiment, some control parameters were
modified such that kp θ = kp φ = 140, kd θ = kd φ = 4, kp x = kp y = 0.9 and kd x = kd y = 0.35.

In Figures 3.24 − 3.27, the performance of the vehicle and its control inputs when performing
the finite time convergence for t̄ = 5s and t̄ = 3s are depicted. Observe from Figures 3.24
and 3.25 when the quadcotper is performing for t̄ = 5s the desired trajectories ~    ξc and the
vehicle’s position converge with a good performance, with not overshoot and small altitude
error. However, for t̄ = 3s a slight overshoot appeared in the desired trajectories due the α
parameter of (3.103) and (3.106). Nevertheless, this effect does not affect the performance of
the control algorithm, as can be confirmed in Figure 3.24 (right column images). In addition,
notice from Figure 3.25 the altitude and position errors were increased.




Figure 3.24 – Performance of the x and y axes of the quadcopter. Left column of the picture
represents the experiment when t̄ = 5s and the right column for t̄ = 3s.



                                                                                                  75


Chapter 3. Control approaches for aerial vehicles




Figure 3.25 – 3D performance of the quadcopter. Left image corresponds when t̄ = 5s and
right one when t̄ = 3s.


Figure 3.25 shows the performance of the rotational dynamics of the quadcopter when tracking
a desired trajectory. Notice that the left column images are the experimental test when t̄ = 5s
and the right ones considering t̄ = 3s. Observe that the dynamics is faster when t̄ = 3s. This
due to the control parameters (for the rotational part) were re-tuned in order to converge at
the desired finite-time.


             10                                        20

              5                                        10

              0                                         0

             -5                                       -10

            -10                                       -20
                  0   1   2   3   4   5   6   7   8         0   1   2   3   4   5


             10                                       20

                                                      10
              5
                                                        0
              0
                                                      -10

             -5                                       -20
                  0   1   2   3   4   5   6   7   8         0   1   2   3   4   5



Figure 3.26 – Attitude behavior of the quadcopter when tracking a desired trajectory with
t̄ = 5s and t̄ = 3s as desired finite-time convergence.


76


                                                                             3.4. Conclusions


Figure 3.27 depicts the behavior of the control inputs. Notice that the “chattering” effect does
not appears. For these experimental tests, we approximate the sgn function as an hyperbolic
tanh function in order to avoid “chattering” effect. Therefore, the performance is softer with
respect to that one of the simulation results.

                                                    0.6
    0.5

                                                    0.5
    0.4
                                                    0.4

    0.3
                                                    0.3

    0.2                                             0.2

                                                    0.1
    0.1

                                                     0
     0
                                                   -0.1

   -0.1
                                                   -0.2

   -0.2                                            -0.3
          0   1   2   3   4     5    6    7    8          0   1       2       3       4       5




Figure 3.27 – Performance of the control inputs when considering t̄ = 5s and t̄ = 3s as desired
finite-time convergence



3.4 Conclusions
In this chapter, some control techniques based on Euler angles and quaternion formalism
were addressed: a brief overview evaluation of popular control algorithms (linear and non-
linear backstepping, nonlinear saturation control and the virtual fully actuated technique), a
quaternion-based nonlinear backstepping controller and a Sliding Mode Control for finite-
time convergence.

The goal of this chapter was to provide a unified and accessible analysis, placing popular con-
trol algorithms, quaternion-based controllers and with finite time convergence, into a proper
context. Simulation and experimental results reveals that using the virtual fully actuated tech-
nique, over classical approaches, results in a smoother convergence to the desired reference
and a smaller control effort demand. Nevertheless, when agile/aggressive movements or
finite time convergence are required, quaternion-based algorithms and sliding mode-based
controllers can quickly satisfy these demands, in comparison with classic controllers. After
analysis, we consider that the choice between the controllers will depend on the problem
requirements and the computational capacity of the embedded system.




                                                                                             77




Chapter 4 Part IV




                    79




4 Autonomous navigation algorithms


 Most of the works currently found in literature about micro aerial vehicles, especially quadro-
 tors, have received plenty of attention of the scientific community. Studies focus on control
 [162, 163, 164], state estimation [165], and planning [166, 28], have been conducted respec-
 tively, and many significant progresses have been achieved. Because of the strong needs in real
 applications, autonomous flight of quadrotors, which requires to address the perception, plan-
 ning and control problem simultaneously, has been investigated and still continuously studied
 to improve its performance. Due to the noteworthy properties, particularly the structural
 simplicity, rapid maneuverability, the stable hovering capability, and low cost, a quadrotor is
 an ideal platform for navigating in confined and hazardous environments such as exploration
 [167], inspection [168], and search and rescue [169].

 Going beyond these motivations and taking advantage of controllers detailed in the previous
 sections, this chapter presents three different alternatives for the autonomous control of
 quadrotor vehicles: a robust trajectory generation and tracking algorithm, a scheme for the
 aerial surveillance of Autonomous Ground Vehicles (AGVs) using a quadcotper vehicle and, a
 virtual control architecture for controlling robots remotely using a virtual reality environment.

 This chapter is organized as follows: first, a path planning algorithm based on model predictive
 control with a bounded strategy is addressed in section 4.1. Experimental tests are carried-
 out in order to validate the proposed scheme. In section 4.2, a vision algorithm for target
 localization is presented. The goal in this section is to present the surveillance application
 between a quadrotor and a ground vehicle. Experimental tests are carried out to demonstrate
 the good performance of the control algorithm. Finally, a semi-autonomous navigation
 architecture using an immersive virtual environment is presented in section 4.3. Here, the
 propose is to reduce the stress in novice pilots when controlling a quadrotor vehicle. Two
 different scenario for the experimental tests are presented to confirm the good performance
 of the proposed architecture.




                                                                                               81


Chapter 4. Autonomous navigation algorithms


4.1 Path planning algorithm using MPC
In this section the path planning algorithm based on model predictive control (MPC) for the
quadcopter system is discussed. For path generation and tracking, it is assumed that system
(2.11) describing the dynamics of the quadcopter is at hover position with a desired altitude,
using a controller with the form (3.26). Thus, let us define the mission set as follows: the aerial
vehicle starts from an initial position, P                        ~ (t f ), where t f denotes the final
                                           ~ (0), to a final one, P
time. Solving the optimal trajectory planning problem (OTPP) involves the determination
                   ~d = [~    ˙
of the trajectory P      ξd , ~
                              ξd ]> and the corresponding control trajectory vector ∆P       ~r which
represents the input to the controlled prediction model. This vector will be the reference
trajectory for the controller developed in Chapter 3 in terms of position and velocity.

The general control diagram used in this work is depicted in Figure 4.1. Here the reference
trajectory will be generated by the Re-Planner algorithm based on MPC, the control algorithm
block includes the control laws with the form (3.26) satisfying the path tracking objective, and
the disturbance observer block (described in Chapter 5) providing robustness to the system.




                Re-Planner           Control
                    MPC             algorithm




                                                     Disturbance
                                                       observer




Figure 4.1 – Control-scheme diagram. P      ~r defines the control trajectory obtained from the
                 ~
algorithm MPC, P d denotes the desired final values. The Re-Planner based on MPC generates
the optimal feasible trajectory, and~η, ~
                                        ξ state for the vehicle’s states. ~
                                                                          u n represent the saturation
nominal controller, ~u ζ expresses a compensate parameter from a disturbance observer and ζ
possible external perturbations.

Our idea is to propose simple schemes which allows to compute the algorithms in the embed-
ded system of the vehicle, the MPC approach used in this paper is based on the predictive
control for linear systems without constraints. It can be notice from section 3.1.2 and using
(3.22) that the controller can impose, using b i , a linear behavior in the system (2.12). Thus,
without lost of generality and for simplify further analysis, system (2.12) can be analyzed as a
linear system and it can be represented as a discrete time state space of the form

                              ~
                              x (k + 1) = A(K , g )~                  ~r (k)
                                                   x (k) + B (K , I )∆P
                                                                                                 (4.1)
                                  ~        x (k)
                                  y (k) = C~

where ~                                ~r ∈ R6×1 represents the control trajectory vector, ~
       x ∈ R12×1 is the state vector, ∆P                                                   y ∈ R12×1
signifies the vector of measured outputs. A(K , g ) ∈ R12×12 , B (K , I ) ∈ R12×6 are matrices with
elements that depend on the gains defined in (3.22) and g , I were declared in (2.16).

82


                                                                  4.1. Path planning algorithm using MPC


Trajectory generation

The model predictive control approach solves a finite-time unconstrained optimal control
problem in a receding horizon manner. Therefore, let H p be the prediction horizon, Hu the
control horizon and H w the window horizon such that the path planning problem can be
formulated as a linear optimization problem with a quadratic cost function with the form:

                                 Hp                                         Hu−1
                        ~r ) =
                   x , ∆P                                          2
                                                                                   k∆P r (k + i )k2R(i ) .
                                 X                                           X
                J (~                    kP (k + i ) − P d (k + i )kQ(i )+                                            (4.2)
                                 i =1                                       i =0
                                                                                                     
             P (k + H w|k)                        P d (k + H w|k)                            ∆P r (k|k)
    ~ (k) =         ..                 ~d (k) =          ..                 ~ (k) =            ..
                                                                             ∆P
                                                                                                     
    P                .
                            ,
                                       P                  .
                                                                   ,
                                                                                                 .
                                                                                                          ,
                                                                                                          
              P (k + H p|k)                        P d (k + H p|k)                     ∆P r (k + Hu − 1|k)

and the weighting matrices Q and R are given by
                                                                                                                    
    Q(H w)     0                    ···     0                     R(H w)     0                        ···       0
    0     Q(H w + 1)               ···     0                    0     R(H w + 1)                   ···       0
                                                                                                                    
                                                                                                                       
Q =  ..       ..                   ..      ..  ,           R =
                                                                  ..        ..                       ..        ..     .
       .        .                      .     .                   .          .                          .       .
                                                                                                                      
                                                                                                                      
      0        0                    · · · Q(H p)                    0        0                        ···    R(Hu − 1)

The tracking error ~δk = P~ −P~d , is the difference between the state vector and a time varying
reference and is penalized along with the control trajectory effort. The weighting matrices Q,
R, penalizing the tracking error, are chosen to reflect the desired balance of their respective
terms. The time reference is generated at each step by drawing a line in an Euclidean space
from P 0 to the final target. That line is discretized into N − 1 points where those points are
used in sequence as ∆P  ~r .

The state’s prediction can be formulated as follows [170]

                                 ~ (k) = Ψ~
                                 P                                 ~r (k)
                                                    ~r (k − 1) + Θ∆P
                                          x (k) + Υ∆P                                                                (4.3)

for suitable matrices Ψ, Υ and Θ. Define

                                             ~d (k) − Ψ~
                                        ~ε = P                   ~r (k − 1)
                                                       x (k) − Υ∆P                                                   (4.4)

This can be thought of as a tracking error, in the sens that it is the difference between the
future target trajectory and the free response of the system. If ε = 0, then it would indeed be
                ~r (k) = 0. Rewriting (4.2) using (4.3) and (4.4)
correct to set ∆P

                                                ~r (k)°2
                            ~r (k) −~ε(k)°2 + °∆P
                  ~r ) = °Θ∆P
             x , ∆P
                         °               °    °       °
          J (~                            Q            R                                                             (4.5)
                                         T                                                T
                                           ~r (k) −~ε(k)] + ∆P
                         ~r (k) −~ε(k)]Q[Θ∆P
                    = [Θ∆P                                            ~r (k)
                                                             ~r (k) R∆P                                              (4.6)
                                                            ~r (k)T [ΘT QΘ + R]∆P
                                       ~r (k)T ΘT Q~ε(k) + ∆P
                    =~ε(k)T Q~ε(k) − 2∆P                                        ~r (k).                              (4.7)



                                                                                                                       83


Chapter 4. Autonomous navigation algorithms


Remark that (4.7) has the form

                        J (~                   ~r (k)T G
                                ~r ) = ct e − ∆P
                           x , ∆P                           ~r (k)T H ∆P
                                                       ~ + ∆P          ~r (k).                (4.8)

where
                              ~ = 2ΘT Q~ε(k),
                              G                        H = ΘT QΘ + R.

and we can see that, neither G                                                ~ (k) we can
                               ~ nor H depend on ∆U (k). To find the optimal ∆P
now find the gradient of J (k) and set it equal to zero. From (4.8) we find

                                                          ~r (k).
                                                  ~ + 2H ∆P
                                   ∇∆P~r (k) J = −G                                           (4.9)

then the optimal set of future input moves is

                                                   1
                                                        ~
                                        ~r (k)opt = H −1G.
                                       ∆P                                                   (4.10)
                                                   2

Equation (4.10) guarantees a stationary point, but is not enough to guarantee a minimum.
In order to guarantee the minimum, the derivative of the gradient ∇∆P~r (k)J with respect to
  ~
∆P r (k) must be obtained, i.e., the Hessian of J (~    ~
                                                   x , ∆P r ):

                                   ∂2 J
                                           = 2H = 2(Θ>QΘ + R)                               (4.11)
                                   ~r (k)2
                                 ∂∆P

Assuming that Q(i ) ≥ 0, this ensures that Θ>QΘ ≥ 0. Thus, if R > 0 then the Hessian is certainly
positive-definite, which is enough to guarantee that we have a minimum.



Formulation as a Least-Squares problem
The optimal solution, as expressed in (4.10), should never be obtained by computing the
inverse of H . The matrix Θ is often ill-conditioned, which can result in H being ill-conditioned.
The best way of computing the solution is by solving it as a least-square problem. It is also a
way which gives some additional insight.

Since Q ≥ 0 and R > 0, we can find matrices SQ and S R which are their square-roots:

                                      T
                                     SQ SQ = Q,        S RT S R = R

Now consider the vector
                                                  ~r (k) −~ε(k))
                                      "                         #
                                          SQ (Θ∆P
                                                                                            (4.12)
                                               S R ∆P~r (k)

We shall show that the squared length of this vector, or equivalently, the sum of squares of its
elements, is the same as the cost function J (~    ~r ), so that ∆P
                                              x , ∆P                                         ~r (k)
                                                                  ~r (k)opt is the value of ∆P
which minimizes this length.




84


                                                            4.1. Path planning algorithm using MPC


Therefore, it yields
                       ¢#°2                              #°2
          ~r (k) −~ε(k) °           ° Q ~ (k) − P ~d (k)) °
  °" ¡                              °"
  ° S Θ∆P                           ° S (P
  ° Q
                         ° =                                                                     (4.13)
                         °                                °
            ~
       S R ∆P r (k)                           ~
                                         S R ∆P r (k)
  °                                 °                     °
  °                      °          °                     °
                                 ~ −P
                              = [P    ~d (k)T ]S T SQ [P
                                                       ~ (k) − P          ~r (k)T S T S R ∆P
                                                               ~d (k)] + ∆P                ~r (k) (4.14)
                                                Q                                   R
                                          ~d (k)°2 + °∆P
                                  ~ (k) − P               ~r (k)°2
                                °                °     °         °
                              = °P                Q               R                               (4.15)
                                        ~r )
                                   x , ∆P
                              = J (~                                                             (4.16)

           ~r (k)opt is the least-squares solution of the equation
Therefore ∆P

                                                           ~
                                                 ~r (k) − ε(k))
                                     "                         #
                                         SQ (Θ∆P
                                                                 =0                              (4.17)
                                              S R ∆P~r (k)

or, equivalently, of:                "    #           "        #
                                      SQ Θ             SQ~ε(k)
                                             ~r (k) =
                                            ∆P                                                   (4.18)
                                       SR                 0

We can see equation (4.18) has the form AΘ = b and can be solved in a least-square sense
using the QR algorithm. Although formally this solution is the same as θopt = (A T A)−1 A T b,
which gives the equation (4.10).

Furthermore, in accordance with the receding horizon strategy, we only use the part of the
solution corresponding to the first step. Thus, from (4.10) it is possible to observe that the only
part of this solution which changes from step to step is the tracking error ε(k). Consequently,
the predictive controller for the unconstrained problem and with full state measurement is
defined by
                                  P r = [I l , 0l , · · · , 0l ] H −1 Θ>Q                    (4.19)

We point out that the correct way of computing (4.19) is
                                                              "    # "        #
                                                               SQ Θ    SQ~ε(k)
                               P r = [I l , 0l , · · · , 0l ]       \                            (4.20)
                                                                SR        0

This essentially works for the following reason: if we had ~ε(k) = [1, 0, · · · , 0]> then it would
effectively have only the first column of SQ on the right side of (4.10). ~ε(k) = [0, 1, 0, · · · , 0]
would effectively give the second column, etc. Since~ε enters the solution linearly, it is only
necessary to solve (4.10) with these columns on the right hand side. This is very efficient,
since most of the work involved is computing the QR decomposition of the left hand side. In
this work, the householder QR decomposition algorithm is used to solve the unconstrained
problem (4.20).

The steps to solve the cost function (4.2) are presented in algorithm 1. In this thesis, the explicit
solution for generating the optimal trajectory using the x, y, z position as the control trajectory
input is addressed.


                                                                                                     85


Chapter 4. Autonomous navigation algorithms


Algorithm 1 General statement of the MPC algorithm
  initialize MPC-LS with nominal a control trajectory ∆P ~r
  ~
  P (0) ← starting position
  ~d (t f ) ← desired position
  P
  Generate the linear controlled model (4.1)
  While (P  ~<P ~d )
     -Create the augmented MPC model of (4.1)
     -Minimize the cost function (4.2) by solving the LS
     sense using the ‘QR’ algorithm
     -Apply the control trajectories
     -Update P ~
     -Update ∆P  ~r
  end


4.1.1 Experimental results

In this section, a helical trajectory with wind and manual disturbances was selected to vali-
date the performance of the presented path planning algorithm. The experimental test was
developed using the quadtotor vehicle AR Drone 2 using the open source software Fl-AIR and
an OptiTrack motion capture system.

The set up of the experiment is as follows: the quadrotor takes off and follows a hold position
~
ξ0 = (1.5, 0, 0.5) m. Then the desired final trajectory is generated by means of the algorithm1.
It is mandatory when the vehicle is navigating through the reference trajectory, to compute
the optimal trajectory at each step by means of the MPC. Moreover, a first fan was turned on
once the reference trajectory started. After that, manual disturbances were applied at different
times during the mission. The parameters used for this test can be found in Table 4.1. A video
of the experimental results can be watched at: https://youtu.be/3G7UVYWsyBs.

                            Table 4.1 – Experimental parameters

                              τi :φ,θ                      MPC
                              k pi :x,y = 0.23    xi = 0    xf = 0
                              k d i :x,y = 0.13   y i = −3  y f = −2
                              σi :x,y = 0.1       Q = 0.1   R = 0.0002
                              σi :ẋ, ẏ = 0.2    H p = 10 Hu = 3
                              k pi :φ,θ = 0.5
                              k d i :φ,θ = 0.1
                              σi :φ,θ = 0.1
                              σi :φ̇,θ̇ = 0.3




86


                                                      4.1. Path planning algorithm using MPC




Figure 4.2 – Evolution of the path tracking in x, y, z−axis with wind and manual disturbances.
Figures 4.2 − 4.4 depict the trajectory generation and the quadrotor performance when
following the desired trajectory subject to wind and manual disturbances. The wind effect is
applied at t = 19s, t = 48s andt = 57s but not necessarily constant due the vehicle is following
a 3D reference trajectory. This can be observed properly in Figure 4.2. Remark that at t = 23s
and t = 34s approximately, a manual disturbance was applied while the vehicle is ascending.
This performance can be seen in Figure 4.3. In this graph, it is roughly depicted when the
wind (two times) and manual (two times) perturbation were applied. These effects were
compensated in a robust manner by the compensation of the disturbance observer developed
in section 5.



                       3


                      2.5


                       2


                      1.5


                       1


                      0.5


                       0
                       2                                              -2
                             1                                   -1
                                  0                         0
                                       -1              1
                                             -2   2



Figure 4.3 – Flight test when the quadcopter follows the helical trajectory in ascending phase
in presence of wind and manual disturbances.


                                                                                             87


Chapter 4. Autonomous navigation algorithms


Figures 4.4 illustrates the descending behavior of the vehicle. This performance can be sees
in the z−axis around t = 36s. Although the gravity force actuates in the drone, and manual
perturbation is applied, the MPC solves the shortest path forcing the control law to avoid
oscillations in the altitude position when the vehicle is descending.



                        2.5


                         2


                        1.5


                         1


                        0.5


                          0
                         -2

                              -1

                                   0                                    -2
                                                                 -1
                                       1                  0
                                                   1
                                           2   2



Figure 4.4 – Flight test when the quadcopter follows the helical trajectory in descending phase
in presence of wind and manual disturbances.


4.2 Vision algorithm for target localization: a case study for
    autonomous vehicles surveillance
Aerial visual tracking is a major hurdle to tackle for feasible prototyping of an autonomous
ground vehicle (AGV). These vehicles are subject to non-holonomic constraints since rear
wheels are fixed preventing to produce lateral velocity in any direction. However, when we
drive such a car, we pick visual landmarks ahead (for instance, as showed in Fig. 4.5, a corner
at the end of the block) in the visual field to plan how to command the steering wheel to
intersect ahead such landmark. The result is smooth car trajectories pointing ahead with small
admissible turning ratio of the steering wheel angle. These trajectories can be modeled as
vector fields pointing to a landmark (known as the contour), for instance, when we need to
turn in the next corner of the block, we solve what the steering wheel angle is, based on the
corner ahead of us, as if we were drawing smooth vector fields.

Then, if we neglect that, such driving motion corresponds to an autonomous car that mimics
human driving, drawing smooth vector fields. The problem of aerial surveillance becomes the
aerial tracking of the car center of mass (x, y) and yaw ψ angle that matches the heading direc-
tion of the car, at a given altitude z. However, such aerial tracking of (x, y, z, ψ) requires solving
the vector field and underactuated visual tracking. Therefore, we aim exploiting structural
properties of the car, such as non holonomy, and the vector field control to mimic driving, and
consider underactuation of the quadrotor, to establish a tractable problem statement.

88


                               4.2. Vision algorithm for target localization: a case study for
                                                          autonomous vehicles surveillance




Figure 4.5 – Proof of concept of the problem: The driver commands the vehicle in urban set,
picking up the next contour A, then B, then C to plan smoothly ahead, as if navigating in
smooth vector fields; then, facilitating tracking with airborne monocular camera, since height
can be regulated efficiently, and assuming target remains in the FoV.


To this end, we assume that the car evolves in the (x, y) plane subject to non-holonomic
constraints while tracking smooth vector fields designed using contour ahead of the road
in ψ direction, thus such vector fields provide the desired admissible trajectories to the car,
and an underactuated quadrotor equipped with airborne monocular camera is considered
to track the car at a given desired altitude z d , see Figure 4.6. Thus, let us consider that the
visual tracking of the mobile robot smoothly draws a vector field converging to a contour. This
contour relies in the field of view of the airborne camera mounted on an underactuated drone.
Then, the following assumptions are required:


   1. The AGV mimics motion of a car driven by a human, implying that its CoM draws a
      smooth vector field toward the contour ahead;

   2. The AGV’s path curvature is finite, implying bounded yaw angle that complies with the
      non-holonomic constraint and a bounded steer wheel angle.

   3. Quadcopter has underactuation in (x, y) coordinates, however the controlled Degrees
      of Freedom (DoF) are yaw ψ angle, altitude z, as well as (x, y) motions, where the latter
      are controlled indirectly using roll and pitch angles.

   4. Monocular camera is along the optical axis collinear to z in body coordinates, where the
      mobile robot lies in its FoV. Since the quadcotper altitude can be controlled quickly and
      independently, 2D visual servoing suffices to capture AGV’s CoM.

   5. For experiments, we consider the 6 DoF of Parrot AR.Drone with monocular camera and
      airborne processing only, [171], to track in the image plane a differential driven mobile
      robot.

                                                                                              89


Chapter 4. Autonomous navigation algorithms


     6. Moreover, the hardware, software and firmware of airborne sensors have limitations,
        including monocular camera, noisy, delayed and quantized measurements yielding
        approximation of the required virtual camera transformations; then, we assume that
        the fast quadcopter actuation and smoothness of trajectories produce small angles in
        roll and pitch, then the diffeomorphism of the virtual camera projection is almost an
        identity. This assumption is substantiated since the proposed quadrotor controls ensure
        asymptotic convergence to the vicinity of stability along very smooth trajectories.




Figure 4.6 – Experimental test-bed showing the AR Drone 2.0 as the quadrotor, and the Jumping
Sumo as the mobile robot (with a chess board on top for image processing).

The trajectories of the non-holonomic differential wheeled mobile robot, under Velocity Field
Control in inertial frame, are captured by the monocular camera as an image-based field in
aerial body frame. Such image is processed on board, without relying data to ground station, to
produce the desired image-based trajectories for the controller of the underactuated quadrotor
dynamics. The mobile robot differential kinematics is processed under kinematic controller in
a ground station, then velocity control command are sent wireless. Trajectories are processed
with a pinhole camera to produce an image-vector field. Then, considering the full non-linear
dynamics, the quaternion-based backstepping control (3.97) is implemented to closed-loop,
under underactuation for well-posed underactuated coordinates.


Vision algorithm

A chess-pattern target was placed onto the mobile robot to process its orthogonal axis in
its frame by high density of corner, assuming a background floor without cluttered lines or
corners. The camera together with the processing unit of the AR Drone 2.0 quadrotor detects
corners with the following:


     1. Finds the 64 most confident corners of chess board with a pinhole camera image using
        the Shi-Tomasi algorithm [172].

90


                                  4.2. Vision algorithm for target localization: a case study for
                                                             autonomous vehicles surveillance


   2. Determine correlation between images using the Lukas Kanade algorithm, [173].


   3. Determine centroid based on matched chess corners, as follows

                                                     N
                                                     X
                                              pt =          p f i /N                               (4.21)
                                                     i =0

      where p t is the estimated centroid of the target, p f i is the position of each matching
      corner feature, and N is the total number of matching corners.


   4. Update matching corners, then determine the centroid (4.21).


   5. Target is detected if area, centered in the centroid with radius of 20 pixels, has at least 15
      corners.


Notice from Figure 4.7a, there is no target detected, even if a centroid is calculated with only
one corner, N f = 1. Nevertheless in Figure 4.7b, algorithm determines that the target has been
detected for N f = 22 corners.




             (a) Target is not the FoV.                                (b) Target is in the FoV.

                        Figure 4.7 – Frames when searching for the target



The estimation of the optical flow is performed on a dedicated DSP to reduce the computa-
tional cost to the main control board, whose processing time takes between 15 and 20 ms.

After computation, a Kalman filter was implemented for improving the robustness of process-
ing. To determine the direction of centroid, see Fig. 4.8, let the vector be
                                                  "      #
                                                  uc
                                             ~t =
                                             p                                                     (4.22)
                                                  vc

which can be used, together with its image approximation of velocity, [u̇ c , v̇ c ]T , for control
purposes, by considering that image axes are parallel to x and y axes of body fixed frame.

                                                                                                      91


Chapter 4. Autonomous navigation algorithms




         Figure 4.8 – Image position of the mobile robot frame and the camera frame.



The autonomous vehicle as a mobile differential robot

Consider a 2D terrestrial differential wheeled robot steered by the difference of angular wheel
velocity connected along a perpendicular axis to longitudinal motion, see Figure 4.9. The state
equation is as follows
                                           ~˙ s = A~
                                           X       ω,                                     (4.23)

where X ~ s = [x s , y s , θs ]T ∈ R3 is the robot pose, for (x s , y s ) representing position its CoM, and
θs its orientation, both with respect to the inertial reference frame, and ~              ω = [ω1 , ω2 ]T , the
angular speed of the robot’s wheels.




     Figure 4.9 – Kinematic of a differential robot as an abstract representation of an AGV.




The flow matrix is given by
                                               r1          r2
                                               2 cos θs    2 cos θs
                                                                      
                                               r1          r2
                                                2 sin θs    2 sin θs
                                      A=                              ,                               (4.24)
                                                                      

                                                  − rL1        r2
                                                               L

which maps generalized angular velocities ~                            ~˙ s , with r 1 = r 2 the radius
                                             ω to operational velocity X
of the left and right wheels, respectively, and L the length to the center of each wheel.

92


                                  4.2. Vision algorithm for target localization: a case study for
                                                             autonomous vehicles surveillance


Vector fields as desired smooth trajectories

Velocity Fields stand for Cartesian vector distributions, or fields, and describe kinematic
motion of a moving particle, i.e. the instantaneous changes in direction toward the objective,
or contour. It is useful in our case, if we consider that AGV driver commands the vehicle
to go to a target, or contour, and such driver steers the vehicle within prescribe standards,
thus producing a smooth maneuverings, that can be modeled as a vector field that converge
to the contour. Then, we assume that the driver mental map commands toward the final
destination by picking locally targets as soon as they appear in our FoV. Once the driver picks
a target ahead, for instance to turn in the next corner, we somehow compute how to turn the
AGV avoiding obstacles to pass through until converge tangentially to the contour. Once we
determine this objective is achieved, we pick next target (contour) in the next block. Thus, this
abstraction stands for how we plan next trajectory based on local contour in our FoV. Similar
to this phenomena, we assume that the AGV produces such vector field, then the surveillance
problem is to produce a visual servoing to maintain the AGV within its FoV.

To this end, consider a parametric curve, G(s), where s stands for arc length, or contour ahead
in the FoV. The problem is to determine the R2 directional components (N              ~ (s)) of the field
                                                                             ~ n (s), T
as a radial attraction to the curve s, or contour, where N              ~ (s) stand for the Normal
                                                            ~ n (s) and T
                                                                  2
and Tangential components, respectively, of the field in R , whose resultant points at the
target correspond to G(s) = 0. There are several methods in the literature to produce such
          ~ (s)) that smoothly converge to G(s) = 0, the arc to turn in the corner asymptotically
 ~ n (s), T
(N
with uniform speed, as we usually compute when we drive our cars through urban settings.
The method developed considers to pick the objective path, or contour, as a parametric curve
to compute from position data of such contour, the velocity vector that intersects ahead such
contour G(s) = 0, see Figure 4.10.




Figure 4.10 – Three steps Velocity Fields design method based on differential geometry proper-
ties of the desired trajectory:(a) parametric curve of motion objective, (b) main directional
components of the field, (c) calculation of the velocity vectors.


Thus, consider ~   v : R2 → R2 the velocity vector that depends on the position of a given point
~        ~ n (s) = −R
r , with N                         ~n (s) is a radial unit vector) and T
                     ~n (s) (where R                                   ~ (s), components gradually
transitioning from a given position CoM to an attractive curve G(s) = 0 standing for the turning
in the corner. Such transition uses a variable coefficients as a function of the distance to the
curve. Then, consider

                             ~                                             ~n (s))
                                                    ~ (s) + µ f ar (d r )(−R
                             v (r ) = µcl ose (d r )T                                             (4.25)

                                                                                                     93


Chapter 4. Autonomous navigation algorithms


where µcl ose (d r ) and µ f ar (d r ) are the variable coefficients depending on the distance d r to the
curve G(s) = 0. To keep a uniform speed motion along the attractive trajectories, ||~         v (r )|| = 1,
consider that the coefficient of the weighted sum are defined using sinusoidal functions,

                                  µcl ose (d r ) = cos(c 1 d r ); µ f ar (d r ) = sin(c 1 d r )              (4.26)

where c 1 is a normalizing constant such that c 1 d r ∈ [0, π2 ]. Recalling the arc length s along G(s)
is determined by ~ r at its closest point, ~
                                           v becomes

                                    ~                                             ~n (r ))
                                                          ~ (r ) + sin(c 1 d r )(−R
                                    v (r ) = cos(c 1 d r )T                                                  (4.27)

thus ~ v (r ) is a gradual uniform speed transition from the attractive to the guiding direction
as the position gets closer to the curve, and represents the reference of the desired velocities,
h           iT
  ẋ d ẏ d , for the differential robot.

Without loss of generality, aiming at illustrating our proposal, let the desired trajectory of the
mobile robot, be a 2D circumference. This simplifies the velocity field design because the
radial and the tangential vectors to the curve can be calculated with respect to the center of
the circumference, r c = (x c , y c ) and its radius, ρ, then

                                                                             (y − y c , −(x s − x c ))
                                     q
                   ~ (x, y) = − sgn( (x s − x c )2 + (y s − y c )2 − ρ) · p s
                   T                                                                                     ,
                                                                            (x s − x c )2 + (yG − y c )2
                                                                               (x s − x c , y s − y c )
                                     q
                  ~
                  R n (x, y) = − sgn( (x s − x c )2 + (y s − y c )2 − ρ) · p                             ,
                                                                            (x s − x c )2 + (yG − y c )2

such that the velocity field becomes

                                    ~                                             ~ ))
                                                          ~ (r ) + sin(c 1 d r )(−R(r
                                    v (r ) = cos(c 1 d r )T                                                  (4.28)

             π
with c 1 =   2r   .


Integration of the overall scheme

The image-based control law is based on the position control (3.80)
                                                                     α        
                                               −(u˙c + u c ) − u˙c − α21x u c
                                                                         x
                                                                      α
                                          ~ =  −(v˙c + v c ) − v˙c − α1 y v c 
                                                                              
                                          U                            2y                                  (4.29)
                                                                α
                                                −e z2 − z 2 − α12z e z1 + g
                                                                       z

        h       iT       h        iT
where u c v c , and u̇ c v̇ c , are respectively image coordinates of the target’s centroid,
and their rate of change. α1i , α2i are positive constants and e z2 and e z1 are the position and
velocity errors of the altitude system, defined in section 3.2 and it is controlled independently,
thus it can be considered that visual projection occurs in 2D, at a given altitude z = z d .



94


                                   4.2. Vision algorithm for target localization: a case study for
                                                              autonomous vehicles surveillance


Then, the well-posed desired quaternion, q d , is computed from (3.97) using the normalized
vector of (4.29) and AGV’s yaw angle, which represents such mapping.

To design the kinematic control of the AGV, forward kinematics yields the following map
                              "                    #             "                           #
                                  x s + l cos θs          ˙=           ẋ s − l θ̇s sin θs
                         ~
                         Ξ=                            =⇒ ~
                                                          Ξ                                        (4.30)
                                  y s + l sin θs                       ẏ s + l θ̇s cos θs

By using the non-holonomic constraint, the change of coordinates ẋ s = ũ 1 cos θs , ẏ s = ũ 1 sin θs ,
θ̇s = ũ 2 , allows the differential kinematic map to be written as follows,
                                          "                                #"          #
                                  ˙ =         cos θs    −l sin θs               ũ 1
                                  ~
                                  Ξ
                                              sin θs    l cos θs                ũ 2
                                        uGV
                                     = B~                                                          (4.31)


Since B is a positive definite matrix, consider the kinematic control as follows
                                                            "          #
                                                                ẋ d
                                              uGV = γB −1
                                              ~                                                    (4.32)
                                                                ẏ d

                                                  h        iT
where γ > 0 is used to scale the desired velocity ẋ d ẏ d of the field. Then, substituting
                                           iT
                          ˙ )=γ
                                h
(4.32) into (4.31) yields ~
                          Ξ(t     ẋ d ẏ d , which ensures that (4.32) computes the desired
angular wheel velocity based on the given velocity field components. Notice that γ becomes
an extra degree of freedom needed in practice to adjust engineering units and for calibration
purposes, otherwise it can be set γ = 1.


4.2.1 Experimental tests

To demonstrate the effectiveness of the proposed method two experimental tests are discussed
in this section. The ground vehicle used is a Jumping Sumo, and the quadrotor is the AR Drone
2.0 with monocular camera pointing downwards, both from the Parrot company. A custom-
made programming platform is configured to command both robots based on personal
computers, giving rise to a platform called Fl-AIR, which decodes communication protocols of
peripheral devices by using a custom made software, including the closed-loop control [160].

The AR Drone 2.0 uses a board with an ARM Cortex A8 1GHz processor with 1GB of RAM,
running the controller programmed in C++, for a IMU update at 5 ms, to handle all system
processes, including control outputs, interruptions, data fusion and communication to ground
station. The mobile sumo robot’s Wi-Fi node enables control command in velocity mode
using a Broadcom BCM43526 transceiver, but for higher range, a pair of Skyworks SKY85803
Wi-Fi front-ends is used. It has an MPU-6050 invenSense 6-Axis gyroscope and accelerometer.




                                                                                                      95


Chapter 4. Autonomous navigation algorithms


Two small DC gear motors drive this mobile robot up to 4.3 MPH. A MoCap system, from
Optitrack, composed of 24 cameras, is used at a rate of 100H z to provide inertial measurement
of sumo robot only. The parameters of the mobile robot tuning of feedback gains are shown in
Table 4.2.

Table 4.2 – Experimental parameters for the control law (4.29) and the ground vehicle control
(4.32).

                    α1 = 0.8              L = 0.092 m              g = 9.81       γ1 = 0.8
                    α2 = 0.1               l = 0.08 m             z d = 1.5m      γ2 = 0.3
                    m = 0.420         r 1 = r 2 = 0.055 m        m = 0.18 K g        −


Scenario 1: target detection test

In this test, arbitrary initial conditions in the longitudinal and lateral positions were considered
for both robots and a desired altitude of z d = 1.5m for the quadcopter. The goal of this test is to
demonstrate the well-performance of the vision algorithm when the ground vehicle is turning
in the z−axis and the algorithm uses the estimated velocities instead that ones coming from
the classical optical flow. Hereafter, variables with subscript “ f ” and superscript “∧” represent
the measures of the traditional optical flow data and the estimation of the states based on the
Kalman filter, respectively.
Figures 4.11 − 4.13 show the performance of the quadcotper and the vision algorithm when
tracking the ground vehicle. Remark from Figure 4.11 the x and y centroid positions are
obtained in the image plane. In addition, it can be observed that these positions are slightly
noisy when using only the traditional Lukas Kanade optical flow.



                        50


                          0


                        -50
                              0   5   10   15   20   25     30    35   40   45   50   55



                       100


                          0


                       -100
                              0   5   10   15   20   25     30    35   40   45   50   55


                        1.8

                        1.6

                        1.4

                        1.2
                              0   5   10   15   20   25     30    35   40   45   50   55



Figure 4.11 – Positions x and y of the centroid using the optical flow data and the kalman filter.
The z position is measured using the Optitrack camera system.


96


                                     4.2. Vision algorithm for target localization: a case study for
                                                                autonomous vehicles surveillance


Observe that, when using the Kalman filter the velocity measure is less noisy. This can be
confirmed in Figure 4.12. Observe in this figure that, the velocities computed from the optical
flow data are notably noisy due the fact the ground vehicle is turning on its own axis (z−axis).
However, computing the velocity using the Kalman filter gives smoothness in the measure
allowing the vehicle keeping the desired hover position, even if the ground robot is turning.
This can be verified in Figure 4.13 where the control laws are showed. From this figure, it is
possible to see that the vehicle keeps the desired hover position during the test with a slightly
movement in the roll control as a result that the ground vehicle moved while rotating.




                      500



                         0



                      -500


                             0   5    10   15   20   25   30   35   40   45   50   55



                     1000


                      500


                         0


                      -500


                     -1000
                             0   5    10   15   20   25   30   35   40   45   50   55




                   Figure 4.12 – Velocities of the target in the image plane.



                       0.1

                         0

                      -0.1
                             0        10        20        30        40        50


                       0.1

                         0

                      -0.1
                             0        10        20        30        40        50


                       0.6

                       0.4

                       0.2
                             0        10        20        30        40        50




                   Figure 4.13 – Control inputs for the quadcopter vehicle.


                                                                                                 97


Chapter 4. Autonomous navigation algorithms


Scenario 2: tracking an autonomous ground vehicle

The goal of this test is to prove the effectiveness of the proposed control algorithm when
the ground robot is moving. For that, in this scenario initial conditions of ~    ξu (0) = ~
                                                                                           ξs (0) =
[−0.2, −1]T m were considered for both robots, and a desired altitude of z d = 1.5m for the
quadrotor. Then, three circumferences are defined as the smooth contour of radius r c1 = 1m,
r c2 = 1.5m and r c3 = 2m, starting from an arbitrary initial condition in the plane. While the
sumo starts its motion, the drone vision algorithm detects the target (the centroid of the visual
landmarks placed over the mobile robot). Then, the velocity field algorithm computes online
the kinematic controller to provide its smooth velocity field components depending of the
instantaneous position with respect to the contour, see Fig. 4.14. Figure 4.15 illustrates the per-
formance of the vision algorithm when following the smooth velocities imposed by the ground
vehicle. Remark from these figures when the radius of circumference was changed. The video
of the experimental test can be seen in https://www.youtube.com/watch?v=zB6dsH3zVg0 .


                        -0.5



                             0



                        0.5
                                 0        10    20   30    40             50        60        70



                        0.5



                             0



                        -0.5
                                 0        10    20   30    40             50        60        70



            Figure 4.14 – Desired velocity field components of the ground robot.


                       200                                400

                       100                                200

                         0                                   0

                      -100                                -200

                      -200                                -400
                             0       10    30   50   70          0   10        30        50        70



                       100                                400

                                                          200
                         0
                                                             0
                      -100
                                                          -200

                      -200                                -400
                             0       10    30   50   70          0   10        30        50        70



                                                     ~t and its estimated velocity.
              Figure 4.15 – Position of the centroid p


98


                                         4.2. Vision algorithm for target localization: a case study for
                                                                    autonomous vehicles surveillance


Figures 4.16 and 4.17 show the resultant path of the quadcotper immersed into a visual
velocity field that converges to the ideal 2D mobile robot’s velocity field. The positions of
the quadcopter and the ground autonomous vehicle are represented by x u , y u and x s , y s ,
respectively. These figures also show the relative position of quadcotper and the mobile
robot. Remark from these figures that the error in both axes is relatively small allowing the
quadcotper keeps the ground robot on the FoV. It is worth to mention that in order to get the
well performance of the vision algorithm showed in Figure 4.15, the desired altitude was set
constant at z d = 1.2m. Furthermore, the shortest distance where the quadcopter can continue
detecting the AGV was z = 0.8m. Nevertheless at this distance the ground vehicle can come out
quickly from the FoV. Contrary, the highest altitude was z = 1.5m. This helps to maintain the
AGV in the FoV. However, more features are needed for computing the centroid and therefore
more computational burden is required. In addition, remember the optical flow camera of the
Ar.Drone 2.0 and its embedded system have computational limits.


                       2

                       0

                       -2
                            0            10          20       30       40     50         60       70


                       2

                       0

                       -2
                            0            10          20       30       40     50         60       70



                      0.2
                        0
                     -0.2
                     -0.4
                            0            10          20       30       40     50         60       70



        Figure 4.16 – Cartesian position trajectories and errors of the mobile robots.


                                2

                        1.5

                                1

                        0.5

                                0

                        -0.5

                            -1

                        -1.5

                            -2

                                    -2        -1.5    -1   -0.5    0    0.5   1    1.5        2



Figure 4.17 – Performance of both robots in the x y plane. These signals are provided by the
Optitrack system.


                                                                                                       99


Chapter 4. Autonomous navigation algorithms


The mobile ground robot control signals and that of the quadcopter are shown in Figure
4.18. Notice the virtual control input of the ground robot vehicle are depicted in Figure 4.18a,
according to the change of coordinates developed in (4.31). Figure 4.18b illustrates the virtual
control input U~ that makes q → q d and Figure 4.18c presents the control torques that take
q e → 0.

                                         20




                                         15




                                         10
                                               0    10    20     30        40          50   60   70



                                         20

                                         10

                                           0

                                         -10

                                         -20
                                               0    10    20     30        40          50   60   70




                                   (a) Virtual control signals ~
                                                               uGV of the ground vehicle.

   0.05                                                                         0.2

        0                                                                         0

   -0.05                                                                        -0.2
             0        10     20     30         40    50    60         70               0    10    20     30     40     50     60       70


      0.1                                                                       0.2

        0                                                                         0

      -0.1                                                                      -0.2
             0        10     20     30         40    50    60         70               0    10    20     30     40     50     60       70


   0.45                                                                         0.2

      0.4                                                                         0

   0.35                                                                         -0.2
             0        10     20     30         40    50    60         70               0    10    20     30     40     50     60       70




                 (b) Virtual control signals U x , U y and U z                              (c) Control torques ~
                                                                                                                τ = [τφ , τθ , τψ ]T
                             of the quadcotper.                                                     of the quadcotper.

                           Figure 4.18 – Control inputs of the flying and ground vehicles.

Assuming the AGV mimics the driving style of a human driver, who tracks in practice trajecto-
ries modeled by vector fields to obtain a smooth drive ride, the quadcotper tracks the CoM and
heading angle of the AGV, thus fulfilling the mission of camera surveillance. Clearly, we are
assuming the CoM of mobile robot remains in the FoV of the airborne camera, then desired
contour, resultant velocity field and quadcotper tuning require to comply with it. Therefore,
the smoothness of the fields facilitates to match with this assumption. Furthermore, despite
that theoretically it is proved that the quadrotor tracks asymptotically the vector field of the
AGV in the image plane, care must be exercised when solving the underactuation algorithm
since this scheme may introduce large acceleration.

100


       4.3. Semi-autonomous navigation using an immersive virtual reality environment


4.3 Semi-autonomous navigation using an immersive virtual real-
    ity environment
Piloting a drone can sometimes be a difficult task because its unstable and fast dynamics
allow it to get out of balance quickly with any external disturbance. Unlike a car that moves
in a plane, aerial robots move in a 3-dimensional space. Besides, controlling a drone is
not an intuitive task for novice pilots when they lose their spatial orientation. The clearest
example is when the heading of the drone is directed towards the pilot while the joystick
command is in the opposite direction. This task of flying the quadrotor in direct view demands
several cognitive overload in general for beginners, and in most cases the quadrotor ends up
crashing during early flight experiments. Even if technological advances have improved them
significantly by implementing inner controls for flying easily these types of vehicles, when
the vehicle leaves the operator’s line-of-sight, this mental overload increases until the pilot
loses the control of the robot, see Fig 4.19. The goal of this work presented in this section is to




Figure 4.19 – Left: stress when piloting a drone. Right: frustration after crashing the vehicle [1].


reduce the cognitive overload when a beginner pilot drives a quadcopter vehicle by means of a
virtual control scheme. The proposed architecture is located in two arenas; one for the robot’s
testing room, where the real robots are evolving and the second one named CAVE - Cave
Automated Virtual Environment, where the virtual environment is placed. In this area, a World
In Miniature (WIM) is modeled representing the real environment where the robot is acting. A
new interaction metaphor DrEAM (Drone Exocentric Advanced Metaphor) is conceived for
the virtual control scheme which represents in the virtual environment (VE) the real drone.
Therefore, the goal of the architecture is to reduce the stress and help the user when piloting
remotely a real robot from a virtual environment, in our case an aerial vehicle. This aim is
conceived by an adaptive visual/sound feedback in the virtual environment, that can be used
for improving the task.

4.3.1 Virtual control scheme

The proposed virtual control scheme can be seen as a structure composed by two blocks as
depicted in Figure 4.20; the first one corresponds to the virtual environment that emulates the
real scenario. The real world where the aerial robots are evolving and the CAVE platform com-
municate together via User Datagram Protocol (UDP) with their respective routers connected
in the same network.

                                                                                                101


Chapter 4. Autonomous navigation algorithms


Both platforms have their own VRPN (Virtual-Reality Peripheral Network) server for recovering
the attitude and position of the real and virtual robot respectively. Each block is represented by
their corresponding frames that in most cases are different. The following subsections explain
these blocks and its components.

                                                                  DrEAM
                   Flight arena




                                                                             Leader
                                                                             Object
                                                         UDP


                                                                   Manager




                                                                             Phantom
                         Fl- Air
                         Framework Libre AIR                                  Object




                                               Figure 4.20 – Virtual control scheme



Real world environment

The real world environment (RWE) is where the robot is evolving. It can be seen as the scenario
of the mission, for example; building inspection or rescue missions. This scenario will be
represented as a WIM where the virtual drone will be piloted. On this document, the robot
used for experimental purposes is the quadcopter vehicle and the RWE is the flight arena.

Flight arena
The flight arena is composed by an OptiTrack motion capture system (24 cameras, 1mm of
precision) used to estimate the vehicle’s position at 100Hz, and a monitoring room, separated
from the test area for security reasons, where the ground station is placed. The size of the
flight arena is determined by 10m × 12m × 6m, see Figure 4.21a.

Quadcopter vehicle
The quadcopter prototype used in the flight tests, is a Parrot AR Drone 2. Its firmware was
modified to work under our software Fl-AIR which is open source and runs a Linux-based
operating system, capable of implementing a wide range of control schemes, see [160]. The
prototype has an internal Inertial Measurement Unit (IMU) for measuring its orientation
and angular rates. All the control algorithms are computed into the embedded system of
the aerial vehicle, and each sampling period, the drone communicates with a ground station
containing Fl-AIR framework, where their states are graphically shown for analysis purposes.
This ground station communicates with the OptiTrack’s software for collecting the position
of the drone in order to send it via wifi as well among other values (desired references, gains,
setup configuration, etc) as depicted in Figure 4.21b.


102


       4.3. Semi-autonomous navigation using an immersive virtual reality environment




                                                                Fl-Air
                                                                Framework Libre AIR




       (a) Flight arena and monitoring room.                         (b) Fl-AIR - Framework libre AIR.

                            Figure 4.21 – Real world environments.


Quadrotor dynamic model and quaternion control scheme

In this section, the dynamic model of the quadcopter corresponds with that one previously
seen in Chapter 2 section 2.3 based on the quaternion formalism. Therefore, without lost
of generality, the mathematical representation of the vehicle can be described as a virtual
complete actuated system by imposing a desired orientation with a unit quaternion, qd , that
                                                                      ~ . Therefore, if q → qd
will be related with the desired main thrust imposed by a controller, U
implies that F     ~.
              ~ξ → U

Let the desired quaternion be with the form

                                             qd = q t ⊗ q z ,                                       (4.33)

with
                                        ~ ⊗F∗
                                      ¡        ¢
                                    ln U    th              ψd
                           qt = e        2         ; q z = e 2 ; ∀ψd ∈ R                            (4.34)

where ψd denotes the desired heading. Notice that (4.33) is the desired attitude imposed by
means of the virtual environment.

Let us define the quaternion error as qe = q∗d ⊗ q, therefore, differentiating it with respect to
time, it follows that the dynamic error between the real arena and the virtual environment can
be defined as
                                   q̇ e = = ddt q d∗ ⊗ q
                                               ¡         ¢
                            1             1 ∗                  1
                              qe ⊗ ~
                                   Ωe =    q ⊗~  ΩI ⊗ q − q d∗ ⊗ ~  ΩI ⊗q                  (4.35)
                            2             2 d¡                 2     d
                                   Ωe = q ∗ ⊗ ~
                                   ~             ΩI − ~ ΩI         Ω−~
                                                               ⊗q =~   Ωd
                                                             ¢
                                                           d

where ~Ωe represents the angular rate error in the body frame, ~ΩI and ~ΩId
                                                                            are the angular
velocity and the desired angular velocity in the inertial frame and ~
                                                                    Ωd denotes the desired
angular velocity in the body frame. For validating the virtual control scheme in real-time
experiments, the attitude control algorithm proposed in (3.97) was implemented in order to
achieve the control objective q → qd .

                                                                                                         103


Chapter 4. Autonomous navigation algorithms


Note from (4.34) that the only desired value imposed in the controller is ψd , this value will be
related with the yaw angle from the virtual drone and must be mapped from the virtual envi-
ronment before being used in the controller by the real robot. Observe that when introducing
(3.97) into the rotational dynamics in (2.51) implies that these dynamics are stabilized. This
means that qe → 0 and then F         ~.
                              ~t h → U

                          ~ ∈ R3 in the following form
Therefore, let us propose U

                  ~ = m ḡ − K p (~                                  ˙           ˙
                  U             t
                                              ξv ⊗ q∗r ←v ) − K v t (~
                                  ξ − qr ←v ⊗ ~                      ξ − qr ←v ⊗ ~
                                                                                 ξv ⊗ q∗r ←v ),              (4.36)

where K p t = diag{[k p x , k p y , k p z ]} > 0 and K v t = diag{[k v x , k v y , k v z ]} > 0 are control gains. ~
                                                                                                                   ξv
describes the position of the virtual drone expressed in the virtual frame, the term qr ←v ⊗
~
ξv ⊗ q∗r ←v represents the mapping of the data from the virtual environment to the inertial
frame where the real drone is evolving. Notice from (3.97) and (4.36) that when qe → 0, implies
q → qd , and this means that u 1 → U          ~ and therefore, ~ξ →~  ξv .


DrEAM in CAVE

CAVE - Cave Automated Virtual Environment

A CAVE-like platform was used for validating DrEAM. This virtual room has a dimension of
7×3.4 m 2 and is composed of four 3D projectors Christie Mirage 1920×1200, a workstation HP
Z840 with two graphic cards Nvidia M5000, RF Active 3D Glasses, an OptiTrack motion capture
system with 10 cameras, and a PS Move motion joystick. A Unity-plugin called TransOne,
encapsulates data from VRPN into Unity Objects to simplify the data protocol between the
motion capture system and Unity, and with the framework called Translife which creates the
virtual environment.


DrEAM-Drone Exocentric Advanced Metaphor

The DrEAM is a new interaction metaphor conceived from the characteristics of the real robot
and the scenario to create virtual robots and a WIM in the virtual environment where they can
evolve. The goals of using DrEAM are, on one hand, to train inexperienced users providing
the control of the movements of the robot that he will do during the real mission. On the
other hand, to control remotely the real drone in the real scenario from a virtual environment,
reducing the cognitive overload in neophytes or novice pilots. With DrEAM, user is a spectator
of the virtual environment and can see a 3D reproduction of the world, for moving, resizing
and rotating the environment using basic commands.

DrEAM naturally offers multiple points of view and multiple scales where the user can oper-
ate, all without requiring explicit modes or commands.User observation indicates that the
operator quickly adapts to the Worlds in Miniature, and that physical props are helpful when
manipulating the WIM and other objects in the environment, see Figure 4.22.


104


        4.3. Semi-autonomous navigation using an immersive virtual reality environment




                    Figure 4.22 – DREAM’s virtual environment and flight arena

In our case, the flight area was modeled statically using blender homemade model and unity
basic shapes. Virtual robots are simple rigid bodies not affected by the law of physics that can
be selected by the user using the spherical ray-casting function provided by Translife. This
infers that their position will be the PS-Move’s position in the 3D-scene. The virtual frame of
the 3D scene has the same origin as the inertial frame in the flight area, nevertheless, they
were conceived with different rotations. Once the real scenario is represented in WIM with a
direct relationship between life-size objects, a virtual drone (VD) is placed at the same position
where the real drone is. This VD is an object of the virtual world that the user can take or leave
it by pressing/releasing a specific button on the PS-Move. While the user takes the VD, he can
rotate and translate it with simple natural gestures (moving his hand), therefore the user has
the impression that the drone is really in his hand.

In addition, user can resize and reorient the environment without changing the scene (object
positions) in any way since the program only change user position (in case of translation and
rotation) and the field of view (in case of resizing). As explained before, in DrEAM, the VD is
manipulated by the user by only pressing the "Take" button on the index of the wand. The
first step for manipulating the drone is that, the PS Move must to be placed in the hitbox of
the VD (which has the same size as the real robot). With this measure, a precise control of the
VD is guaranteed. In the second step, the user can describe a trajectory with the wand, while
the VD is already in his hand. Besides, the color of the VD changes to help the user known its
state; a).- red when it is not possible to be taken, b).- yellow when it is ready to be taken and
c).- black when has been taken already, as is depicted in Figure 4.23. In DrEAM, two different
feedbacks to help the user are conceived. The first one is a visual feedback of the position
and orientation of the real drone. For this, a ‘phantom’ drone is designed and placed with
the information of the real drone coming from the flight arena. The second one is a speed
indicator of the real drone emulated by a sound feedback in the CAVE.

Virtual representation
When the virtual drone (VD) is manipulated via the PS Move, it describes a trajectory that is a
                                                                  ˙
                                            x v (t ) = f (~
function of its position and velocity, i.e. ~             ξv (t ),~
                                                                  ξv (t ), qv (t ), ~
                                                                                    Ωv (t )) where the subindex
v refers the virtual drone. All the data are in the virtual frame V . These data information ~             x v is
periodically sent to the RWE, as desired references for the autonomous navigation of the real
drone, using the Windows asynchronous socket API in DrEAM’s platform and the Linux socket
API employing a string-based protocol in the ground station.

                                                                                                            105


Chapter 4. Autonomous navigation algorithms




                                                      (a)




                                    (b)                               (c)

Figure 4.23 – Different states of the virtual drone; (a) - cannot be taken , (b) - can be taken and
(c) - has been taken.

The VD is referred in the frame V and the real drone in several cases in the inertial frame
(or body frame) in the real world. Both frames are different and a mapping between them
(Rotation matrix) is necessary in order to use the data of each one in their respective frame.
For example, for a given point (~           ξv , qv ) of the virtual drone in the virtual frame, with ~   ξv =
£                ¤T        £                        ¤T
  x v , y v , z v and qv = q 0v , q 1v , q 2v , q 3v , its representation in the inertial frame (real scenario)
                          £        ¤T                               £                             ¤T
is for the translation z, x, y and for the orientation cos(q 2v /2), 0, 0, cos(q 2v /2) .

Observe that the pitch and roll information is not yet used in the virtual drone. Therefore, for
a good correlation between frames the following mapping is defined

                                                    1 1   1   1
                                          qr ←v =    + i + j + k.                                      (4.37)
                                                    2 2   2   2

Hence, the position of the virtual drone can be correctly represented in the inertial frame as a
desired value by
                                    ~ξd = qr ←v ⊗ ~
                                                  ξv ⊗ q∗r ←v .                           (4.38)

Similarly, for the visual feedback in the virtual environment, the attitude and position of the
real drone are expressed as

                                           ξp = qv←r ⊗ ~
                                           ~           ξ ⊗ q∗v←r
                                                                                                       (4.39)
                                           qp = qv←r ⊗ q ⊗ q∗v←r .

where ξp and qp define the position and attitude of the phantom drone in the virtual environ-
ment.

106


        4.3. Semi-autonomous navigation using an immersive virtual reality environment


The phantom drone position and orientation are updated in DrEAM every frame (100H z rate)
using the last information received from the real drone and mapping it, to the virtual frame
using the above equations.

The virtual environment can be fitted to any space, this signifies that, it can represent a
complex or simple structure, such as a building, a cube or even a sphere. Using this property, it
is then possible to impose bounds in the area where the real drone is evolving and at the same
time, keep safe the prototype. For our room test, the virtual drone will be bounded inside of a
virtual cubic scene with the following properties

                                         x b1 (t ) ≤ x v (t ) ≤ x b2 (t )
                                         y b1 (t ) ≤ y v (t ) ≤ y b2 (t )                             (4.40)
                                         z b1 (t ) ≤ z v (t ) ≤ z b2 (t )

where ξv = [x v , y v , z v ]T denotes the position of the virtual drone and x bi , y bi , z bi with i : 1, 2
are the bounds that can be functions of time or constants delimiting the testing room.


4.3.2 DrEAM’s experimental fatigue tests results

In order to test the advantages of DrEAM when controlling a real drone over a control in direct
view, an experimental study was lead with eight volunteers evaluating their performance
among six criteria: Mental demand, Physical Demand, Temporal Demand (this depicts the
stress involved by the control task), performance (this pictures the sensation of success), Effort,
Frustration (this shows the sensation of UAV’s obedience). The test consists to fly manually
the vehicle with a conventional joystick and with the DrEAM architecture, when performing a
specific task. The participants had four minutes to learn how to use the platforms and the task
must be finished in three minutes.

The scenario of the task is settled as follows: the volunteers take the control of the drone when
it is hovering around the start point (S) with a fixed altitude z t . The goal is to move the vehicle
from the point (S) to the point (C) and then to the point (A) keeping, all the time, the heading
of the vehicle pointing to a desired target as illustrate in Figure 4.24.

During the test each participant must follow the following rules


    • The altitude of the drone should be kept constant, i.e. z(t ) ≈ z t = 1m.

    • The real drone must not be put in danger in any case.

    • The task must be accomplished with accuracy as much as possible .

    • The task must be achieved as faster as possible.

    • The roll and pitch angles of both experiments were previously stabilized with an inner
      controller.

                                                                                                        107


Chapter 4. Autonomous navigation algorithms


                              Window delimitations
                                                         Target




                              A                           C                 S



Figure 4.24 – Navigation task: start point (S), checkpoint (C) and the final point (A) keeping
the heading of the vehicle pointing to the target.

After each flight test, a NASA-TLX form was filled by each participant. Figure 4.25 depicts the
results of this questionnaire. Most of the volunteers were men and without any experience
flying a quadrotor vehicle. Note from Figure 4.25 for every index when controlling the aerial
robot with a conventional joystick, for beginner pilots can result complicated to have success
even for a simple task as proposed in the test.

                     6                                               Joystick
                     5                                               DrEAM

                     4

                     3

                     2

                     1

                     0
                          Mental Demand              Phsycal Demand Temporal Demand

                      6
                                                                                Joystick
                      5
                                                                                DrEAM
                      4

                      3

                      2

                      1

                      0
                           Performance                   Effort        Frustration

Figure 4.25 – Graphics results from the NASA-TLX questionnaire. From graphs 0 means low
and 6 high demand or impact on the presented criteria.


108


       4.3. Semi-autonomous navigation using an immersive virtual reality environment


Flight data information as timestamp, attitude, position and velocities are used to compute the
mean lateral error (MLE) with respect to the desired path, the mean completion time (MCT)
of all laps (a lap is every time user finish the task from the initial point to the final one) and
the mean yaw error (MYE) with respect to the target. In Table 4.3 the results of these indexes
are presented. During the tests, 162 laps were successfully performed by the users: 81 with a
joystick (direct view) and 81 using DrEAM. Latency between CAVE and the flight arena was
around 0.06s and no jitter has been registered, which could have disturbed the flight tests.
DrEAM was sending data at 100H z as well the aerial drone.

                   Table 4.3 – Data results of MLE, MCT and MYE indexes

                                 Index   Joystick     DrEAM
                                 MLE     0.389 m      0.104 m
                                 MCT     6.810 s      5.130 s
                                 MYE     0.252 rad    0.140 rad

To corroborate the outcomes obtained with the NASA-TLX questionnaire, one sample t-Test
was carried out considering a maximum percentage of confidence (5%, α = 0.05) in the six
performance criteria. Results of this test are shown in Table 4.4, where H0 means DrEAM has
no impact on the performance criteria. Notice from this table that the p−value on almost
all the performance criteria, excepts for the ’temporal demand’ and ’frustration’, is less than
5% ( p < 0.05). Therefore, it is possible to state that DrEAM has not impact on these criteria.
Nevertheless, for the case of the ’temporal demand’ and ’frustration’, with a p−value bigger
than 0.05, it is not possible, at the moment, to state that there is not demand of this criteria.

                        Table 4.4 – Results from the one sample t-Test.

                        Hypothesis             p-value              H0
                        Mental Demand           0.013         Rejected
                        Physical Demand         0.007         Rejected
                        Temporal Demand         0.269     Not Rejected
                        Performance             0.003         Rejected
                        Effort                  0.022         Rejected
                        Frustration             0.140     Not Rejected

The fatigue conclusion in these tests was that DrEAM increases the control ergonomy for
inexperienced users when controlling the aerial robot, without loss of precision, in comparison
with controlling the robot in direct view, in particular concerning complex movements with
more than two DoF.

4.3.3 DrEAM real-time validation with robots
DrEAM performance was validated in real-time experiments when controlling remotely a real
quadrotor vehicle. The practical goal of these experiments is to corroborate and compare the
performance of the real robot versus the virtual robot in two scenarios. In the first scenario,
the inspection in reduced spaces is emulated.

                                                                                             109


Chapter 4. Autonomous navigation algorithms


For this, the goal is to navigate with the real robot inside a building crossing small surfaces as
windows. In the second scenario a cellar inspection is emulated, therefore, the objective is to
send the aerial vehicle inside of the cellar and navigate there to survey the zone. The cellar
is composed by pillars that the aerial vehicle needs to avoid. A video with the experimental
results can be seen at: https://youtu.be/jMYWIoCsj7I.
The tests are carried-out with the following procedure

   1. The take off and landing of the real robot are not still considered controlled with DrEAM.
      They are done in a safety mode by a user in the flight arena.

   2. The initial position of the real drone for the tests is ~
                                                              ξ(t 0 ) = [0, 0, 0.5]T m. At this position,
      DrEAM can take the control of the vehicle.

   3. At any moment, the user in the virtual world can always put the vehicle at hover position,
      to change/rotate/expand the view of the WIM.

   4. For simplifying the test, when the user takes the virtual drone and moves it, the real
      drone will be aligned to the direction of the trajectory. Nevertheless, the user can rotate
      it, in any desired yaw angle.

   5. No sensors for detecting obstacles are embedded into the drone. Therefore, large errors
      in the virtual commands should produce the crash of the robot with the obstacles.


Scenario 1: crossing reduced spaces for rescuing

As previously explained, in this scenario, the vehicle must cross through some reduced spaces
that can produces several stress when the user drives the aerial drone in direct view. For this
scenario, two physical windows are located in the flight arena in different altitudes, positions
and headings. These windows are also created in the WIM with the same characteristics. The
                        ξw 1 = [2, 2, 1.4]T m and the second one at ~
first one is located at ~                                           ξw 2 = [−0.5, −1.7, 1.7]T m in
the flight area. The test consists that the user must move the virtual vehicle in any desired
path while crossing the windows and repeating the experiment three times with different
translational velocities. The real robot must imitate the same performance of the virtual drone
in real time as can be seen in Figure 4.26.




                          Figure 4.26 – Scenario of the first experiment.




110


       4.3. Semi-autonomous navigation using an immersive virtual reality environment


From Figures 4.27 - 4.32, the states performance of the robots (real and virtual) when this
scenario is validated are depicted. In Figure 4.27, the translation motion in 3D is illustrated.
Moreover, observe from Figure 4.28 that the user changes the heading of the virtual robot
in order to cross the windows. This information is also presented in each axes in Figures
4.29 – 4.31. In this experiment, from 0 < t 1 ≤ 5s the real vehicle takes off autonomously to be
placed at 1.4m in z-axis. Once the vehicle switch to DrEAM’s mode, it is posed in an altitude of
0.5m. At time t = 10s the user in DrEAM takes the virtual drone and manipulates it making a
trajectory and repeating it three times at different velocities. The three laps are done at times:
10 < t 1 ≤ 40s, 40 < t 2 ≤ 60s and 60 < t 3 ≤ 80s, respectively.




Figure 4.27 – 3D performance of the virtual drone and the real vehicle when scenario 1 is
validated in real time.


                       200


                       150


                       100


                        50


                          0


                        -50


                       -100


                       -150


                       -200
                              0   10   20   30   40   50   60   70   80



              Figure 4.28 – Yaw angle behavior of the drones (real and virtual).


                                                                                             111


Chapter 4. Autonomous navigation algorithms


The first one was performed with a slower velocity because the user did not have much
confidence and he was tense. The second lap, the user increases the velocity of the trajectory
(up to 1m/s) and in the last one, the user tries to do the displacement as fast as possible. The
variations in the velocity can be checked in Figure 4.32. In figures, the subscripts d r and d v
represent the state of the real drone and the virtual drone respectively.



                      3



                      2



                      1



                      0



                      -1



                      -2



                      -3
                           0   10   20   30   40    50    60    70    80




Figure 4.29 – x-position performance of the virtual drone and the real vehicle obtained from
the first scenario. Observer the good behavior of the real drone when imitates the virtual drone
trajectory.




                       3



                       2



                       1



                       0



                      -1



                      -2



                      -3
                           0   10   20   30   40    50    60   70    80




          Figure 4.30 – Performance of the robots (virtual and drone) in the y axis.



112


       4.3. Semi-autonomous navigation using an immersive virtual reality environment



                             2

                         1.8

                         1.6

                         1.4

                         1.2

                             1

                         0.8

                         0.6

                         0.4

                         0.2

                             0
                                 0    10    20   30   40   50   60    70    80




Figure 4.31 – z-state behavior of the first scenario. Observe that the robots (virtual and real)
change their altitude for crossing the windows.




                     2

                     1

                     0

                    -1
                         0           10    20    30   40   50    60    70        80


                     2

                     1

                     0

                    -1
                         0           10    20    30   40   50    60    70        80


                     2

                     1

                     0

                    -1
                         0           10    20    30   40   50    60    70        80




Figure 4.32 – Performance of the velocities of vehicle during the first scenario. Note that it is
increased mainly in the x and y axes.




                                                                                             113


Chapter 4. Autonomous navigation algorithms


Scenario 2: Building inspection

In this scenario, two tripod are required in the flight arena emulating pillars in the cellar. In
DrEAM, two cylinders were drawn to simulate the corresponding ‘pillars’ as can be seen in
Figure 4.33. The practical goal is to illustrate the maneuverability of DrEAM when the user
manipulates the virtual drone between the emulated pillars and changing its heading. The
experiment is repeated several times with different maneuvers trying to approach the drone
as near as possible to the ‘pillars’.




                       Figure 4.33 – Scenario of the second experiment.

The performance of the states when the real drone follows the position references of the virtual
vehicle are shown in Figures 4.34 - 4.38. A 3D representation of the trajectories is presented in
Figure 4.34. As in the first scenario, the initial step was to take off the real vehicle autonomously
in safety mode. In this mode the real drone is placed at an altitude of 1.4m and a few seconds
later its altitude is reduced at 0.5m in hover position, ready to follows the virtual commands.
This is done in the interval time 0 < t 0 ≤ 20s.




Figure 4.34 – 3D behavior of the virtual and the real aerial vehicles when performing the
second scenario.


114


       4.3. Semi-autonomous navigation using an immersive virtual reality environment



                      2.5

                        2

                      1.5

                        1

                      0.5

                        0

                     -0.5

                       -1

                     -1.5

                       -2

                     -2.5
                            0     20       40        60        80       100


Figure 4.35 – Performance of the aerial robots in the x axis. Observe the good performance
when the real robot imitates the virtual robot.

                       2


                      1.5


                       1


                      0.5


                       0


                     -0.5


                      -1


                     -1.5


                      -2
                            0     20       40        60        80        100


Figure 4.36 – y- state behavior of the aerial robots (virtual and real) when the user turns the
pillars three times.

As depicted in Figure 4.34 the goal of the experiment was that the user manipulates the
virtual drone between the pillars. Three laps were carried out by the user at different times;
20 < t 1 ≤ 55s for the first one, 55 < t 2 ≤ 80s for the second lap and 80 < t 3 ≤ 100s for the last
one. This task was made in an area of −2 ≤ x ≤ 2, −1.5 ≤ y ≤ 1.5 and 0.5 ≤ z ≤ 1.4 all in meters.
Moreover, the mission demands to change the heading of the aerial robots several times as is
illustrated in Figure 4.38. From these figures, observe the good performance of the real robot
when it is controlled with the DrEAM architecture. Remark that the task has been developed
with good precision, that it should not be possible when the vehicle is controlled in direct
view.

                                                                                               115


Chapter 4. Autonomous navigation algorithms



                        2

                       1.8

                       1.6

                       1.4

                       1.2

                        1

                       0.8

                       0.6

                       0.4

                       0.2

                        0
                             0       20   40      60       80       100



Figure 4.37 – z performance of the vehicles obtained during the second scenario. Observe that
the last two laps the user change also the altitude during the trajectory.


                       200


                       150


                       100


                         50


                             0


                        -50


                       -100


                       -150


                       -200
                                 0   20   40      60      80      100



       Figure 4.38 – Behavior of the heading of the virtual and real drone respectively.



4.4 Quadcopter autonomous navigation conclusions
The aim of this chapter was to propose and introduce autonomous and semi-autonomous
navigation control techniques. They exploit properties from classical and quaternion based
algorithms providing advantageous features for navigating aerial vehicles. These navigation
techniques have been implemented for tracking optimal trajectories, ground autonomous
vehicles and virtual trajectories imposed by means of an immersive virtual reality environment.

The first navigation technique concerns the trajectory generation and tracking problems.
It is based on a simple nonlinear controller, the MPC algorithm for path generation and a
disturbance observer for giving robustness to the system.

116


                                      4.4. Quadcopter autonomous navigation conclusions


This technique was validated in a real-time flight test for a trajectory generation in a 3D−space
while dealing with external perturbations. On one hand, the optimal problem was solved
considering H p = 10 without constraints for reducing computational issues. Nevertheless,
augmenting H p for giving robustness to the prediction of the trajectory will exceed the capacity
of memory of the embedded system. This is mainly due to the fact the H p is related with
the prediction model. On the other hand, the experimental results demonstrate that the
architecture reduces considerably the error in the path tracking problem even when external
perturbations were presented.

Furthermore, a novel scheme for the aerial surveillance of AGVs using quadcopters was
proposed. The scheme uses a simple vision algorithm for the target detection and, a vector
field approach for describing the movements of a driver. Experimental results illustrate the
feasibility and good performance of the proposed scheme. However, from this experimental
validation, we can sate the following: the maximum number of features for the vision algorithm
correspond to N p = 64 and the movements described by the ground vehicle need to be smooth.
In other words, the ground robot must to remain in the FoVs of the airborne camera. Higher
number of features can cause mismatching when looking for the centroid. Moreover, fast
accelerations of the ground robot produce that it goes out of the FoV.

Finally, a new semi-autonomous virtual control architecture for controlling robots remotely
was developed in this chapter. The architecture is composed by a new metaphor interaction
called DrEAM that uses a world-in-miniature located in a virtual environment and, a real
aerial robot located in the flight arena. Two experimental tests were addressed to highlight
the easy implementation and feasibility of the proposed architecture. The testing rooms were
connected using the UDP protocol with a insignificant delay in the exchange of packages such
that, it was neglected. In addition, it was demonstrated in real-time experiments the easy
maneuverability and controllability of the real drone when the user is controlling it by means
of DrEAM. Therefore, a reduction of the cognitive overload was observed when piloting with
DrEAM than when controlling the real drone in direct view.




                                                                                            117




Chapter 5 Part V




                   119




5 Robust control scheme based on dis-
  turbance estimator

 Aerial Vehicles have gained an enormous interest for their civil potential applications. Among
 different UAVs, quadrotors are remarkably popular and have been used extensively in research
 over the past decade [174, 175]. A high-performance attitude control is a prerequisite for
 developing any other high-level control tasks [176]. For autonomous navigation, aerial vehicles
 need robust control systems to compensate the adverse effects produced by parametric and
 non-parametric uncertainties, unmeasured dynamics and atmospheric disturbances, such as
 wind and turbulence [177]. Although many solutions have been proposed in the literature,
 very few of them have been validated in real flight tests and the most popular techniques are
 still based on classical control strategies. This is mainly due to the constraints imposed by
 the limited computational resources of the embedded systems, which are typically micro-
 controllers. Also, and perhaps more importantly, because of the unstable nature of quadrotors,
 controllers must run typically at very high frequencies [10].

 Robust control for quadrotors is still an active field of research, see [178, 179, 180], because
 the aerodynamic effects are extremely hard to be accurately modeled [181] and, specially
 in outdoor applications, a UAV is constantly perturbed by wind gusts [182]. Disturbance
 observers have drawn the attention of many researchers as a tool for facing these problems
 [183, 184].

 Inspired by the works [140, 141, 185], the goal of this chapter is to present a novel robust
 control architecture for solving the practical stability for aerial autonomous vehicles subject
 to uncertainties in the model, external perturbations and rotor’s failures, while meeting the
 rotor’s physical constraints. This chapter is organized as follows: first, some preliminaries as
 well the problem formulation and the proposed solution are stated in section 5.1. Furthermore,
 a robust control architecture based on disturbance estimator is introduced in section 5.2. An
 experimental study on disturbance rejection is carried out to prove the performance of the
 proposed architecture. Then, an enhanced robust tolerant control architecture is addressed
 in section 5.3. Here, simulations and experimental tests with multiple rotors failures are
 conducted. Finally, a bounded robust control scheme is conceived and proved experimentally
 in section 5.4. Some conclusion of the developed strategies are discussed in section 5.5.


                                                                                             121


Chapter 5. Robust control scheme based on disturbance estimator


5.1 Preliminaries
Recall from (2.16), that the nonlinear dynamic model of the quadcopter using the Newton-
Euler formalism can be expressed as

                                  ˙
                                  ~                                         ~t h (t ) − m~
                                  ξ(t ) = ~
                                          v (t ),            v˙ (t ) = R(t )F
                                                            m~                           g,
                                                                                                                                (5.1)
                                                ˆ ),
                                  Ṙ(t ) = R(t )~
                                                Ω(t              ˙ = −~
                                                                J~
                                                                 Ω    Ω(t ) × J ~      τ(t )
                                                                                Ω(t ) +~

                                                                      2                                                2
In this work it is assumed that the thrust, f i ≈ k f w M               i
                                                                          , and torque, τMi ≈ k τ w M                    i
                                                                                                                           , of each
propeller are directly controlled by the angular rate of the motor, w Mi , with k f and k τ are
aerodynamic thrust and torque factors, respectively. Therefore, from (5.1), F                                ~t h and ~      τ can be
           ~t h = [0, 0,
                         P4                                                                                            P4
written as F                  f
                          i =1 i ] T
                                     and ~
                                         τ = [l ( f 1 + f 4 ) − l ( f 2 +   f 3 ), l ( f 1 + f 2 ) − l ( f 3 +  f 4 ),                T
                                                                                                                           i =1 τM i ] ,
with l representing the distance from the center of mass to the point where the force is applied.

Notice from the above, and according to (2.7), the main thrust can be defined as u 1 = 4i =1 f i ,
                                                                                            P

which acts along the direction of z−axis in the inertial frame. In addition, notice that the torque
generated by each propeller can be represented by using its thrust and a scale aerodynamic
factor denoted by c t f . Thus, the following relation can be established
                                                                                                 
                                      u 1 (t )     1                1       1         1       f 1 (t )
                                                                                                 
                                     u 2 (t )  l                                   l 
                                ~
                                                                   −l       −l              f 2 (t )
                                                                                                     
                                uR = 
                                     u (t ) =  l
                                                                                                                              (5.2)
                                      3                          l       −l       −l   f 3 (t )
                                                                                           
                                                                                                      
                                      u 4 (t )    −c t f           ct f    −c t f    ct f     f 4 (t )


Now, let’s consider that system (5.1) can be stabilized using a feedback controller with the
form
                                         u R = −K L~
                                         ~         x                                    (5.3)

where ~    x = [~ ξ, ~η]T denotes the system states, K L > 0 is a constant matrix gain and ~η˙ represents
the attitude vector of the vehicle, with ~        Ω = Wη~η˙ and Wη defines the standard kinematics
relation between ~         Ω and ~η, see [147]. The linear system of (5.1) for designing ~    u R is given
by ~ x˙ (t ) = A~           u R (t ), where A and B are the state matrix and control vector and ~
                  x (t ) + B~                                                                         uR =
                        T
[u 1 , u 2 , u 3 , u 4 ] .

Experimental tests using the (5.3) controller has shown a correct performance, nevertheless,
when the vehicle is exposed to external disturbances (as wind gust), the system becomes
unstable and some crashes occurs. These non desired effects can be also produced by actu-
ators fault (damage in the propeller or the motor itself) producing a loss in the efficiency of
the vehicle. Moreover, voltage variations in battery could be seen also as a motors Loss of
Efficiency (LoE), which is reasonable due the fact, the motor thrusts are related with the battery
voltage. In addition, when the aerial robot is exposed to these undesired situations, the con-
troller, in the embedded system, computes a large amount of energy for counteracting them.




122


                                            5.2. Robust control scheme for disturbance rejection


If this energy is sent and without measuring it, and during large periods of time, the actuators
in the aerial vehicle can be overheated and damaged, leading a poor performance or undesir-
able crashes when performing a desired mission. This situation happens because they have
physical constraints that are not often considered when computing the control law, e.g. maxi-
mum of revolution per minute (RPM) in a motor. Therefore, the design of robust controllers to
counter-actuate aggressive external disturbances or non-desired dynamics without saturate
the actuators remains a challenge for the automatic control community.


5.1.1 Proposed solution

Exploring the properties of disturbance observers, we introduce a robust control strategy for
solving the disturbance rejection problem. The underlying idea behind this work is that the
unknown lumped signal d (t ), along the solutions of (5.1) can accurately be estimated and
counteracted. However, as aforementioned in the presence of LoE in rotors or their physical
constraints, DOBC strategies have limitations and needs to be improved. Therefore, our robust
control architecture is composed of the following stages,



   1. Enhancing (5.3) by means of a disturbance estimator such that ~ u R becomes robust in
      presence of model uncertainties and a class of external disturbances.


   2. Improving the previous robust control strategy such as a rotors fault estimator M̂ ζ can
      be derived by means of ~
                             u R , giving robustness to the architecture even in LoE in rotors.


   3. Solving the physical constraints of the motors such that, the bounded control input
      σ≤~                                                                ξ →~
          u R∗ ≤ σ̄ of the robust control scheme, guarantees~η →~η r and ~  ξr with~η r and ~
                                                                                            ξr
      standing for the attitude and position references, respectively.



5.2 Robust control scheme for disturbance rejection
Let consider that system (5.1) can be also expressed as a perturbed nonlinear system with the
form

                  x˙ (t ) = (A + ∆A)~
                  ~                 x (t ) + (B + ∆B )~             x , t ,~
                                                      u R (t ) + f (~      u R (t )) + d (t )          (5.4)
                  y (t ) = ~
                  ~        x (t )

      x (t ) = [~
where ~         ξ,~η]T ∈ Rn and ~   u R (t ) ∈ Rm are the state and control vectors respectively, f (~
                                                                                                     x, t ) :
 n                 n
R × R × R → R defines an unknown non-linear function, and d (t ) : R+ → Rn denotes the
            +

vector of unknown disturbances. The state and control matrices are split so that A and B
are known and ∆A and ∆B are parametric uncertainties. Moreover, it is assumed that the
                       ∂[ f (~    uR ]
                             x )+B~
nonlinear function           ∂~u
                                                         u R ) ∈ Rn × Rm .
                                                      x ,~
                                       6= 0, for all (~
                             R



                                                                                                        123


Chapter 5. Robust control scheme based on disturbance estimator


The following assumptions are stated

Assumption 2. The pair (A, B ) is controllable.

Assumption 3. The uncertainty f (~      x ) belongs to the column space of B , i.e. there exists a vector
~
d f (~      m
     x ) ∈ R such that f (~       ~
                          x ) = B d f (x).

Assumption 4. There is a region D = ~                  x | ≤ r x where: i.) d~f (~
                                             x ∈ Rn : |~                          x ) is locally bounded, ii.)
~                                                                 ~
d f (0) = 0 and iii.) its derivative is locally bounded by |∇d f (~  x )| ≤ c x .

Assumption 5. The input disturbance d (t ) is uniformly bounded and its derivative is bounded
by °d˙° ≤ c d , ∀t ≥ 0.
   ° °


For developing the robust control scheme, let us propose the following ideal reference model

                                         x˙q (t ) = A q ~
                                         ~              x q (t ) + B q ~
                                                                       u q (t )                          (5.5)

                                            x q ∈ Rn and ~
where A q ∈ Rn×n , is Hurwitz, B q ∈ Rn×m , ~            u q ∈ Rm .

The goal for robust control strategies, is that ~x →~   x q , therefore, the following error can be
proposed
                                     ξ −~
                                e = (~
                                ~        ξq ,~η −~η q )> = ~    xq
                                                             x −~                              (5.6)

Differentiating (5.6) and using (5.4), (5.5) and adding and subtracting A q ~
                                                                            x , it holds that

                                                   e˙ = A q ~
                                                   ~        e −Γ                                         (5.7)
with
                             x + (B + ∆B )~
                 Γ = (A + ∆A)~            u R + f (~                           x − Bq ~
                                                      u R , t ) + d (t ) − A q ~
                                                   x ,~                               uq

Observe that if Γ → 0 then (5.7) will be asymptotically stable. Hence, ~
                                                                       u R can be proposed as

                                     ~
                                     u
                        z £        }|n           {¤
                  u R = B + (A q − A)~
                  ~                           u q + B + −∆A~
                                       x + Bq ~            x − ∆B~
                                                       £                     ¤
                                                                  uR − f − d                             (5.8)
                                                    |          {z            }
                                                                             ~
                                                                             uζ


where B + = (B T B )−1 B T corresponds to the pseudo-inverse of B . Then, the challenge will be
to compute ~u n and ~uζ .

Notice from (5.8) that, on one hand ~             u n concerns about the reference tracking performance
for system (5.5). Thus, proposing ~               u q = −K~x makes (A q − A)~    x + Bq ~
                                                                                        u q stable, with K > 0.
Therefore, this implies that ~       u n = −B K~   +
                                                             x with K̄ > 0. On the other hand, notice that,
                                                      x = −K̄~
~
u ζ will be the control part for compensating the inner uncertainties, unknown dynamics or
external perturbations. In addition, observe that ~             u ζ is a function of unknown variables, i.e.,
~
u ζ = f (∆A~x , ∆B,~        x ,~
                   u R , f (~  u R , t ), d (t )), and therefore it is difficult to estimate this parameter in
this form. However, using (5.4), it can be rewritten as

                             u ζ = B + [−∆A~
                             ~             x − ∆B~        x ,~
                                                 u R − f (~  u R , t ) − d (t )].                        (5.9)

124


                                             5.2. Robust control scheme for disturbance rejection


Observe that all the proposed methodology for estimating the uncertainties and external
perturbations are based on computing ~     u ζ in (5.9). Nevertheless, this parameter is function of
unknown variables as stated in (5.9), i.e., ~
                                            u ζ = f (∆A~ x , ∆B,~          x ,~
                                                                  u R , f (~  u R , t ), d (t )). However, using
(5.4), (5.9) can be rewritten as
                                      u ζ = B + [A~
                                      ~            x + B~uR − ~x˙ ]                                       (5.10)
Intuitively, it indicates that the unknown dynamics and disturbances can be estimated from
the known dynamics of the systems and control signal. Implementing (5.10), in this form in a
microcontroller, is not commonly used, hence for solving it, the signal (5.10) can be accurately
represented in the frequency domain as follows [186]

                                u ζ (s) = G f (s)B + [A~
                                ~                               u R (s) − s~
                                                       x (s) + B~          x (s)]                        (5.11)
if G f (s) is a strictly proper stable low-pass filter with unity gain and zero phase shift over the
spectrum of ~    u ζ and gain elsewhere. Computing the Laplace transform of (5.8) and using (5.11),
the disturbance rejection observer control law ~           u R (s), can be obtained as

                      u R (s) = [I −G f B + B ]−1 B + A q ~
                      ~                                   x + Bq ~       x (1 −G f ) − sG f ~
                                                     £                                        ¤
                                                                  u q − A~                  x   (5.12)
Observe that (5.12) is in general only an approximation cause the pseudo-inverse, however,
it is generally satisfied for some cases [187]. The asymptotic stability of the closed-loop
system is established in [188], when the filter G f (s) is chosen appropriately as a strictly-
proper stable filter with unity gain and zero phase shift over the spectrum of the uncertain
term f (~   u R , t ) + d (t ) and zero gain elsewhere. The developed robust control architecture is
         x ,~
depicted in Figure 5.1.
To summarize the tuning procedure, three essential parameters are considered: the control
gains of the feedback controller ~u n , the filter time constant T and the desired reference
model (5.5). On one hand, the value of the law-pass filter corresponds to the dynamic of
the perturbation to be estimated. A high value of T causes to filter excessively and, a small
one makes that any noise be a perturbation giving large peaks of the control action which
means that the system could become unstable. On the other hand, the b value of the reference
model represents a double integrator of each axes of the quadrotor and it was obtained
experimentally using a Pseudo Random Binary Sequence (PRBS) and the Recursive Least
Squares (RLS) algorithm, for identification purposes.



                                      Control

                         -
                                     Strategy




                                                         Disturbance
                                                          Observer




                                                     u n and ~
Figure 5.1 – Block diagram of the control structure. ~       u ζ correspond to the the nominal
control action and the control rejection part, respectively, ~ ξd is the desired reference. ~
                                                                                            uR
represents the proposed controller ζ represents external disturbances.


                                                                                                           125


Chapter 5. Robust control scheme based on disturbance estimator


5.2.1 Experimental results for disturbance rejections

The quadrotor prototype used in the flight tests, is a Parrot AR Drone 2 running the open
source software Fl-AIR [160]. An OptiTrack motion capture system was used to estimate the
vehicle’s position and analyzed in a ground station with others control variables coming from
the IMU sensor.

Three scenarios are proposed for validating the robust control scheme (5.8) using (5.11). The
practical goal is to expose the aerial vehicle to common disturbances as: wind, variable mass
and degradation in the performance of the rotors. The tests are carried-out with the following
procedure:


      • The state feedback controller is implemented and tuned into the aerial vehicle and used
        in all experiments.

      • The goal is to keep the vehicle at hover at the desired position is (x r , y r , z r ) = (0, 0, z r )m.

      • Disturbances are applied when the vehicle is at hover for degrading its performance.


The experimental tests are developed using parameters on Table 5.1. Here, K (1), K (2), express
the gains of the feedback controller for each subsystem. For the design of disturbance esti-
mator, each axis of (5.1) is considered decoupled and modeled by a double integrator of the
form G(s) = b/s 2 such that b is is obtained experimentally and T represents the bandwidth of
the low-pass filter G f = 1/(T s + 1) defined in (5.11). A video of the experimental results can be
seen at: https://youtu.be/lhcRiGlPq54.

                     Table 5.1 – Gain parameters used in the experimental tests


                                   Controller     φ/θ      ψ     x, y     z
                                      K (1)       0.8     0.6    0.17    0.3
                                      K (2)       0.1     0.2    0.13    0.1
                                       b          140     44      10      5
                                       T          0.1     0.5    0.5     0.3




Wind-gust disturbance

In this experiment, the practical goal consists of keeping the quadcotper at hover position
with an altitude z d = 1m while the vehicle is being affected by wind disturbance. For that,
three fans (1m from the desired position, see Fig. 5.2) were put to encircle the aerial robot for
emulating wind disturbance. Thus, the scenario is as follows: the quadrotor starts at hover
position x(0) = y(0) = 0m with the observer block activated while is being perturbed by the
fans. The observer block is deactivated and re-activated to compare the performances.

126


                                         5.2. Robust control scheme for disturbance rejection




                                Figure 5.2 – Wind-gust scenario.




From Figures 5.3-5.5 observe the good quadcopter performance when applying the proposed
controller. In Figure 5.3 the 3D state performance is depicted. Observe that when the robust
control scheme is activated, the vehicle remains in a small neighborhood around the desired
set-point, that is not the case when using only the state feedback controller.




                    1.05


                       1


                    0.95


                     0.9


                    0.85


                     0.8




                            0                                            0.3
                                  -0.5                             0.2
                                                           0.1
                                           -1        0




             Figure 5.3 – Vehicle’s performance in 3D against wind disturbance.




Note in Figure 5.4 that from time t = 0s to t < 45s, the proposed controller is applied and the
vehicle stay close into a neighborhood near to the origin. From t ≥ 45s and t ≤ 75s, only the
state feedback control is used and the quadrotor behavior is degraded due the control action
is not enough to compensate the wind-gust disturbances. To recover the good performance of
the system, the observer block is activated again at time t > 75s.

                                                                                           127


Chapter 5. Robust control scheme based on disturbance estimator




            Figure 5.4 – Performance of the vehicle in x−axis, y−axis and z−axis.

In Figure 5.5 the disturbance estimation is depicted related to the system performance. Notice
that when the observer is activated the disturbance is compensated and then the system
behavior is barely affected. Nevertheless that, from t ≥ 45s and t ≤ 75s the observer is not
activated and the real values of the disturbances appear as it can be seen in this figure. It is
worth mentioning that, the observer is used in open-loop in order to continue estimating the
disturbances.

                   0.1


                     0


                   -0.1
                          0           20        40         60        80          100



                     0


                   -0.1


                   -0.2
                          0           20        40         60        80          100



                   0.2


                     0


                   -0.2
                          0           20        40         60        80          100




                              Figure 5.5 – Estimation of the wind disturbance.



128


                                       5.2. Robust control scheme for disturbance rejection


Variable mass

This scenario was proposed for applications with variable mass. For example, when the drone
is tuned for certain gains and takes a mass for transporting to a desired position and needs
to leave it, usually, their performance is degraded. In this experiment, a mass of 100g is
applied on the rear right rotor when the quadrotor is at hover, emulating a box that needs to
be transported, see Figure 5.6. The desired altitude is z d (t ) = 1.5m.




             Figure 5.6 – Lateral weight disturbance applied to an aerial system.

In Figure 5.7, the 3D performance of the vehicle is depicted. On one hand, note here that
when the mass is added, the state feedback controller is not enough to compensate it and
the system performance is severely degraded (blue line). On the other hand, when the aerial
drone is flying with the proposed control scheme and the mass is added, its performance is
barely degraded (red line).




                     1.5

                     1.4

                     1.3

                     1.2

                     1.1

                      1

                     0.9

                     0.8
                                                                            0
                                                                     -0.5
                               1       0.5       0              -1
                                                         -0.5



          Figure 5.7 – Vehicle’s performance in 3D against the weight disturbance.

Figure 5.8 depicts the behavior of the vehicle in the three axes when adding a mass in motor
M 2 . Observe in this figure the poor performance when the mass is added to the vehicle flying
only with the linear controller, which is not the case, when the proposed scheme is used during
the flight and the mass is added. Notice that for this last case, the disturbance in the system is
unperceived, see graphs at time 2s< t < 4.5s.

                                                                                              129


Chapter 5. Robust control scheme based on disturbance estimator



                           1

                           0

                       -1
                               0       2       4   6   8   10   12    14    16



                           2

                           0

                       -2
                               0       2       4   6   8   10   12    14    16



                           2

                           1

                           0
                               0       2       4   6   8   10   12    14    16



      Figure 5.8 – Performance of the quadrotor against the later weight disturbance.

In Figure 5.9 the disturbance estimation is presented. Notice here from t ≥ 2s when the
observer is activated the disturbance is compensated and then the system behavior is barely
affected. However at the same time but with the observer deactivated, the real values of the
disturbances appear and the system performance is harshly degraded. Notice that dˆz have
similar behaviors. This is due the mass was not dropped immediately, for safety reasons, in
the test when the observer was not activated. This fact can be appreciated in the video.

                 0.2


                  0


                -0.2
                       0           2       4       6   8   10    12    14        16



                 0.5


                  0


                -0.5
                       0           2       4       6   8   10    12    14        16



                 0.5


                  0


                -0.5
                       0           2       4       6   8   10    12    14        16




                           Figure 5.9 – Estimation of the weight disturbance.



130


                                                5.2. Robust control scheme for disturbance rejection


Motor failure

The goal of this experiment, is to analyze the aerial vehicle performance when a motor failure
appears. Several researchers, for this kind of problems, propose solutions based on FTC
algorithms such that, an identification, isolation and compensation of the failure need to be
done. In our case, we propose to solve this problem only using the proposed robust control
scheme. Therefore, a virtual motor failure is considered when reducing its efficiency of the
frontal left motor (M 1 in Fig 5.10) in 40%. The desired altitude for this test is z d = 1.5m and the
fault is applied at time t = 4.5s. Observe in Figures 5.11 to 5.13 the vehicle performance when
a motor failure is applied.



                                           40%
                                       motor failure
                                                           zB
                                                f1                    f2   f3
                                      f4

                                 yB
                                                                OB
                                                     M               M2
                                      M4                                    M3
                                                            mg
                                                 z
                                           yI
                                                OI

                       Figure 5.10 – Partial rotor failure in a quadcopter.




                      1.8

                      1.6

                      1.4

                      1.2

                       1

                      0.8

                      0.6

                      0.4

                      0.2

                       0
                            2                                                        4
                                0                                                2
                                           -2                          0
                                                         -4-2



               Figure 5.11 – Vehicle’s performance in 3D against a rotor failure.




                                                                                                 131


Chapter 5. Robust control scheme based on disturbance estimator


In Figure 5.12, the states behavior in the three axes are illustrated. Observe in this figure that
the closed-loop system is harshly affected when the linear controller is used. However, note
that when applying the robust control strategy, the drone performance remains stable. In
Figure 5.13 the disturbance estimation is presented. Notice in this figure in red line, when the
proposed controller is applied, it could be appreciated that no disturbances are presented
because the proposed scheme estimates them considering a desired system performance and
then, compensate this external/internal disturbances. However, a small degradation can be
appreciated in the altitude.

                         4


                         2


                         0
                          0    2     4      6     8     10    12    14    16       18




                         0


                      -2


                      -4
                        0      2     4      6     8     10    12    14    16       18




                     1.5

                         1

                     0.5

                         0
                          0    2     4      6     8     10    12    14    16       18




              Figure 5.12 – Performance of the quadrotor against a rotor’s fault.



                     0


                   -0.5


                    -1
                      0        2     4     6      8     10    12     14       16    18




                     0


                   -0.5


                    -1
                      0        2     4     6      8     10    12     14       16    18




                   0.4

                   0.2

                     0
                      0        2     4     6      8     10    12     14       16    18




                              Figure 5.13 – Estimation of the rotor failure


132


                                     5.3. Enhancing robust control architecture for LoE in rotors


Moreover, when using a simple feedback controller without the observer, the system is sternly
affected and the vehicle altitude is reduced to 0.2m even if the controller tries to recover
the performance applying more energy to the affected motor, see Figure 5.14. It is worth to
mention that in Fl-AIR framework, the operating range of motors is from 0 to 1. Letting the
control algorithm operates out of these limits can lead to a crash of the vehicle or damage in
the actuators. In addition, 40% was the maximum value of the virtual rotor failure that has
been successfully applied to the proposed robust controller. This leads to the possibility to
improve the performance of the robust control architecture for dealing with these issues.



                     1.5



                      1



                     0.5



                      0
                           0     2     4    6     8     10   12    14    16     18




                     1.2

                      1

                     0.8

                     0.6

                     0.4

                     0.2

                      0
                           0     2     4    6     8     10   12    14    16     18




                               Figure 5.14 – Control actions of the motors.



5.3 Enhancing robust control architecture for LoE in rotors
In this section, the challenge will be to design a rotor fault observer for improving the per-
formance of the closed-loop system when using the robust controller addressed in section
5.2. Note from (5.8), in order to compensate external disturbances affecting the vehicle, the
estimation of ~
              u ζ through (5.11) is only necessary, nevertheless, for rotors fault estimation, this
variable needs to be reformulated. In addition, from (5.2) observe that u i is a function of the
motors force f i . We assume, in this work, that the thrust of each propeller is directly controlled
and attached in the z axis of the vehicle, i.e., the blade flapping effect is not considered.

                                                                u n and ~
Notice that (5.8) has the same structure that (5.2), therefore, ~       u ζ are also vectors of four
components and functions of the forces f i . As stated before, the force i produced by i −th
                                                                            2
motor can be computed using its angular rate w Mi , such that, f i ≈ k f w M  i
                                                                                . Therefore, it is also
possible to have a relation between the i −th motor and the combination of the control inputs
u i , i : 1...4.

                                                                                                   133


Chapter 5. Robust control scheme based on disturbance estimator


This relation is often obtained when the control laws u i need to be transformed into the real
control inputs, i.e., the actuators (motors). For the quadrotor vehicle with parallel motors, we
have
                                            M = H~  uR                                    (5.13)

with                                                                           
                              M 1 (t )                   u 1 (t )      u n 1 + u ζ1
                                                                               
                            M 2 (t )                  u 2 (t ) u n2 + u ζ2 
                         M =
                                      ;          ~
                                                   uR = 
                                                        
                                                                   = u + u  ;
                                                                                  
                             M 3 (t ) 
                                                       u 3 (t )   3  n       ζ 3

                              M 4 (t )                   u 4 (t )      u n 4 + u ζ4

and H denotes the allocation control matrix with the form
                                                       
                                       1 1       1 −1
                                                       
                                      1 −1 1         1
                                 H = 1 −1 −1 −1
                                                        
                                                       
                                       1 1 −1 1

Hence, M can be also separated as M = M n + M ζ ; the first one corresponding for the values
computed with the control law and the second one for the disturbances rejection. Therefore,
M ζ is the vector parameter that should compensate the undesired performances in the vehicle.
Analyzing only the disturbance part, it follows that M ζ = H~          u ζ . Rewriting it, in the scalar form,
it follows that
                                   M ζ 1 = u ζ1 + u ζ 2 + u ζ 3 − u ζ4
                                   M ζ 2 = u ζ1 − u ζ 2 + u ζ 3 + u ζ 4
                                                                                                        (5.14)
                                   M ζ 3 = u ζ1 − u ζ 2 − u ζ 3 − u ζ 4
                                   M ζ 4 = u ζ1 + u ζ 2 − u ζ 3 + u ζ 4

From (5.14), observe that ~ u ζ1 is common for the four rotors and it can be considered as the
altitude disturbance in the vehicle and affects the efficiency of all rotors power at the same
time. Therefore, its contribution for detecting if one motor is losing efficiency is less important.
Nevertheless, notice also from (5.14) that the combination of the terms ~    u ζ j for j : 2, 3, 4; has a
severe impact in each rotor. Hence from the previous analysis, it is possible to propose the
following rotors fault estimator

                                        M̂ ζ1    = u ζ 2 + u ζ3 − u ζ4
                                        M̂ ζ2    = −u ζ2 + u ζ3 + u ζ4
                                        M̂ ζ3    = −u ζ2 − u ζ3 − u ζ4                                (5.15)
                                        M̂ ζ4    = u ζ 2 − u ζ3 + u ζ4
                                        M̂ t h   = u ζ1 .

with M̂ ζi is the disturbance parameter estimation for motor i .




134


                                  5.3. Enhancing robust control architecture for LoE in rotors


The analysis of equation (5.15) can be done in two scenarios:



   1. without rotors fault (conventional flights), here the values of M̂ ζi for i : 1 : 4; are relatively
      small but they should not be necessarily null, M̂ t h is increased and the external and
      unknown disturbances can be estimated using only (5.11).



   2. with rotors fault, in this scenario the values of M̂ ζi for i : 1 : 4; increase, degrading
      severally the performance of the vehicle and it can be seen as LoE in motors.



From the vehicle configuration and physical characteristics, observe that if one parameter
of M̂ ζi reaches a critical value ²m , the control law will not be capable of keeping the vehicle
stable at hover position, and thus, an inevitable crash will arise. This critical value is chosen
such that a minimal main thrust (u 1 ) is required to overcome the weight of the vehicle (mg ),
i.e.,
                                        ²m = min u 1 = mg + δ.

with δ is a small positive constant. Therefore, two flight modes are proposed for scenario (2)

                                          SM :    M̂ i d ≤ ²m ,
                                          EM :    M̂ i d > ²m ,

where S M and E M stand for the safe and emergency modes, respectively.

The enhanced control architecture is depicted in Figure 5.15. dˆξ and dˆη correspond to the
internal/external disturbances on the position and attitude subsystems and ~ξd is the desired
position. ~
          u R represents the vector control input containing the main thrust and the control
torques respectively. ζi means the external disturbances and ²m symbolizes the desired
threshold.




              Figure 5.15 – Block diagram of the enhanced control architecture.




                                                                                                    135


Chapter 5. Robust control scheme based on disturbance estimator


5.3.1 Numerical and practical validation

The robust control scheme developed in (5.8) and (5.15) were validated in numerical simu-
lations and real-time experiments. The experimental and numerical tests were performed
using Fl-AIR and the quadrotor Ar. Drone 2.0. The control parameters for simulations and
experiments are the same as presented in Table 5.1. A video of the experimental results can be
seen in https://youtu.be/OHoGpP7s12w.

The proposed architecture is validated using the following priorities
      • Assuring the attitude stabilization at hover of the aerial vehicle, i.e., ~η → ~η d , where
        ~η = [θ φ ψ]T ,~η d defines the desired attitude and ψ, θ and φ are the yaw, pitch and roll
         angles, respectively.

                                                         ξ →~
      • Once the attitude performance is recovered, then ~             ξ(t ) = [x, y, z]T , ~
                                                            ξd , where ~                    ξd
        denotes the desired position.
For simulations and experimental flight tests and for solving the practical stability of the
vehicle, two flying modes are considered in rotors failures. The first one is called safe mode -
S M or non critical case. Here, the proposed robust architecture can attenuate internal/external
disturbances such as: wind, uncertainties into the model, etc, in such a way that, the practical
stability of the quadrotor can be guaranteed. The non critical case is considered when rotors
faults are less than a desired threshold ²m .

The second one, the emergency mode - E M - or critical case, uses the proposed robust scheme
to detect important loss of effectiveness in the rotors and assure a safe landing. The critical
case is activated when rotors failures are greater than ²m . In this critical case, one degree of
freedom is lost into the system and the control architecture is reconfigured for maintaining
the aerial drone in flight or ensuring a safe landing. The control reconfiguration is given in
following procedure :

   1. The controllability of the yaw angle (ψ) is lost when the rotor failure exceeds the thresh-
      old.

   2. The vehicle turns along its z axis and the yaw angle rate (ψ̇) is controlled at high velocities
      for recovering its practical stability.

   3. The practical stability is recovered trying to reach the desired altitude, z d . If z d is not
      reached quickly the safe landing is activated.

   4. The drone lands in a safe mode.

For simulations and flight tests, the following assumptions are taken into account:

Assumption 6. Physical constraints of the rotors, as damage in the propeller, are also considered
as Loss of Effectiveness.

Assumption 7. Motors are constrained with a maximum value of revolutions per minute (RPM)
for physical safety reasons.

136


                                5.3. Enhancing robust control architecture for LoE in rotors


Assumption 8. For the practical validation and keeping the integrity of the prototypes, it is
assumed that only individual partial faults in the actuators are presented in the system, i.e., not
simultaneous rotors fault are considered in this work.


Numerical results

Two rotors fault scenarios are introduced for numerical validation. The first one consists in
apply a LoE in motor M 1 into the aerial robot while it is performing a non hover position. For
the second one, a critical rotor failure in M 1 is injected when the vehicle is at hover position
and the emergency landing is required.


Rotor fault in a non hover position

The goal of this scenario is to show the performance of the quadrotor, when a rotor fault of
30% in motor M 1 is applied while performing a non hover position. The initial and desired
                                                  ξ(t 0 = 0) = [−2, 0, 0]T m and ~
conditions, for this scenario, are the following: ~                              ξd = [3, 0, 2]T m,
respectively, moreover ²m = 0.4.

In Figure 5.16 the performance of the vehicle in 3D space when performing the desired task
is addressed. Notice that when using the proposed architecture and the fault is injected, the
whole system overcomes it and converges to the desired final point (solid line). In other case,
when using only ~ u n , the performance of the vehicle is degraded (dotted line). In other case,
the performance of the vehicle is degraded, as can be verified in Figure 5.17. Notice from this
figure, when the fault is injected at t = 6.5s, the y and z axes are slightly more compromised.
Nevertheless, when using the proposed approach, at t = 7s the quadrotor is recovered and
thus, it can converge to the desired trajectory.




Figure 5.16 – Quadrotor position performance when using a feedback controller and the
proposed architecture.


                                                                                               137


Chapter 5. Robust control scheme based on disturbance estimator



                         4

                         2

                         0

                        -2
                          0             2       4       6       8   10    12        14        16        18




                         0


                       -0.5


                        -1
                          0             2       4       6       8   10    12        14        16        18




                         2


                       1.8


                       1.6
                          0             2       4       6       8   10    12        14        16        18




   Figure 5.17 – Scenario 1.- Performance of the quadrotor subject to a LoE of 30% in M 1 .


In Figure 5.18 the performance of the proposed rotors faults estimator is shown. It can be
observed that the fault occurs at t = 6.5s. Moreover, the performance of the rotor inputs is
displayed in 5.19. Notice the slightly difference when the scheme is activated or deactivated.
In order to compensate the LoE in motor M 1 when using the scheme’s feedback, motor M 3
reduces its velocity to maintain the drone flying in the desired path.




                              0.3

                         0.25

                              0.2

                         0.15

                              0.1

                         0.05

                               0

                        -0.05

                          -0.1

                        -0.15

                          -0.2
                                    0       2       4       6   8   10   12    14        16        18




      Figure 5.18 – Scenario 1.- Performance of the rotor fault estimator M̂ ζi , i = 1, · · · , 4.




138


                                   5.3. Enhancing robust control architecture for LoE in rotors



                         1
                                                   30% Fault M1
                        0.8

                        0.6                           0.8

                        0.4                           0.6

                        0.2
                                                      0.4
                                                         6              6.5         7     7.5
                         0
                          0    2      4   6    8       10          12          14   16   18




                         1

                        0.8                        30% Fault M1

                        0.6
                                                            0.8
                        0.4
                                                            0.6
                        0.2                                 0.4
                                                               6         6.5        7    7.5
                         0
                          0    2      4   6    8       10          12          14   16   18




                                                                                      u n and ~
Figure 5.19 – Scenario 1.- Control action’s behavior of each of the rotors when using ~       uR
controllers.

A critical rotor fault (emergency mode)
In this scenario the aerial vehicle is at hover at the position ~
                                                                ξ(t 0 = 0) = [0, 0, 2]T m. A critical
rotor failure in motor M 1 , emulated by the loss of 60% of its effectiveness, is introduced in
this scenario at t = 4.5s. Here, the fault exceeds the threshold chosen ²m = 0.4, and then, the
control algorithm switches into emergency mode. In the reconfiguration control, the yaw
angle is lost and the desired yaw velocity is chosen as ψ˙d = 10rad/s.
Figures 5.20 shows the performance of the quadrotor subject to a critical rotor failure. From
this figure, notice that when the fault is injected instantaneously the vehicle crashes when
using only the state feedback controller ~ u n = −K~  x . However, when using proposed control
scheme ~ u R the quadrotor recovers quickly its altitude (at t = 6s) for then, landing in a safe way.




     Figure 5.20 – Position performance of the vehicle subject to a critical failure in M 1 .


                                                                                                 139


Chapter 5. Robust control scheme based on disturbance estimator


In Figure 5.21 the performance of the fault estimator is presented. Notice that the fault is
injected at t = 4.5s and some small oscillations appear are as result of the vehicle is turning on
its own axis. Nevertheless, the estimation has almost reached the exact value of the injected
fault. This can be confirmed in Figure 5.22. Observe in here, the motors M 2 , M 3 and M 4 as
a result that the control scheme lost the controllability of the yaw angle. Remark that the
magnitude of the motor M 1 is reduced to a maximum of 40% of its effectiveness. Hence, rotors
M 2 , M 3 and M 4 change its velocity, even reaching and passing the limits of saturation, in order
to recover the quadrotor subject to the rotor fault.



                            1

                          0.8

                          0.6

                          0.4

                          0.2

                            0

                          -0.2

                          -0.4

                          -0.6

                          -0.8

                            -1
                                 0           2             4          6            8             10




      Figure 5.21 – Scenario 2.- Performance of the rotor fault estimator M̂ ζi , i = 1, · · · , 4.




                          1.5

                                         60% Fault M1
                            1


                          0.5

                                                                             Vehicle crash
                            0
                             0       1      2      3       4   5      6      7      8        9    10




                          1.5
                                                                   Safe Landing
                                            60% Fault M1
                            1


                          0.5


                            0
                             0       1      2      3       4   5       6     7      8        9    10




Figure 5.22 – Scenario 2.- Rotors control action’s performances when a critical fault in motor
M 1 is applied.




140


                                   5.3. Enhancing robust control architecture for LoE in rotors


Experimental results

In this section, four different motor fault scenarios are introduced to validate in real-time tests
the proposed robust control scheme considering ²m = 0.4. Thus, they are defined as follows:


   1. A motor fault is applied in different times in each motor (academic example).

   2. A motor fault is injected in M 1 while the drone is flying to reach a desired position.

   3. A critical fault (50% LoE) is induced in a motor when the vehicle is at hover position.

   4. A critical fault (60% LoE) is applied in a motor and the emergency landing is applied.


Scenario 1: The academic example

In this scenario, non critical rotors faults are injected into the system, i.e., each 10s a virtual
fault of 30% LoE is applied on each rotor. The goal of this scenario is to show the good accuracy
of the proposed approach to estimate and compensate the virtual fault. The initial conditions
of the system are: x(0) = y(0) = 0 and z = 2 in meters and the goal is to keep the robot at hover
position.

Observe in Figure 5.23 at 3s≤ t ≤ 8s the virtual fault in the rotor M 1 was injected. Similarly,
for the motor M 2 the fault was induced at 13s≤ t ≤ 18s, then at 23s≤ t ≤ 28s for the rotor M 3
and finally at 33s≤ t ≤ 42s in rotor M 4 . Notice that the proposed architecture is capable to
continue estimating almost the total value of the injected fault, as we proposed in (5.15), even
if the control law is not using the feedback of the proposed scheme.


                                                       0.1
                                                      0.05
                                                        0
   0.4
                                                     -0.05
                                                      -0.1

   0.3                                                   0    5   10   15   20   25   30   35   40   45    50



                                                       0.1
   0.2
                                                        0


   0.1                                                -0.1
                                                         0    5   10   15   20   25   30   35   40   45    50


    0                                                  0.2



  -0.1                                                  0



                                                      -0.2
  -0.2                                                    0   5   10   15   20   25   30   35   40   45    50
         0   10      20       30        40      50




Figure 5.23 – Performance of the rotor faults estimator M̂ ζi and the disturbance estimations
(5.11) of the attitude system of the quadrotor .


                                                                                                          141


Chapter 5. Robust control scheme based on disturbance estimator


Furthermore, in Figure 5.24, when the fault is induced, each motor suffers a degradation on its
performance. Here, it is worth to mention that the operating range of the rotors in Fl-AIR’s
framework is between 0 to 1. Thus, when the rotor fault is injected, its effectiveness is changes
to 0 - 0.7, in this particular scenario. Notice in this figure, that when the fault is injected and
the scheme is active, the rotor reacts faster to compensate this fault and the vehicle converges
to the desired reference. This can be checked in Figure 5.25 in each axis, where the z and x axes
are slightly more penalized when the rotor fault is injected. Notice that according to number
of the rotors, this will affect the performance of the vehicle, moving forward or backward
respectively (positive or negative sign in the graph).




Figure 5.24 – Scenario 1.- Control rotors performance when using the linear controller (top
graph) and the proposed scheme.

                          1



                          0



                          -1
                            0   5   10   15   20   25   30   35   40   45   50



                          1


                         0.5


                          0


                        -0.5
                            0   5   10   15   20   25   30   35   40   45   50




                         1.6


                         1.4


                         1.2
                            0   5   10   15   20   25   30   35   40   45   50



Figure 5.25 – Scenario 1.- Performance of the quadrotor position subject to a sequence of
rotors failures.


142


                                   5.3. Enhancing robust control architecture for LoE in rotors


Scenario 2: Rotor fault in a non hover position
Most of the aerial robot applications imply long displacements and when a rotor fault occurs
the drone crashes. The goal of the second scenario is to show the performance of the quadrotor
when moving from a point A to a point B and then, a degradation of 30% of the effectiveness
in motor M 1 on time t = 6s is virtually induced. For this end, the initial and desired conditions
are as follows ξ(t 0 = 0) = [−2, 0, 2]T m and ξd = [3, 0, 2]T m, respectively.

In Figure 5.26 the behaviors of the vehicle in 3D space when performing the desired task, using
two controllers, are introduced. Observe that when the fault is injected and the proposed
architecture is applied, the quadrotor overcomes it and converges to the desired final point.
Otherwise, the performance of the vehicle is degraded, as can be verified in Figure 5.27.




Figure 5.26 – Scenario 2.- Position performance of the vehicle when using the linear controller
and the proposed architecture, and a rotor fault is induced in a non hover position.


                          4


                          2


                          0


                          -2
                            0      2   4    6    8    10   12   14   16



                         0.2

                           0

                        -0.2

                        -0.4


                               0   2   4    6    8    10   12   14   16



                         2.2


                          2


                         1.8


                         1.6
                            0      2   4    6    8    10   12   14   16




Figure 5.27 – Scenario 2.- Performance of the quadrotor position subject to a rotor fault while
moving to a desired position ~ ξd (t f ).


                                                                                              143


Chapter 5. Robust control scheme based on disturbance estimator


In Figure 5.28 the estimation of the motors fault is presented. Notice that the observer keeps
estimating the fault even if it was compensated. Similarly in Figure 5.29 the motor control
input performances are depicted. A slightly difference between these graphs can be seen.
In order to compensate the magnitude of the rotor fault, when using the proposed scheme,
motor M 2 immediately switch to zero its velocity to maintain the drone flying in the desired
trajectory.


                       0.4


                       0.3


                       0.2


                       0.1                                                30% fault M 1

                           0


                      -0.1


                      -0.2


                      -0.3


                      -0.4


                      -0.5
                               0           2           4   6          8        10         12    14        16




            Figure 5.28 – Scenario 2.- Rotors faults estimations M̂ ζi , i = 1, · · · , 4.




                     1.2

                       1

                     0.8

                     0.6
                                                                0.8
                     0.4                                        0.7
                                                                0.6
                     0.2              30% fault M 1
                                                                          8      10       12    14
                       0
                           0           2           4       6          8        10         12     14        16



                     1.2

                       1

                     0.8

                     0.6

                     0.4
                                                                0.6

                     0.2           30% fault M 1
                                                               0.55
                                                                          8         10     12        14
                       0
                           0           2           4       6          8        10         12     14        16




Figure 5.29 – Scenario 2.- Rotors control action’s performances, when a LoE of 30% in M 1 is
applied during a non hover position.



144


                                5.3. Enhancing robust control architecture for LoE in rotors


Scenario 3: A critical rotor failure: searching for a safe zone for landing

When a quadrotor is performing a task and a critical rotor fault occurs is not always possible
to land safely. The goal of this test is to present the performance of the vehicle when a critical
fault appears while it is flying in zones where, a safety landing immediately is not possible.
Thus, searching for a safe zone must be done. For that, suppose the quadrotor is located at
~
ξ(t 0 = 0) = [0, 0, 2]T m, and a virtual fault of 50% of LoE in the motor M 1 is introduced. Then,
according to the control reconfiguration procedure, the control law switches to the emergency
mode. Here, the position yaw control is lost and only the yaw rate can be controlled. Once the
drone attitude is recovered, it reaches quickly its desired altitude z d and then a safe set-point;
~
ξd = [2, 0, 2]T m, is sent to the quadrotor simulating a coordinate where the vehicle can be
landed in safety mode.

In Figure 5.30 the 3D performance of the vehicle when a critical fault injected in motor M 1
is depicted. Notice here that, on the one hand, when the fault is injected, the state feedback
controller is not enough to compensate it and the system performance is harshly degraded,
making the drone crashes (dotted line). On the other hand, when the aerial drone is flying with
the proposed control scheme, its performance is barely degraded such that, safe displacements
and safe landings are possibles.




Figure 5.30 – Scenario 3.- Performance of the vehicle when applying a motor fault of 50% and,
two different controllers are used.



Figure 5.31 presents the behavior of the vehicle in the three axes when the fault in motor M 1 is
injected. Observe that, when the virtual rotor fault is injected, the performance of the vehicle
when using the state feedback controller is degraded. However, in the same figure in the z−
axis at 4s≤ t ≤ 6s, note that when using the proposed scheme the performance of the drone is
barely degraded.

                                                                                              145


Chapter 5. Robust control scheme based on disturbance estimator


The variations in the x and y axis are due the quadrotor is turning on its own axis and simul-
taneously, controlling the error position. The safe reference is sent at t = 12s and once the
vehicle arrives, the safe landing can be achieved. The performance of the proposed rotor
fault estimator is shown in Figure 5.32. From this figure we can corroborate that the fault was
injected at t = 4.5s and the well performance of the rotor fault observer when estimating the
failure.



                          2
                                   50% Fault M1        Safe displacement
                          1


                          0

                           0           2     4         6     8      10     12     14      16   18        20




                        0.5
                               50% Fault M1

                          0


                        -0.5
                           0           2     4         6     8      10     12     14      16   18        20




                          2


                          1

                                   Vehicle Crash                           Safe Landing
                          0
                           0           2     4         6     8      10     12     14      16   18        20




Figure 5.31 – Scenario 3.- Performance of the quadcopter position subject to a critical rotor
fault of 50% in M 1 .




                           1

                         0.8

                         0.6

                         0.4

                         0.2

                           0

                        -0.2

                        -0.4

                        -0.6

                        -0.8
                               0                   5              10               15               20




             Figure 5.32 – Scenario 3.- Rotors faults estimations M̂ ζi , i = 1, · · · , 4.



146


                                         5.3. Enhancing robust control architecture for LoE in rotors


In Figure 5.33 the performances of the motors M i subject to a rotor fault of 50% of LoE in
M 1 are depicted. Notice that, once the fault is injected, the effectiveness range in motor M 1
is reduced 50%, in addition, remark that the motor M 4 turns off for some milliseconds (for
compensating M 1 ) and, motors M 2 and M 3 increases its velocity to make possible the yaw
velocity control.




                          2


                         1.5                                       Vehicle Crash
                                    50% Fault M1

                          1


                         0.5


                          0
                              0      2        4    6      8   10       12     14    16        18   20




                          1
                                    Moving into a safe zone                    Safe Landing
                         0.8

                         0.6

                         0.4
                               50% Fault M1
                         0.2

                          0
                              0      2        4    6      8   10       12     14    16        18   20




Figure 5.33 – Scenario 3.- Rotors control action’s performances, when a critical fault of 50% in
M 1 is applied.




Scenario 4: A critical rotor fault with emergency landing

An emergency landing is a prioritized flight mode made by an aircraft in response to an
imminent or ongoing threat, e.g. rotors failures, in order to keep the safety operation of the
vehicle. This scenario shows the performance of the drone when a LoE of 60% is induced in
a motor. Thus, the scenario is set as follows: the drone is flying at hover ξ = [0, 0, 2]T m, this
position is taken as its initial position ξt0 =0 , at time t = 3.9s the virtual failure in M 1 is applied
and the vehicle performance degraded.

Notice from Figure 5.34 that when using only the linear controller the robot performance
is instantly degraded and it crashes (dotted line). Nevertheless, when using the proposed
architecture, the rotor fault observer estimates the motor fault that is compared with the
threshold. As the threshold is overpassed, the control scheme switches into the emergency
mode. This allows to recover the quadrotor attitude performance and the desired altitude.
Nevertheless the aerial robot begins to lose altitude and then the condition for an emergency
landing is activated. And thus at the end, the quadrotor lands safely (solid line).

                                                                                                        147


Chapter 5. Robust control scheme based on disturbance estimator




Figure 5.34 – Scenario 4.- Position performance of the vehicle when using the linear controller
and the proposed architecture, and a critical rotor fault is induced.


In Figure 5.35 the estimations of M̂ ζi are depicted. Notice here that their values oscillate
after time t = 4.2s and they are produced when the aerial robot is turning in its vertical axis.
Moreover, in Figure 5.36 the motors performances are illustrated. Notice that M 1 has 40% of
tis effectiveness when the failure is applied, and then M 4 stops working for short intermittent
milliseconds for compensating effectiveness in M 1 . Observe also that M 2 and M 3 increase
their effectiveness to recover the main thrust and recover the desired altitude, nevertheless it
produces that the vehicle turns in its vertical axis.


                        2

                       1.5

                        1

                       0.5

                        0

                      -0.5

                        -1

                      -1.5

                        -2
                             0   1    2     3     4     5      6     7     8     9



             Figure 5.35 – Scenario 4.- Rotors faults estimations M̂ ζi , i : 1, · · · , 4.




148


                                      5.3. Enhancing robust control architecture for LoE in rotors



                         1

                        0.8

                        0.6

                        0.4
                                      60% Fault M1
                        0.2                                         Crash

                         0
                              0   1         2        3   4      5      6      7        8   9



                         2


                        1.5                                             Safe Landing
                                          60% Fault M1
                         1


                        0.5


                         0
                              0   1         2        3   4      5      6      7        8   9




Figure 5.36 – Scenario 4.- Rotors control action’s performances, when a critical fault of 60% in
M 1 is applied.


5.3.2 Discussion

In this section, we have carried out a performance analysis, with the three experimental
scenarios, of the advantages of the proposed architecture with respect to use only the linear
controller. For this purpose, the performance indices and a qualitative comparison of the
controllers are obtained. The performance indices are the Integral Absolute Error (IAE), and
the Root Mean Square Error (RMSE). A summary of the analysis of the three experimental tests
is presented in Table 5.2. It is worth to mention that, all the experiments were developed using
the same control gains, i.e., re-tuning these variables was not needed. Concerning the steady
state regime, from table results, it can be observed that the proposed robust control scheme
achieves the best performance in all the axes. Nevertheless, it is true that is possible to have a
better performance for the linear controller but in this case, re-tuning the control variables
most be done for each experiment.

                    Table 5.2 – Performance indices of the three scenarios.

                                    Scenario 1                Scenario 2            Scenario 3
                                   IAE   RMSE                IAE RMSE             IAE RMSE
                        uq         3.34   0.19               in f   in f          in f    in f
                    z
                        ū         0.39   0.04               1.52   0.41           1.8    0.35
                        uq        13.02   1.18               in f   in f          in f    in f
                    x
                        ū         5.29   1.02               5.55   0.46          2.17    0.24
                        uq         6.01   0.38               in f   in f          in f    in f
                    y
                        ū         0.35   0.04               1.49   0.22          0.98    0.09



                                                                                                 149


Chapter 5. Robust control scheme based on disturbance estimator


Regarding the design, tuning and the implementation effort, the linear controller is easier
to tune because its structure can be seen as a simple controller. However, the proposed
scheme is composed mainly of an observer, a simple reference model of the vehicle and a
band-pass filter. All these parameters need to be obtained experimentally in order to have
a good approximation of the system. Nevertheless, once the observer is well-tuned for the
prototype, it can be used with almost all kind of controllers. The advantage of using the
proposed scheme is that it contains an immediate and smooth control action when undesired
dynamics appears, especially rotors fault. This can be verified in Table 5.2, column two and
three, where it can be observed that, using only a linear controller, when a critical rotor fault is
injected, it wont be enough to overcome it.

For that, the good performance of the system is guaranteed when critical fault occurs and the
proposed control scheme is being used. Nevertheless, as all kind of control schemes, there
are some limitations that are related with the physical characteristics of the prototype. For
example, we have observed from real-time flight tests that when injecting critical faults more
than 70%, the observer sends the respective compensation which exceeds the capacity of
effectiveness of all the motors, such that the quadrotor becomes unstable. This is mainly due
the fact, the observer does not take into account the limit of operating range of the rotors. In
addition, we have analyzed the Total Variation (T V ) of the control input (T V = ii =∞
                                                                                 P
                                                                                     =1 |u i +1 −u i |)
as a measure of the control effort. This index can easily show the aggressively of the controller
and can be seen as a measurement of the used energy by the control action. In Table 5.3,
scenario 1, the T V of the first experiment is presented.


                        Table 5.3 – Total Variation (TV) of the control inputs.

                                              Scenario 1
               u2           u3        u4        u1      M1        M2          M3        M4
        uq    26.80        39.43     95.11     4.72    64.68     116.12      54.06     89.43
        ū    46.62        65.33    112.80     6.52    76.10     150.75      58.20     117.04
                                              Scenario 2
                 u2          u3        u4       u1       M1        M2         M3        M4
                in f        in f      in f     in f      in f      in f       in f      in f
        uq
              (17.35)     (29.13)   (32.59)   (4.70)   (26.36)   (29.28)    (34.76)   (29.47)
               30.03       68.45     89.03    10.33     58.05     76.19      69.95    114.97
        ū
              (21.54)     (32.14)   (40.61)   (6.07)   (31.39)   (37.62)    (36.02)   (40.80)
                                              Scenario 3
                 u2          u3        u4       u1       M1        M2         M3        M4
                in f        in f      in f     in f      in f      in f       in f      in f
        uq
              (10.42)     (11.78)   (17.54)   (1.12)    (9.67)   (20.91)    (16.73)   (15.56)
               26.31       32.52     38.88     4.45     24.22     53.78      34.06     37.66
        ū
              (12.31)     (14.90)   (18.68)   (1.98)   (12.75)   (27.51)    (20.09)   (18.64)




150


                                         5.3. Enhancing robust control architecture for LoE in rotors


Remark from Figure 5.37, a similar performance of both controllers is encountered. Neverthe-
less, the ~
          u n controller has a lower T V because the designed controller is not aggressive as the
u R , but with the lack of the disturbance rejection property, since the ~
~                                                                        u n cannot deal with the
set-point tracking problem in the presence of faults.


                         1



                       0.5



                         0

                             0       2         4           6           8        10       12        14            16




                         1


                       0.5


                         0


                       -0.5
                           0         2         4           6           8        10       12        14            16




                                              u n and ~
                 Figure 5.37 – Control inputs ~       u R of the first scenario.


Moreover, based on the performance of the control laws depicted in Figure 5.38, the T V of the
second experiment is presented in Table 5.3, scenario 2. In contrast to the previous cases, the
~
u n controller presents an infinity T V when the fault was injected since the system becomes
unstable. This is mainly due to the fact that, the control algorithm is not robust enough to
reject this kind of disturbances. However, the ~
                                               u R control can overcome the fault, even continue
flying safely, thus, the safe landing can be carried-out.


                         1


                         0


                        -1


                        -2
                             0       1             2           3           4         5        6         7             8




                         1

                       0.5

                         0

                       -0.5

                        -1
                             0   2         4           6           8       10   12       14       16        18        20




                                            u n and ~
               Figure 5.38 – Control inputs ~       u R of the second scenario.


                                                                                                                           151


Chapter 5. Robust control scheme based on disturbance estimator


Finally, in Table 5.3, scenario 3, the T V of the last experiment is provided. In this experiment,
an aggressive fault was introduced, as can be observed in Figure 5.39. Therefore, the ~        un
controller is not able to continue flying and thus, it becomes unstable such that, the T V
becomes infinity. Nevertheless, the ~   u R controller is able to overcome this problem since is
prepared to deal with this kind of high disturbances. We show in parenthesis, the T V of these
last two experiments, before the faults were injected.


                         0.5




                          0




                        -0.5
                            0     0.5   1   1.5   2   2.5   3   3.5   4   4.5   5




                          1


                          0


                         -1


                         -2
                              0   1     2   3     4   5     6   7     8   9     10




                                               u n and ~
                  Figure 5.39 – Control inputs ~       u R of the third scenario.



5.4 Enhancing robust control architecture for handling rotor’s con-
    straints
Notice that equation (5.13) represents the real robust control input applied to the actuator
M i for controlling the aerial vehicle. Moreover and as stated before, rotors have physical
constraints that can be seen as the limit of operating speed range σ̄i and σi which describes the
upper and lower bound of the i − t h motor, respectively. This brings out a non trivial problem
with respect to, when is needed to saturate a controller or when is not. To make this clear let
us introduce two cases; assuming the upper and lower bound of motors are σ̄i = 1, σi = 0
respectively, and considering the control action as ~u R = [0.80 0.05 0.05 0.05]T , this produce the
control actions of motors M = [0.95 0.75 0.75 0.85] . Nevertheless, if ~
                                                    T
                                                                        u R = [0.80 0.15 0.05 0.05]T ,
gives M = [1.05 0.65 0.85 0.95]T .

Therefore notice that even if the values of ~  u Ri are almost the same for both cases, it is not
obvious if actuators could be or not saturated, since that to saturate the actuators, it will
depend of the set of control inputs and not only in one in particular. A popular solution
is to bound each control input, ~  u Ri , however, this is not at all an efficiently solution since,
bounding the control input does not means that one of the actuators has not been saturated.
For avoiding that, it is necessary to compute a set of the optimal bounded control inputs, ~     u R∗ ,
from ~uR .

152


                 5.4. Enhancing robust control architecture for handling rotor’s constraints


Hence, ~
       u R∗ can be obtained as
                                                       u R∗ = ~
                                                       ~      δTM ~
                                                                  uR .                                (5.16)

where ~
      δTM = [δ1 δ2 δ3 δ4 ] with δi defining a factor for fulfilling the rotors constraints. The
bounds for the motors control inputs can be find solving the following quadratic problem

                                                         1 ~T ~
                                                min                c T δ~M
                                                           δ Q δM +~                                  (5.17)
                                                  ~
                                                  δM     2 M
                                                         δM ≤ ~
                                                st . A M ~    b                                       (5.18)

        c , A M ,~
where Q,~        b are matrices and vectors that will be defined later.

For computing matrices and vectors in (5.17) and (5.18), the following cost-to-go function can
be defined
                                        4
                                                      u R∗i )2 ,
                                               u Ri − ~
                                       X
                                  fo =    Q i (~                                         (5.19)
                                                    i =1

where Q i is a weight value penalizing the control input ~        u Ri . Developing the above equation, it
follows that
                                     4
                                                          u R2 i + δ2i ~
                                             u R2 i − 2δi ~            u R2 i ).
                                    X
                               fo =     Q i (~                                                     (5.20)
                                           i =1


From (5.20), note that the term ~u R2 i does not affect to find the minimum of the quadratic
problem, thus, it can be neglected. Rewriting the above equation in matrix form, it yields

                                              1 T ~
                                           fo= ~       cT ~
                                               δ Q δM +~  δM
                                              2 M

with                                                                                           
                      Q 1 u R2 1       0                0           0                 −Q 1 u R2 1
                                   Q 2 u R2 2                                        −Q 2 u R2 
                                                                                               
                      0                                0           0
                                                                                  ~
                                                                             
                  Q =                                                       ,   c =
                                                                                     −Q u 2  .
                                                                                                2
                      0
                                      0           Q 3 u R2 3       0        
                                                                                     3 R3 
                         0             0                0       Q 4 u R2 4            −Q 4 u R2 4


Let now introduce the constraints in the motors control input with the form σi ≤ M i ≤ σ̄i ,
where σ̄i and σi are the upper and lower bounds of the motors, respectively. Moreover, define
  ∗
u R0 as the equilibrium point of the aerial robot at hover position, in other words, the u 1 needed
to compensate the weight of the vehicle.

For finding the condition (5.18), consider the case of the motor M 1 ≤ |σ̄1 |. Thus, taking into
account the weight compensation u R0  ∗
                                        and using (5.13) with the optimal value of ~    u R as in
(5.16), it follows that
                                    4
                                                              ∗
                                   | ±δi ~u Ri | ≤ |σ̄1 | − u R0
                                    X
                                                                 .                         (5.21)
                                           i =1




                                                                                                        153


Chapter 5. Robust control scheme based on disturbance estimator


Then, following the same procedure for the rest of motors and rewriting them in a matrix form,
it follows that (5.18) can be founded with

                                                                   σ̄1 − u R0
                                                                           ∗ 
                                                                
                            +u R1   +u R2   +u R3   −u R4
                           +u      −u R2   +u R3   +u R4        σ̄ − u ∗ 
                            R1                                  2       R0 
                                                                  σ̄3 − u ∗ 
                                                                            
                           +u R1   −u R2   −u R3   −u R4 
                                                                        R0 
                           +u      +u R2   −u R3   +u R4        σ̄ − u ∗ 
                            R1                           ~      4       R0 
                     AM   =                              ,b   =             .         (5.22)
                           −u R1   −u R2   −u R3   +u R4       −σ1 + u ∗ 
                                                                         R0 
                           −u      +u R2   −u R3   −u R4       −σ + u ∗ 
                            R1                                  2        R0 
                           
                           −u R1
                                                                
                                                                 −σ3 + u R0∗ 
                                    +u R2   +u R3   +u R4                     
                                                                           ∗
                            −u R1   −u R2   +u R3   −u R4          −σ4 + u R0


Thus using (5.16) with constraints (5.17) and (5.18), it is possible to find the set of optimal
bounded values of ~ u R . The proposed enhanced bounded robust control architecture is de-
picted in Figure 5.40




                              Control

                 -
                             Strategy




                                                Disturbance
                                                 Observer




                                                      u n and ~
Figure 5.40 – Block diagram of the control structure. ~       u ζ correspond to the the nominal
control action and the control rejection part, respectively, ξd is the desired reference. ~ξ, ~η
mean the position and attitude states. ~u R and ~ ∗
                                                u R represent the proposed controller and the
set of its optimal and bounded values, respectively. The quadratic problem block deals with
the motors constraints and ζi represents external disturbances.


5.4.1 Experimental results of bounded control

The practical goal of these experiments is to validate the proposed control architecture. For
better illustrate the good performance of the optimal bounded robust controller (5.16), it is
compared, in two scenarios, with respect to its nominal form (5.8). It is worth to mention that
both algorithms have a low computational cost, which permits to be implemented in low cost
CPU. The experimental tests are performed in a quadrotor vehicle AR Drone 2 using the open
source Fl-AIR. The optimal control problem described by (5.17), (5.18) was solved using the
Goldfarb-Idnani algorithm [189] and implented based on the open source code uQuadProg
[190]. The control parameters for the experimental validation are the same as presented in
Table 5.1.

154


                5.4. Enhancing robust control architecture for handling rotor’s constraints


First scenario: aggressive wind-gust

Most of the aerial robot applications are developed in outdoors environments where robust-
ness with respect to wind is a primary task. The goal of the first scenario is to show the
performance of the quadcopter while it is at hover, subject to aggressive constant and inter-
mittent wind-gust. For this end, a leaf blower Bosch AVS1 was used to emulate external wind
gust with an airflow speed of 60km/h and placed at 1.5m from the quadrotor, see Figure 5.41.
The hover position is at: x(0) = 0, y(0) = 0, z(0) = 1, all in meters. A video of the experimental
results can be seen in https://youtu.be/6Fhjyb1JVXY.




                         Figure 5.41 – Set-up of the wind-gust scenario.

In Figure 5.42 the performance of the vehicle in 3D space subject to high wind-gust is intro-
duced. Notice the better performance of the proposed bounded control architecture ~          u R∗ with
respect to ~
           u R . The position behavior of the drone is depicted in Figure 5.43. In the experiment
the wind-gust was directed to the y−axis the firsts 20s. Note that both approaches suffer a
degradation in their performance, nevertheless it is clear that when using ~ u R∗ , this degradation
(especially in z) is smoother, see Figure 5.44.




               Figure 5.42 – Scenario 1.- System performance during flight tests.



                                                                                                 155


Chapter 5. Robust control scheme based on disturbance estimator




   Figure 5.43 – Scenario 1.- Performance of the quadrotor position subject to wind-gust.




                     50


                      0


                     -50

                           0   10   20     30     40    50     60     70




                     20


                      0


                     -20


                     -40
                           0   10   20     30     40    50     60     70




                     40

                     20

                      0

                     -20
                           0   10   20     30     40    50     60     70




Figure 5.44 – Scenario 1.- Attitude Performance of the quadrotor system subject to wind-gust.




156


               5.4. Enhancing robust control architecture for handling rotor’s constraints


Figures 5.45, 5.46 depict the performance of the disturbance estimator and the motors control
input. Notice that these both figures are extremely related. This due to the fact that the
disturbance estimator sends the compensation (see Figure 5.45) without knowing the motor’s
constraints (for ~  u R ). This makes the control motors inputs exceed their limits (see Figure
5.46 in 18s≤ t ≤ 22s, then in 28s≤ t ≤ 32s and 48s≤ t ≤ 52s ). However, when the vehicle is
controlled by ~u R∗ , the aforementioned problem does not appear.



                        1

                      0.5

                        0

                      -0.5
                          0   10     20     30     40    50     60     70




                      0.5

                        0

                      -0.5

                       -1
                         0    10     20     30     40    50     60     70




                      0.5

                        0

                      -0.5

                       -1
                         0    10     20     30     40    50     60     70




                 Figure 5.45 – Scenario 1.- Attitude disturbance estimations.




            Figure 5.46 – Scenario 1.- Performance of the motor control actions.



                                                                                           157


Chapter 5. Robust control scheme based on disturbance estimator


Second scenario: loss of effectiveness in rotors when performing a trajectory

Conducting electrical inspections with drones has been an application developed through the
last years. In this kind of tasks, the vehicle needs to be robust with respect to many factors,
as wind-gust, possible loss of effectiveness in rotors (repetitive tasks), among others. The
goal of the second scenario is to show the performance of the quadrotor when two LoE in
motors M 1 and M 2 occur while performing a desired trajectory emulating conduct electrical
inspection. In this experiment, the efficiency in M 1 is reduced 40% at time t ∼ 28s and, later,
at time t ∼ 44s, the efficiency in M 2 is reduced 20%.

An helical trajectory with the form x r (t ) = t , y r (t ) = a sin(t ) and z r (t ) = a cos(t ) was chosen as
desired trajectory, where a indicating the radius of the circumference. The initial conditions
are defined as ξr (0) = [−1, 1, 2]T in meters. A video of this experiment can be seen at https:
//youtu.be/CTBkhfcTYXc.

Figures 5.47- 5.49 show the performance of the quadcopter, while tracking a desired trajectory
subject to LoE in two rotors. The behavior of the vehicle in 3D space is presented in Figure 5.47.
Notice from this figure that when the first LoE (40%) in rotor M 0 was injected, the practical
stability, when using ~
                      u R , is compromised perturbing the drone. Moreover, this controller was
not capable of assuring the stability of the system and therefore, it was not possible to apply
the second LoE in rotor M 1 because the aerial robot crashed. Nevertheless, when using ~  u ∗ , the
quadrotor can continue tracking the desired reference and even tough, compensate a second
LoE (20%) in rotor M 1 at time t ∼ 44s.




                 Figure 5.47 – Scenario 2.- 3D state performances in flight tests.


158


               5.4. Enhancing robust control architecture for handling rotor’s constraints


Figures 5.48, 5.49 introduce the behavior of the disturbance estimation and the motor control
inputs. Observe from these figures that when using ~ u R∗ , the vehicle suffers a small degradation
on their performance without exceeding the physical constraints of the motors and even
tough, it can overcome the second LoE around t ∼ 44s allowing to continue tracking the
desired reference and landing safely.




                       4

                                    40% LoE
                       2              M1


                       0
                        0      10          20        30        40   50   60




                       4

                                                     20% LoE
                       2                               M2


                       0
                        0      10          20        30        40   50   60




                       0


                             Vehicle crashes after
                       -2
                               40% LoE in M1

                       -4
                         0     10          20        30        40   50   60




       Figure 5.48 – Scenario 2.- Performance of the attitude disturbance estimation.




                 Figure 5.49 – Scenario 2.- Behavior of motor control actions.




                                                                                               159


Chapter 5. Robust control scheme based on disturbance estimator


5.5 Robust control architecture conclusions
The goal of this chapter was to introduce a robust control architecture based on disturbance
estimator. The scheme is composed of a linear/nonlinear controller and an observer to give
robustness to the closed-loop system with respect to nonlinear uncertainties and external
disturbances. Three experiments were performed to validate the proposed architecture: facing
small airflow speed, adding charge in the quadcopter and LoE in a rotor. The experimental
results have shown the good performance of the architecture facing the aforementioned
scenarios. Nevertheless, if wind gust or reduced LoE in rotors are applied, this can lead to the
damage of actuators or make the aerial drone to become unstable.

A novel robust fault tolerant control scheme was obtained enhancing the control strategy
previously discussed. The difference from the first scheme is that, this novel architecture
contains a rotors fault observer to detect and estimate the loss of effectiveness in actuators.
Simulations and experimental tests were carried-out for validating the performance of the
proposed scheme: a rotor failure in a non hover position, a critical rotor fault with safe
displacement and emergency landing and, a critical rotor fault with forced landing. The
maximum value of LoE in rotors that the architecture counteracted was 30% and 60% for non
hover and hover positions, respectively. This is occurs for three reasons. The compensating
parameter ~u ζ is not aware of the limits of the rotors and therefore it sends a large value to
counteract the fault. The other one is related with the physical constraints of the actuators
and their operating velocity range. The last one and perhaps more importantly, because
the architecture is not based on classical fault tolerant controls which are integrated with a
reconfiguration control block. Nevertheless, the analysis of the experimental and simulations
results have shown the high performance capacity on rotor faults rejection and smooth
convergence with low computational cost.

Finally, a bounded robust control architecture was developed from the disturbance observer
and optimal control properties. Besides estimating and compensating unknown dynamics,
this scheme improves its robustness by solving the physical constraints of the motors. The
resultant controller avoids damaging the actuators of the system such that, its stability is
guaranteed for a class of perturbations. The proposed architecture was validated in practice
in two different scenarios: applying several wind-gust while the vehicle was hovering and,
LoE in two motors while performing a desired trajectory. From these experiments, a high
performance and smoother convergence can be obtained when using ~       u R∗ . The aforementioned
is the result of scaling the values of the compensating parameter, as well that of the control
input into the motors constraints value. In other words, solving these constraints as a quadratic
problem. In addition, regardless the computational limitations of the embedded system, the
proposed architecture has low computational cost even when solving the quadratic problem.




160


Chapter 6 Part VI




                    161




6 Conclusions



 In this thesis the problem of robustly tracking moving targets has been investigated. The
 contributions herein reported have been focused on the three objectives: i.) Introducing a
 unified and accessible analysis of control strategies aimed at solving the stabilization and
 tracking problems, ii.) exhibiting novel autonomous and semi-autonomous navigation al-
 gorithms capable of following individual targets and iii) improving disturbance rejection
 performance with several types of perturbations as well overcoming the implementation
 issues of conventional strategies.

 The first goal has been achieved introducing popular controllers: nonlinear and linear back-
 stepping and bounded state; virtual controllers based on hyperbolic functions, nonlinear
 backstepping based on the quaternion formalism and the finite-time convergence based on
 the well-known SMC. The second goal has been pursued by exploring navigation algorithms
 based on Model Predictive Control, vector field in cooperation with a vision algorithm based
 on the well-known optical flow and Kalman filter techniques and, a novel interaction Drone
 Exocentric Advanced Metaphor (DrEAM) relying on virtual reality properties. Finally, the last
 goal has been reached by exploiting the so-called uncertainty disturbance estimator, which
 has gained popularity over the past years. This strategy has been enhanced to deal with loss of
 effectiveness in rotors as properly handling rotor’s constraints.

 The performance of the studied control methodologies for solving the stabilization and track-
 ing problem has been proved in Chapter 3. These results guarantee from a mathematical
 standpoint that the increment in complexity of the controller is paid back in terms of per-
 formance. In practice, not only the achievable performance has to be taken into account,
 but also the simplicity when tuning the controller. From these results, we conclude that
 linear backstepping controller is the simplest one to analyze and implement. This is as a
 consequence of assuming that the dynamic model is linear and therefore, the tuning process
 and implementation can be seen as a classic PD.




                                                                                           163


Conclusions


In Chapter 4 the performance of the explored navigation algorithms is addressed. The first
result relies on the optimal trajectory generation based on the target’s position.The optimal
problem was solved without constraints and considering lower values of H p for avoiding
computational issues. An interesting improvement would be to consider in a new prototype
for implementing the algorithm alongside the input and output constraints. In addition,
using polynomial trajectories and the target model should improve the performance for
reaching a target. The second one shows the resultant path of a quadrotor immersed into a
visual velocity field that converges to the ideal 2D mobile robot’s velocity field. For avoiding
mismatching when looking for the centroid of the target, the algorithm is restricted to a
maximum number of features. Moreover, the ground robot must to remain in the FoV of
the airborne camera, with smooth displacements. A reasonable continuation of this work
is considering the frontal camera of the quadrotor for tracking flying objects. Furthermore,
considering the use of a predictive model of the target for anticipating its movements should
improve the performance of the control algorithm. The last navigation algorithm result is
referred to the easy maneuverability and controllability of a real drone, when a user was
controlling it by means of a virtual environment. In addition, a reduction of the cognitive
overload was observed when using the virtual proposed architecture. The extension of the
architecture for other types of robots and the analysis of time delays in the communication
could be a feasible line of research in the future of telerobotics field.

The performance improvement of a robust control architecture equipped with a disturbance
observer and a nonlinear/linear controller has been introduced in Chapter 5. This is a remark-
able result of this thesis in which, asymptotic trajectory tracking and rejection of disturbances
with unknown dynamics was achieved, while guaranteeing a prescribed level of attenuation of
unmodeled disturbances. The proposed architecture has been rigorously tested with different
kind of perturbations which are related with many aerial applications. Besides to be robust
towards unmodeled disturbances, this scheme is capable to handle rotors faults without a re-
configuration block as traditional FTC does it. Furthermore, high performance and smoother
convergence can be obtained when using a bounded control ~        u R∗ subject to several wind gust.
Additionally, the tuning of the primary controller can be performed using conventional design
techniques, while the observer is adjusted to reach a trade-off between disturbance rejec-
tion performance and robustness. This is a highly celebrated feature for control engineers
because, in practice, not only the achievable performance has to be taken into account, but
also the simplicity when tuning the controller. A reasonable continuation of this work is to
analyze the system performance when considering outdoors experiments using a GPS as well
exploring the introduction of time delays. Some primary ideas have been proposed combining
disturbance observers with sequential predictor controllers but further development has to
be performed.




164


A Publications


  International journals

    1. J. Betancourt-Vera, P. Castillo and R. Lozano, Stabilization and tracking control algo-
       rithms for VTOL aircraft: Theoretical and practical overview, Journal of Intelligent and
       Robotic Systems, 100, 1249–1263 (2020).


    2. J. Betancourt-Vera, B. Wojtkowski, P. Castillo, and I. Thouvenin, Exocentric control
       scheme for robot applications: An immersive virtual reality approach, IEEE Transactions
       on Visualization and Computer Graphics, *submitted in 2020.

    3. V. Balaguer, J. Betancourt-Vera, P. Castillo, P. García and R. Lozano, Robust fault tolerant
       architecture based on the Uncertainty and Disturbance Estimator: a case study in a
       quadrotor system, IEEE Transactions on Aerospace and Electronic Systems, *submitted
       in 2021


  International conferences

    1. J. Betancourt-Vera, V. Balaguer, P. Castillo, P. García and R. Lozano, Robust linear control
       scheme for nonlinear aerial systems: an experimental study on disturbance rejection,
       IEEE ITSC, September 20 - 23, 2020, Rhodes, Greece.


    2. A. Sánchez-Orta, P. Castillo , F. Oliva-Palomo, J. Betancourt-Vera, V. Parra-Vega, L.
       Gallegos-Bermudez, and F. J. Ruiz-Sanchez, Aerial Following of a Non-holonomic Mobile
       Robot subject to Velocity Fields: A Case Study for Autonomous Vehicles Surveillance,
       ICUAS, September 1-4, 2020, Athens, Greece.


    3. J. Betancourt-Vera, P. Castillo, R. Lozano, B. Vidolov, Robust control scheme for trajec-
       tory generation and tracking for quadcopters vehicles: Experimental results, ICUAS,
       June 12 - 15, 2018, Dallas, TX, USA.


    4. J. Betancourt-Vera, V. Balaguer, P. Castillo, P. García and R. Lozano, Bounded robust

                                                                                               165


Appendix A. Publications


      control scheme for quadcopter vehicles, IEEE CDC 2021, 13-15 Dec 2021, Austin Texas,
      *submitted in 2021


Scientific activities

   1. C. de Souza Jr, J. Betancourt-Vera, P. Castillo, R. Lozano, Trajectory and Estimation
      for low cost drones in outdoor environment, Journeée Reégionale des Doctorants en
      Automatique, July 3, 2018, Amiens, France. Poster.

   2. Journée Nationales sur ROS, Toulouse, 2018

   3. Fête de la science, UTC, Compiègne, 2017, 2018.


Preparing for submission

   1. J. Betancourt-Vera, P. Castillo, V. Balaguer, P. García and R. Lozano, Bounded control
      algorithms for quadcopter vehicles: Theoretical and practical overview in disturbance
      rejection.

   2. J. Betancourt-Vera, P. Castillo, E. Ibarra Jimenez, R. Lozano, Autonomous catching ball
      using a quadcopter vehicle: an integral sliding mode approach




166


Bibliography

 [1] Dreamstime. url: https://www.dreamstime.com. Accessed 20-04-2020.

 [2] Edwin Vattapparamban, Ismail Guvenc, Ali I. Yurekli, Kemal Akkaya, and Selcuk Ulua-
     gac. Drones for smart cities: Issues in cybersecurity, privacy, and public safety. 2016
     International Wireless Communications and Mobile Computing Conference, IWCMC
     2016, pages 216–221, 2016.

 [3] Andrew Zulu and Samuel John. A review of control algorithms for autonomous quadro-
     tors. arXiv preprint arXiv:1602.02622, 2016.

 [4] Jesse Stafford. How a quadcopter works| clay allen. University of Alaska, Fairbanks.
     Retrieved, 20, 2015.

 [5] Hamid Menouar, Ismail Guvenc, Kemal Akkaya, A Selcuk Uluagac, Abdullah Kadri,
     and Adem Tuncer. Uav-enabled intelligent transportation systems for the smart city:
     Applications and challenges. IEEE Communications Magazine, 55(3):22–28, 2017.

 [6] Chad Kerr, Raed Jaradat, and Niamat Ullah Ibne Hossain. Battlefield mapping by an un-
     manned aerial vehicle swarm: Applied systems engineering processes and architectural
     considerations from system of systems. IEEE Access, 8:20892–20903, 2020.

 [7] R. T. Ogan, D. Lott, and W. Paden. Electrical transmission line inspection using un-
     manned aircraft. In 2019 SoutheastCon, pages 1–7, 2019.

 [8] S. Sudhakar, V. Vijayakumar, C. Sathiya Kumar, V. Priya, Logesh Ravi, and V. Subra-
     maniyaswamy. Unmanned aerial vehicle (uav) based forest fire detection and moni-
     toring for reducing false alarms in forest-fires. Computer Communications, 149:1–16,
     2020.

 [9] Malavika Bhaskaranand and Jerry D. Gibson. Low-complexity video encoding for uav
     reconnaissance and surveillance. In 2011 - MILCOM 2011 Military Communications
     Conference, pages 1633–1638, 2011.

[10] Teodor Tomic, Korbinian Schmid, Philipp Lutz, Andreas Domel, Michael Kassecker,
     Elmar Mair, Iris Lynne Grixa, Felix Ruess, Michael Suppa, and Darius Burschka. Toward

                                                                                       167


Bibliography


      a fully autonomous uav: Research platform for indoor and outdoor urban search and
      rescue. IEEE Robotics Automation Magazine, 19(3):46–56, 2012.

 [11] Jianxing Liu, Chengwei Wu, Zhenhuan Wang, and Ligang Wu. Reliable filter design
      for sensor networks using type-2 fuzzy framework. IEEE Transactions on Industrial
      Informatics, 13(4):1742–1752, 2017.

 [12] Patrick Doherty and Piotr Rudol. A uav search and rescue scenario with human body
      detection and geolocalization. In Mehmet A. Orgun and John Thornton, editors, AI
      2007: Advances in Artificial Intelligence, pages 1–13, Berlin, Heidelberg, 2007. Springer
      Berlin Heidelberg.

 [13] Hyon Lim and Sudipta N. Sinha. Monocular localization of a moving person onboard
      a quadrotor mav. In 2015 IEEE International Conference on Robotics and Automation
      (ICRA), pages 2182–2189, 2015.

 [14] Roohul Amin, Li Aijun, and Shahaboddin Shamshirband. A review of quadrotor
      UAV: control methodologies and performance evaluation. International Journal of
      Automation and Control, 10(2):87–103, 2016.

 [15] Weihua Zhao and Tiauw Hiong Go. Quadcopter formation flight control combining MPC
      and robust feedback linearization. Journal of the Franklin Institute, 351(3):1335–1355,
      2014.

 [16] Giuseppe Loianno, Chris Brunner, Gary McGrath, and Vijay Kumar. Estimation, Control,
      and Planning for Aggressive Flight With a Small Quadrotor With a Single Camera and
      IMU. IEEE Robotics and Automation Letters, 2(2):404–411, 2017.

 [17] Hossein Beikzadeh and Guangjun Liu. Trajectory tracking of quadrotor flying manipu-
      lators using l1 adaptive control. Journal of the Franklin Institute, 355(14):6239 – 6261,
      2018.

 [18] W. Lei, C. Li, and M. Z. Q. Chen. Robust adaptive tracking control for quadrotors by com-
      bining pi and self-tuning regulator. IEEE Transactions on Control Systems Technology,
      27(6):2663–2671, Nov 2019.

 [19] Stanislav Tomashevich and Andrey Belyavskyi. Passification based simple adaptive
      control of quadrotor. IFAC-PapersOnLine, 49(13):281 – 286, 2016. 12th IFAC Workshop
      on Adaptation and Learning in Control and Signal Processing ALCOSP 2016.

 [20] J. Santiaguillo-Salinas, M.A. Rosaldo-Serrano, and E. Aranda-Bricaire. Observer-based
      time-varying backstepping control for parrot’s ar.drone 2.0. IFAC-PapersOnLine,
      50(1):10305 – 10310, 2017. 20th IFAC World Congress.

 [21] M.A. Rosaldo-Serrano and E. Aranda-Bricaire. Trajectory tracking for a commercial
      quadrotor via time-varying backstepping. IFAC-PapersOnLine, 51(13):532 – 536, 2018.
      2nd IFAC Conference on Modelling, Identification and Control of Nonlinear Systems
      MICNON 2018.

168


                                                                               Bibliography


[22] U. Ansari and A. H. Bajodah. Tracking control of quadrotor using generalized dy-
     namic inversion with constant-proportional rate reaching law. In 2019 1st International
     Conference on Unmanned Vehicle Systems-Oman (UVS), pages 1–7, Feb 2019.

[23] A. Das, K. Subbarao, and F. Lewis. Dynamic inversion with zero-dynamics stabilisation
     for quadrotor control. IET Control Theory Applications, 3(3):303–314, March 2009.

[24] M. Elena Antonio-Toledo, Edgar N. Sanchez, Alma Y. Alanis, J.A. Flórez, and Marco A.
     Perez-Cisneros. Real-time integral backstepping with sliding mode control for a quadro-
     tor uav. IFAC-PapersOnLine, 51(13):549 – 554, 2018. 2nd IFAC Conference on Modelling,
     Identification and Control of Nonlinear Systems MICNON 2018.

[25] J. Escareño, S. Salazar, H. Romero, and R. Lozano. Trajectory control of a quadrotor
     subject to 2d wind disturbances. Journal of Intelligent & Robotic Systems, 70(1):51–63,
     Apr 2013.

[26] Markus Hehn and Raffaello D Andrea. Real-Time Trajectory Generation for Interception
     Maneuvers with Quadrocopters. IEEE Transactions on Robotics, pages 1–16, 2015.

[27] Matthias Faessler, Antonio Franchi, and Davide Scaramuzza. Differential Flatness
     of Quadrotor Dynamics Subject to Rotor Drag for Accurate Tracking of High-Speed
     Trajectories. 2017.

[28] Daniel Mellinger and Vijay Kumar. Minimum Snap Trajectory Generation and Control
     for Quadrotors. International Conference on Robotics and Automation, pages 2520–
     2525, 2011.

[29] Rui Wang and Jinkun Liu. Trajectory tracking control of a 6-dof quadrotor uav with
     input saturation via backstepping. Journal of the Franklin Institute, 355(7):3288 – 3309,
     2018.

[30] Zhuofan Xu, Ruixuan Wei, Qirui Zhang, Kai Zhou, and Renke He. Obstacle avoidance
     algorithm for UAVs in unknown environment based on distributional perception and
     decision making. CGNCC 2016 - 2016 IEEE Chinese Guidance, Navigation and Control
     Conference, pages 1072–1075, 2017.

[31] Rakesh R. Warier, Amit K. Sanyal, Mani H. Dhullipalla, and Sasi Prabhakaran
     Viswanathan. Trajectory tracking control for underactuated thrust-propelled aerial
     vehicles. IFAC-PapersOnLine, 51(13):555 – 560, 2018. 2nd IFAC Conference on Mod-
     elling, Identification and Control of Nonlinear Systems MICNON 2018.

[32] B. P. ICKES. A new method for performing digital control system attitude computations
     using quaternions. AIAA Journal, 8(1):13–17, 1970.

[33] Chutiphon Pukdeboon, Alan S. I. Zinober, and May-Win L. Thein. Quasi-continuous
     higher order sliding-mode controllers for spacecraft-attitude-tracking maneuvers. IEEE
     Transactions on Industrial Electronics, 57(4):1436–1444, 2010.

                                                                                          169


Bibliography


 [34] Zheng Zhu, Yuanqing Xia, and Mengyin Fu. Adaptive sliding mode control for attitude
      stabilization with actuator saturation. IEEE Transactions on Industrial Electronics,
      58(10):4898–4907, 2011.

 [35] A. Chovancová, T. Fico, P. Hubinský, and F. Duchon. Comparison of various quaternion-
      based control methods applied to quadrotor with disturbance observer and position
      estimator. Robotics and Autonomous Systems, 79:87–98, 2016.

 [36] C. Izaguirre-Espinosa, A.J. Muñoz-Vázquez, A. Sánchez-Orta, V. Parra-Vega, and
      G. Sanahuja. Fractional attitude-reactive control for robust quadrotor position sta-
      bilization without resolving underactuation. Control Engineering Practice, 53:47–56,
      2016.

 [37] Carlos Izaguirre-Espinosa, Aldo Jonathan Muñoz-Vázquez, Anand Sánchez-Orta, Vi-
      cente Parra-Vega, and Pedro Castillo. Attitude control of quadrotors based on fractional
      sliding modes: theory and experiments. IET Control Theory & Applications, 10(7):825–
      832, 2016.

 [38] Yonggen Ling, Tianbo Liu, and Shaojie Shen. Aggressive quadrotor flight using
      dense visual-inertial fusion. In 2016 IEEE International Conference on Robotics and
      Automation (ICRA), pages 1499–1506, 2016.

 [39] S.P. Bhat and D.S. Bernstein. Finite-time stability of homogeneous systems. In
      Proceedings of the 1997 American Control Conference (Cat. No.97CH36041), volume 4,
      pages 2513–2514 vol.4, 1997.

 [40] Sanjay P. Bhat and Dennis S. Bernstein. Finite-time stability of continuous autonomous
      systems. SIAM Journal on Control and Optimization, 38(3):751–766, 2000.

 [41] S. Bhat and D. Bernstein. Geometric homogeneity with applications to finite-time
      stability. Mathematics of Control, Signals and Systems, 17:101–127, 2005.

 [42] Yiguang Hong, Yangsheng Xu, and Jie Huang. Finite-time control for robot manipulators.
      Systems & Control Letters, 46(4):243–253, 2002.

 [43] Haibo Du and Shihua Li. Finite-time attitude stabilization for a rigid spacecraft using
      homogeneous method. IFAC Proceedings Volumes, 44(1):2620–2625, 2011. 18th IFAC
      World Congress.

 [44] Haibo Du, Shihua Li, and Chunjiang Qian. Finite-time attitude tracking control of space-
      craft with application to attitude synchronization. IEEE Transactions on Automatic
      Control, 56(11):2711–2717, 2011.

 [45] Amit K. Sanyal, Jan Bohn, and Anthony M. Bloch. Almost global finite time stabilization
      of rigid body attitude dynamics. In 52nd IEEE Conference on Decision and Control,
      pages 3261–3266, 2013.

170


                                                                              Bibliography


[46] Jan Bohn and Amit K. Sanyal. Almost global finite-time stabilization of rigid body atti-
     tude dynamics using rotation matrices. International Journal of Robust and Nonlinear
     Control, 26(9):2008–2022, 2016.

[47] Arthur E. Bryson, Yu-Chi Ho, and George M. Siouris. Applied optimal control: Optimiza-
     tion, estimation, and control. IEEE Transactions on Systems, Man, and Cybernetics,
     9(6):366–367, 1979.

[48] Emanuel Todorov. Optimal Control Theory. Environment and Planning C Government
     and Policy, 4(2):1–28, 2006.

[49] P. R. Chandler and M. Pachter. Research issues in autonomous control of tactical UAVs.
     Proceedings of the American Control Conference, 1(June):394–398, 1998.

[50] E. Frazzoli, M.a. A Dahleh, and E. Feron. Robust hybrid control for autonomous vehicle
     motion planning. Proceedings of the 39th IEEE Conference on Decision and Control,
     2000, 1(iii):821–826 vol.1, 2000.

[51] Steven M. LaValle. Planning Algorithms. Cambridge University Press, 2006.

[52] Li-chun Lai, Chi-ching Yang, and Chia-ju Wu. Time-Optimal Control of a Hovering
     Quad-Rotor Helicopter. Journal of Intelligent and Robotic Systems, pages 115–135,
     2006.

[53] C. L. Castillo, W. Moreno, and K. P. Valavanis. Unmanned helicopter waypoint trajectory
     tracking using model predictive control. In 2007 Mediterranean Conference on Control
     Automation, pages 1–8, 2007.

[54] L Beji, A Abichou, and N Azouz. Modeling, Motion planning and Control of the drone
     with revolving Aerofoils: an Outline of the XSF Project. Robot Motion and Control, (335,
     pp.):165–177, 2006.

[55] Marcus Nolte, Marcel Rose, Torben Stolte, and Markus Maurer. Model predictive control
     based trajectory generation for autonomous vehicles — an architectural approach. In
     2017 IEEE Intelligent Vehicles Symposium (IV), pages 798–805, 2017.

[56] Pengkai Ru and Kamesh Subbarao. Nonlinear Model Predictive Control for Unmanned
     Aerial Vehicles. MDPI aerospace, pages 1–26, 2017.

[57] Michael Neunert, Cédric de Crousaz, Fadri Furrer, Mina Kamel, Farbod Farshidian,
     Roland Siegwart, and Jonas Buchli. Fast nonlinear model predictive control for uni-
     fied trajectory optimization and tracking. In 2016 IEEE International Conference on
     Robotics and Automation (ICRA), pages 1398–1404, 2016.

[58] Fabio Morbidi, Roel Cano, and David Lara. Minimum-Energy Path Generation for
     a Quadrotor UAV. International Conference on Robotics and Automation, (May):2–8,
     2016.

                                                                                         171


Bibliography


 [59] Pedro Serra, Rita Cunha, Tarek Hamel, David Cabecinhas, and Carlos Silvestre. Landing
      of a quadrotor on a moving target using dynamic image-based visual servo control.
      IEEE Transactions on Robotics, 32(6):1524–1535, 2016.

 [60] Hamed Jabbari Asl and Jungwon Yoon. Bounded-input control of the quadrotor un-
      manned aerial vehicle: A vision-based approach. Asian Journal of Control, 19(3):840–
      855, 2017.

 [61] Rafik Mebarki and Bruno Siciliano. Velocity-free image-based control of unmanned
      aerial vehicles. In 2013 IEEE/ASME International Conference on Advanced Intelligent
      Mechatronics, pages 1522–1527, 2013.

 [62] Dongliang Zheng, Hesheng Wang, Weidong Chen, and Yong Wang. Planning and track-
      ing in image space for image-based visual servoing of a quadrotor. IEEE Transactions
      on Industrial Electronics, 65(4):3376–3385, 2018.

 [63] Dongliang Zheng, Hesheng Wang, Jingchuan Wang, Siheng Chen, Weidong Chen, and
      Xinwu Liang. Image-based visual servoing of a quadrotor using virtual camera approach.
      IEEE/ASME Transactions on Mechatronics, 22(2):972–982, 2017.

 [64] Geoff Fink, Hui Xie, Alan F. Lynch, and Martin Jagersand. Nonlinear dynamic image-
      based visual servoing of a quadrotor. Journal of Unmanned Vehicle Systems, 3(1):1–21,
      2015.

 [65] H. Jabbari, G. Oriolo, and H. Bolandi. An adaptive scheme for image-based visual
      servoing of an underactuated uav. Int. J. Robotics Autom., 29, 2014.

 [66] Francois Chaumette and Seth Hutchinson. Visual servo control. i. basic approaches.
      IEEE Robotics Automation Magazine, 13(4):82–90, 2006.

 [67] Javier Gomez-Avila, Carlos Lopez-Franco, Alma Y. Alanis, Nancy Arana-Daniel, and
      Michel Lopez-Franco. Ground vehicle tracking with a quadrotor using image based
      visual servoing. IFAC-PapersOnLine, 51(13):344–349, 2018. 2nd IFAC Conference on
      Modelling, Identification and Control of Nonlinear Systems MICNON 2018.

 [68] Erdinc Altug, James P. Ostrowski, and Camillo J. Taylor. Control of a quadrotor helicopter
      using dual camera visual feedback. The International Journal of Robotics Research,
      24(5):329–341, 2005.

 [69] Bruno Herisse, Tarek Hamel, Robert Mahony, and Francois-Xavier Russotto. A nonlinear
      terrain-following controller for a vtol unmanned aerial vehicle using translational optical
      flow. In 2009 IEEE International Conference on Robotics and Automation, pages 3251–
      3257, 2009.

 [70] Heera Lal Maurya, Archit Krishna Kamath, Nishchal K. Verma, and Laxmidhar Behera.
      Vision-based fractional order sliding mode control for autonomous vehicle tracking
      by a quadrotor uav. In 2019 28th IEEE International Conference on Robot and Human
      Interactive Communication (RO-MAN), pages 1–6, 2019.

172


                                                                             Bibliography


[71] Fátima Oliva-Palomo, Aldo Jonathan Muñoz-Vázquez, Anand Sánchez-Orta, Vicente
     Parra-Vega, Carlos Izaguirre-Espinosa, and Pedro Castillo. A fractional nonlinear pi-
     structure control for robust attitude tracking of quadrotors. IEEE Transactions on
     Aerospace and Electronic Systems, 55(6):2911–2920, 2019.

[72] Justin Thomas, Jake Welde, Giuseppe Loianno, Kostas Daniilidis, and Vijay Kumar.
     Autonomous flight for detection, localization, and tracking of moving targets with a
     small quadrotor. IEEE Robotics and Automation Letters, 2(3):1762–1769, 2017.

[73] C. Huang and Tzu-Shun Hung. Visual servoing of micro aerial vehicle landing on ground
     platform. 2014 IEEE International Conference on Systems, Man, and Cybernetics
     (SMC), pages 2071–2076, 2014.

[74] Vincenzo Lippiello, Rafik Mebarki, and Fabio Ruggiero. Visual coordinated landing of a
     uav on a mobile robot manipulator. In 2013 IEEE International Symposium on Safety,
     Security, and Rescue Robotics (SSRR), pages 1–7, 2013.

[75] Shakeeb Ahmad and R. Fierro. Real-time quadrotor navigation through planning
     in depth space in unstructured environments*. 2019 International Conference on
     Unmanned Aircraft Systems (ICUAS), pages 1467–1476, 2019.

[76] Minjie Wan, Guohua Gu, Weixian Qian, Kan Ren, Xavier Maldague, and Qian Chen.
     Unmanned aerial vehicle video-based target tracking algorithm using sparse represen-
     tation. IEEE Internet of Things Journal, 6(6):9689–9706, 2019.

[77] Hamid Alturbeh and James F. Whidborne. Visual flight rules-based collision avoidance
     systems for uav flying in civil aerospace. Robotics, 9(1), 2020.

[78] Dongxu Li and J.B. Cruz. Better cooperative control with limited look-ahead. In 2006
     American Control Conference, pages 6 pp.–, 2006.

[79] A. Siddiqui, M. Verma, and David M. Tulett. A periodic planning model for maritime
     transportation of crude oil. EURO Journal on Transportation and Logistics, 2:307–335,
     2013.

[80] Edwyn Gray. Nineteenth-century torpedoes and their inventors. Annapolis, Md.: Naval
     Institute Press ; London : Greenhill, 2004.

[81] Robin R. Murphy and Jennifer L. Burke. Up from the rubble: Lessons learned about hri
     from search and rescue. Proceedings of the Human Factors and Ergonomics Society
     Annual Meeting, 49(3):437–441, 2005.

[82] Mica R. Endsley. Design and evaluation for situation awareness enhancement.
     Proceedings of the Human Factors Society Annual Meeting, 32(2):97–101, 1988.

[83] G. Gioioso, M. Mohammadi, A. Franchi, and D. Prattichizzo. A force-based bilateral
     teleoperation framework for aerial robots in contact with the environment. In 2015

                                                                                       173


Bibliography


      IEEE International Conference on Robotics and Automation (ICRA), Seattle, WA, pages
      318–324, 2015.

 [84] Jiayu Li, Bo You, Liang Ding, Jiazhong Xu, Weihua Li, Hannan Chen, and Haibo Gao. A
      novel bilateral haptic teleoperation approach for hexapod robot walking and manipu-
      lating with legs. Robotics and Autonomous Systems, 108:1 – 12, 2018.

 [85] C. A. López Martínez, I. Polat, R. v. d. Molengraft, and M. Steinbuch. Robust high
      performance bilateral teleoperation under bounded time-varying dynamics. IEEE
      Transactions on Control Systems Technology, 23(1):206–218, 2015.

 [86] D.D. Santiago, E. Slawinski, and V. Mut. Human-inspired stable bilateral teleoperation
      of mobile manipulators. ISA Transactions, 95:392 – 404, 2019.

 [87] Y. Ye, Y. Pan, and T. Hilliard. Bilateral teleoperation with time-varying delay: A commu-
      nication channel passification approach. IEEE/ASME Transactions on Mechatronics,
      18(4):1431–1434, 2013.

 [88] Seung-Ju Lee and Hyo-Sung Ahn. Controller designs for bilateral teleoperation with
      input saturation. Control Engineering Practice, 33:35 – 47, 2014.

 [89] R. Mahony, F. Schill, P. Corke, and Y. S. Oh. A new framework for force feedback teleoper-
      ation of robotic vehicles based on optical flow. In 2009 IEEE International Conference
      on Robotics and Automation, Kobe, Japan, pages 1079–1085, 2009.

 [90] Hala Rifaï, Minh-Duc Hua, Tarek Hamel, and Pascal Morin. Haptic-based bilateral
      teleoperation of underactuated unmanned aerial vehicles. Proceedings of the 18th
      World Congress, Milano, Italy, 44(1):13782 – 13788, 2011.

 [91] Xiaolei Hou, Hua Lan, Xiaojun Xing, Yaohong Qu, Dongli Yuan, Jianguo Yan, and Panfeng
      Huang. Environmental force reflection in an admittance configured haptic interface
      for teleoperation of vtol aerial robots. 20th IFAC World Congress, Toulouse, France,
      50(1):10262 – 10267, 2017.

 [92] E. Slawiñski, D. Santiago, and V. Mut. Control for delayed bilateral teleoperation of a
      quadrotor. ISA Transactions, 71:415 – 425, 2017.

 [93] R. A. S. Fernández, J. L. Sanchez-Lopez, C. Sampedro, H. Bavle, M. Molina, and P. Campoy.
      Natural user interfaces for human-drone multi-modal interaction. In 2016 International
      Conference on Unmanned Aircraft Systems (ICUAS), Arlington, VA, USA, pages 1013–
      1022, 2016.

 [94] J. Regenbrecht, A. Tavakkoli, and D. Loffredo. A robust and intuitive 3d interface for
      teleoperation of autonomous robotic agents through immersive virtual reality environ-
      ments. In 2017 IEEE Symposium on 3D User Interfaces (3DUI), Los Angeles, CA, USA,
      pages 199–200, 2017.

174


                                                                                       Bibliography


 [95] T. Abut and S. Soygüder. Haptic industrial robot control and bilateral teleoperation by
      using a virtual visual interface. In 2018 26th Signal Processing and Communications
      Applications Conference (SIU), Izmir, Turkey, pages 1–4, 2018.

 [96] A. Naceri, D. Mazzanti, J. Bimbo, D. Prattichizzo, D. G. Caldwell, L. S. Mattos, and
      N. Deshpande. Towards a virtual reality interface for remote robotic teleoperation.
      In 2019 19th International Conference on Advanced Robotics (ICAR), Belo Horizonte,
      Brazil, Brazil, pages 284–289, 2019.

 [97] S. N. F. Nahri, S. Du, and B. Van Wyk. Haptic system interface design and modelling
      for bilateral teleoperation systems. In 2020 International SAUPEC/RobMech/PRASA
      Conference, Cape Town, South Africa, South Africa, pages 1–6, 2020.

 [98] João Marcelo Teixeira, Ronaldo Ferreira, Matheus Santos, and Veronica Teichrieb. Tele-
      operation using google glass and ar, drone for structural inspection. In XVI Symposium
      on Virtual and Augmented Reality, pages 28–36. IEEE, 2014.

 [99] A. Suarez, P. Sanchez-Cuevas, M. Fernandez, M. Perez, G. Heredia, and A. Ollero.
      Lightweight and compliant long reach aerial manipulator for inspection operations.
      In 2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS),
      Madrid, Spain, pages 6746–6752, 2018.

[100] John Paulin Hansen, Alexandre Alapetite, I Scott MacKenzie, and Emilie Møllenbach.
      The use of gaze to control drones. In ETRA ’14: Proceedings of the Symposium on Eye
      Tracking Research and Applications, Safety Harbor, Florida, pages 27–34. ACM, 2014.

[101] Jzau-Sheng Lin and Zi-Yang Jiang. Implementing remote presence using quadcopter
      control by a non-invasive bci device. Computer Science and Information Technology,
      3(4):122–126, 2015.

[102] N. Liu, T. Lu, Y. Cai, J. Lu, H. Gao, B. Li, and S. Wang. Design of virtual reality teleoperation
      system for robot complex manipulation. In 2019 Chinese Automation Congress (CAC),
      Hangzhou, China, China, pages 1789–1793, 2019.

[103] S. Kim, Y. Kim, J. Ha, and S. Jo. Mapping system with virtual reality for mobile robot tele-
      operation. In 2018 18th International Conference on Control, Automation and Systems
      (ICCAS), Daegwallyeong, South Korea, pages 1541–1541, 2018.

[104] A.W.W. Yew, S.K. Ong, and A.Y.C. Nee. Immersive augmented reality environment for
      the teleoperation of maintenance robots. Procedia CIRP, 61:305 – 310, 2017. The 24th
      CIRP Conference on Life Cycle Engineering.

[105] Bryan Walter, Jared Knutzon, Adrian Sannier, and James Oliver. Virtual uav ground
      control station. In AIAA 3rd" Unmanned Unlimited" Technical Conference, Workshop
      and Exhibit, Chicago, Illinois, page 6320, 2004.

                                                                                                  175


Bibliography


[106] Baichuan Huang, Deniz Bayazit, Daniel Ullman, Nakul Gopalan, and Stefanie Tellex.
      Flight, camera, action! using natural language and mixed reality to control a drone.
      In Proc. IEEE International Conference on Robotics and Automation (ICRA), Montreal,
      Canada, 2019.

[107] Matteo Macchini, Thomas Havy, Antoine Weber, Fabrizio Schiano, and Dario Flore-
      ano. Hand-worn haptic interface for drone teleoperation. In Proc. IEEE International
      Conference on Robotics and Automation (ICRA), Paris, France, 2020.

[108] Siyang Yang, Jiang Han, Lian Xia, and Ye-Hwa Chen. Adaptive robust servo constraint
      tracking control for an underactuated quadrotor uav with mismatched uncertainties.
      ISA Transactions, 106:12–30, 2020.

[109] Xiao-Zheng Jin, Tao He, Xiao-Ming Wu, Hai Wang, and Jing Chi. Robust adaptive neural
      network-based compensation control of a class of quadrotor aircrafts. Journal of the
      Franklin Institute, 357(17):12241–12263, 2020.

[110] Moussa Labbadi and Mohamed Cherkaoui. Robust adaptive nonsingular fast terminal
      sliding-mode tracking control for an uncertain quadrotor uav subjected to disturbances.
      ISA Transactions, 99:290 – 304, 2020.

[111] Lei Guo and Songyin Cao. Anti-disturbance control theory for systems with multiple
      disturbances: A survey. ISA transactions, 53(4):846–849, 2014.

[112] Shihong Ding, Wen-Hua Chen, Keqi Mei, and David J Murray-Smith. Disturbance
      observer design for nonlinear systems represented by input–output models. IEEE
      Transactions on Industrial Electronics, 67(2):1222–1232, 2019.

[113] Jingqing Han. From PID to active disturbance rejection control. IEEE transactions on
      Industrial Electronics, 56(3):900–906, 2009.

[114] Shihua Li, Jun Yang, Wen-Hua Chen, and Xisong Chen. Generalized extended state
      observer based control for systems with mismatched uncertainties. IEEE Transactions
      on Industrial Electronics, 59(12):4792–4802, 2011.

[115] Vicente Balaguer, Ricardo Sanz, Pedro Garcia, and Pedro Albertos. Two-degree-of-
      freedom PID tuning based on an uncertainty and disturbance estimator. In 2018 7th
      International Conference on Systems and Control (ICSC), pages 424–429. IEEE, 2018.

[116] Antonio González, Angel Cuenca, Vicente Balaguer, and Pedro García. Event-triggered
      predictor-based control with gain-scheduling and extended state observer for net-
      worked control systems. Information Sciences, 491:90–108, 2019.

[117] Antonio Gonzalez, Vicente Balaguer, Pedro Garcia, and Angel Cuenca. Gain-scheduled
      predictive extended state observer for time-varying delays systems with mismatched
      disturbances. ISA transactions, 84:206–213, 2019.

176


                                                                                    Bibliography


[118] B. Kurkçu, C. Kasnakoglu, and M. Ö. Efe. Disturbance/uncertainty estimator
      based robust control of nonminimum phase systems. IEEE/ASME Transactions on
      Mechatronics, 23(4):1941–1951, 2018.

[119] Jiuqiang Deng, Xi Zhou, and Yao Mao. On vibration rejection of nonminimum-
      phase long-distance laser pointing system with compensatory disturbance observer.
      Mechatronics, 74:102490, 2021.

[120] Alireza Mohammadi, Mahdi Tavakoli, Horacio J Marquez, and Farzad Hashemzadeh.
      Nonlinear disturbance observer design for robotic manipulators. Control Engineering
      Practice, 21(3):253–267, 2013.

[121] Jialu Du, Xin Hu, Miroslav Krstić, and Yuqing Sun. Robust dynamic positioning of ships
      with disturbances under input saturation. Automatica, 73:207–214, 2016.

[122] Divyesh Ginoya, Chandrashekhar M Gutte, PD Shendge, and SB Phadke. State-
      and-disturbance-observer-based sliding mode control of magnetic levitation systems.
      Transactions of the Institute of Measurement and Control, 38(6):751–763, 2016.

[123] Qi Lu, Beibei Ren, Siva Parameswaran, and Qing-Chang Zhong. Uncertainty and dis-
      turbance estimator-based robust trajectory tracking control for a quadrotor in a global
      positioning system-denied environment. Journal of Dynamic Systems, Measurement,
      and Control, 140(3), 2018.

[124] Longhao Qian and Hugh HT Liu. Path-following control of a quadrotor uav with a
      cable-suspended payload under wind disturbances. IEEE Transactions on Industrial
      Electronics, 67(3):2021–2029, 2019.

[125] Qi Lu, Beibei Ren, and Siva Parameswaran. Uncertainty and disturbance estimator-
      based global trajectory tracking control for a quadrotor. IEEE/ASME Transactions on
      Mechatronics, 2020.

[126] Shen Yin, Bing Xiao, Steven X Ding, and Donghua Zhou. A review on recent development
      of spacecraft attitude fault tolerant control system. IEEE Transactions on Industrial
      Electronics, 63(5):3311–3320, 2016.

[127] G. Ortiz-Torres, P. Castillo, F. D. J. Sorcia-Vázquez, J. Y. Rumbo-Morales, J. A. Brizuela-
      Mendoza, J. De La Cruz-Soto, and M. Martínez-García. Fault estimation and fault
      tolerant control strategies applied to vtol aerial vehicles with soft and aggressive actuator
      faults. IEEE Access, 8:10649–10661, 2020.

[128] Youmin Zhang and Jin Jiang. Bibliographical review on reconfigurable fault-tolerant
      control systems. Annual reviews in control, 32(2):229–252, 2008.

[129] Iman Sadeghzadeh, Ankit Mehta, Abbas Chamseddine, and Youmin Zhang. Active fault
      tolerant control of a quadrotor uav based on gainscheduled pid control. In 2012 25th
      IEEE Canadian Conference on Electrical and Computer Engineering (CCECE), pages
      1–4. IEEE, 2012.

                                                                                              177


Bibliography


[130] Abdel-Razzak Merheb, Hassan Noura, and François Bateman. Passive fault tolerant
      control of quadrotor uav using regular and cascaded sliding mode control. In 2013
      Conference on Control and Fault-Tolerant Systems (SysTol), pages 330–335. IEEE, 2013.

[131] Luis Gracia, J Ernesto Solanes, Pau Muñoz-Benavent, Jaime Valls Miro, Carlos Perez-
      Vidal, and Josep Tornero. Adaptive sliding mode control for robotic surface treatment
      using force feedback. Mechatronics, 52:102–118, 2018.

[132] Pin Lyu, Jizhou Lai, Jianye Liu, Hugh HT Liu, and Qingrui Zhang. A thrust model aided
      fault diagnosis method for the altitude estimation of a quadrotor. IEEE Transactions on
      Aerospace and Electronic Systems, 54(2):1008–1019, 2017.

[133] Abdel-Razzak Merheb and Hassan Noura. Active fault-tolerant control of quadrotor uavs
      based on passive controller bank. In Rany Rizk and Mariette Awad, editors, Mechanism,
      Machine, Robotics and Mechatronics Sciences, pages 231–241. Springer International
      Publishing, 2019.

[134] Xiaohong Nian, Weiqiang Chen, Xiaoyan Chu, and Zhiwei Xu. Robust adaptive fault
      estimation and fault tolerant control for quadrotor attitude systems. International
      Journal of Control, 93(3):725–737, 2020.

[135] R. C. Avram, X. Zhang, and J. Muse. Quadrotor actuator fault diagnosis and accom-
      modation using nonlinear adaptive estimators. IEEE Transactions on Control Systems
      Technology, 25(6):2219–2226, 2017.

[136] B.R. Andrievsky, N.V. Kuznetsov, G.A. Leonov, and A.Yu. Pogromsky. Hidden oscilla-
      tions in aircraft flight control system with input saturation. IFAC Proceedings Volumes,
      46(12):75 – 79, 2013. 5th IFAC Workshop on Periodic Control Systems.

[137] R. van den Berg, A. Pogromsky, and K. Rooda. Convergent systems design: Anti-windup
      for marginally stable plants. In Proceedings of the 45th IEEE Conference on Decision
      and Control, pages 5441–5446, 2006.

[138] B. R. Andrievsky, N. V. Kuznetsov, G. A. Leonov, and A. Y. Pogromsky. Convergence based
      anti-windup design method and its application to flight control. In 2012 IV International
      Congress on Ultra Modern Telecommunications and Control Systems, pages 212–218,
      2012.

[139] Gennady Leonov, Boris Andrievsky, Nikolay Kuznetsov, and A. Pogromskii. Aircraft
      control with anti-windup compensation. Differential Equations, 48:1700–1720, 2012.

[140] Matthias Faessler, Davide Falanga, and Davide Scaramuzza. Thrust Mixing, Saturation,
      and Body-Rate Control for Accurate Aggressive Quadrotor Flight. IEEE Robotics and
      Automation Letters, 2(2):476–482, 2017.

[141] E.J.J. Smeur, G.C.H.E. de Croon, and Q. Chu. Cascaded incremental nonlinear dynamic
      inversion for mav disturbance rejection. Control Engineering Practice, 73:79–90, 2018.

178


                                                                                 Bibliography


[142] Paul Pounds, Robert Mahony, and Joel Gresham. Towards dynamicallyfavourable quad-
      rotor aerial robots. In In Proc. of Australasian Conference on Robotics and Automation,
      2004.

[143] Raymond W. Prouty. Helicopter performance, stability and control. Krieger Publishing
      Company, 1995.

[144] P. Pounds, R. Mahony, and P. Corke. Modelling and control of a large quadrotor robot.
      Control Engineering Practice, 18(7):691–699, 2010. Special Issue on Aerial Robotics.

[145] Herbert Goldstein. Classical Mechanics. Addison-Wesley, 1980.

[146] P. Castillo, R. Lozano, and A. Dzul. Stabilization of a mini rotorcraft with four rotors.
      IEEE Control Systems Magazine, 25(6):45–55, 2005.

[147] Pedro Castillo Garcia, R. Lozano, and Alejandro Dzul. Modelling and Control of
      Mini-Flying Machines. 01 2005.

[148] Richard M. Howard. Dynamics of flight: Stability and control; third edition. Journal of
      Guidance, Control, and Dynamics, 20(4):839–840, 1997.

[149] R. Lozano. Unmanned Aerial Vehicles Embedded Control. John Wiley-ISTE Ltd, 2010.

[150] H. Abaunza, P. Castillo, and R. Lozano. Quaternion Modeling and Control Approaches,
      pages 1–29. Springer International Publishing, 2018.

[151] D. C. Gandolfo, L. R. Salinas, A. Brandão, and J. M. Toibero. Stable path-following
      control for a quadrotor helicopter considering energy consumption. IEEE Transactions
      on Control Systems Technology, 25(4):1423–1430, July 2017.

[152] J.F. Guerrero-Castellanos, N. Marchand, A. Hably, S. Lesecq, and J. Delamare. Bounded
      attitude control of rigid bodies: Real-time experimentation to a quadrotor mini-
      helicopter. Control Engineering Practice, 19(8):790 – 797, 2011.

[153] Alejandro J Malo Tamayo, Cesar A. Villaseñor Ríos, Juan Manuel Ibarra Zannatha, and
      Santos M. Orozco Soto. Quadrotor input-output linearization and cascade control.
      IFAC-PapersOnLine", 51(13):437 – 442, 2018. 2nd IFAC Conference on Modelling, Iden-
      tification and Control of Nonlinear Systems MICNON 2018.

[154] Andrew R. Teel. Global stabilization and restricted tracking for multiple integrators with
      bounded controls. Systems & Control Letters, 18(3):165 – 171, 1992.

[155] Guillaume Sanahuja, Pedro Christian Ayala Castillo, and Anand Sanchez. Stabilization
      of n integrators in cascade with bounded input with experimental application to a vtol
      laboratory system. International Journal of Robust and Nonlinear Control, 2009.

[156] A. Ailon. Simple tracking controllers for autonomous vtol aircraft with bounded inputs.
      IEEE Transactions on Automatic Control, 55(3):737–743, March 2010.

                                                                                            179


Bibliography


[157] Trong-Toan Tran, Ge Shuzhi Sam, and He Wei. Adaptive control of a quadrotor aerial ve-
      hicle with input constraints and uncertain parameters. International Journal of Control,
      2018.

[158] H K Khalil. Nonlinear systems (3rd ed. ). Upper Saddle River, NJ: Prentice Hall, 2002.

[159] Antonios Zagaris, Hans G. Kaper, and Tasso J. Kaper. Fast and Slow Dynamics for
      the Computational Singular Perturbation Method. arXiv Mathematics e-prints, page
      math/0401206, Jan 2004.

[160] Heudiasyc Lab.      FL-AIR framework. accessed:       Feb. 27, 2020. [online]., 2012,
      https://devel.hds.utc.fr/software/flair.

[161] Shtessel Yuri, Leonid Fridman Christopher, Edwards, and Levant Arie. Sliding Mode
      Control and Observation. Birkhäuser Basel, 2014.

[162] Taeyoung Lee, M. Leoky, and N.H. McClamroch. Geometric tracking control of a quadro-
      tor UAV on SE(3). 49th IEEE Conference on Decision and Control (CDC), 2010., pages
      5420–5425, 2010.

[163] Zhong Liu, Yuqing He, Liying Yang, and Jianda Han. Control techniques of tilt ro-
      tor unmanned aerial vehicle systems: A review. Chinese Journal of Aeronautics,
      30(December):135–148, 2016.

[164] Moses Bangura and Robert Mahony. Real-time model predictive control for quadrotors.
      IFAC Proceedings Volumes, 47(3):11773–11780, 2014. 19th IFAC World Congress.

[165] C. Forster, M. Pizzoli, and D. Scaramuzza. Svo: Fast semi-direct monocular visual
      odometry. In 2014 IEEE International Conference on Robotics and Automation (ICRA),
      pages 15–22, 2014.

[166] Charles Richter, Adam Bry, and Nicholas Roy. Polynomial Trajectory Planning for
      Aggressive Quadrotor Flight in Dense Indoor Environments, pages 649–666. 04 2016.

[167] Andreas Bircher, Mina Samir Kamel, Kostas Alexis, Helen Oleynikova, and Roland
      Siegwart. Receding horizon path planning for 3d exploration and surface inspection.
      Autonomous Robots, 42, 02 2018.

[168] Matthias Faessler, Flavio Fontana, Christian Forster, Elias Mueggler, Matia Pizzoli, and
      Davide Scaramuzza. Autonomous, vision-based flight and live dense 3d mapping with
      a quadrotor micro aerial vehicle. Journal of Field Robotics, 33(4):431–450, 2016.

[169] Nathan Michael, Shaojie Shen, Kartik Mohta, Yash Mulgaonkar, Vijay Kumar, Keiji
      Nagatani, Yoshito Okada, Seiga Kiribayashi, Kazuki Otake, Kazuya Yoshida, Kazunori
      Ohno, Eijiro Takeuchi, and Satoshi Tadokoro. Collaborative mapping of an earthquake-
      damaged building via ground and aerial robots. Journal of Field Robotics, 29(5):832–841,
      2012.

180


                                                                                 Bibliography


[170] JM M Maciejowski. Predictive control: with constraints. Pearson Education Limited,
      Harlow, UK, page 331, 2002.

[171] A. Chakrabarty, R. Morris, X. Bouyssounouse, and R. Hunt. Autonomous indoor object
      tracking with the parrot ar.drone. In 2016 International Conference on Unmanned
      Aircraft Systems (ICUAS), pages 25–30, 2016.

[172] Jianbo Shi and Tomasi. Good features to track. In 1994 Proceedings of IEEE Conference
      on Computer Vision and Pattern Recognition, pages 593–600, 1994.

[173] Jean yves Bouguet. Pyramidal implementation of the lucas kanade feature tracker. Intel
      Corporation, Microprocessor Research Labs, 2000.

[174] Pedro Castillo, Alejandro Dzul, and Rogelio Lozano. Real-time stabilization and track-
      ing of a four-rotor mini rotorcraft. IEEE Transactions on Control Systems Technology,
      12(4):510–516, 2004.

[175] Robert Mahony, Vijay Kumar, and Peter Corke. Multirotor aerial vehicles: Modeling,
      estimation, and control of quadrotor. IEEE Robotics Automation Magazine, 19(3):20–32,
      2012.

[176] Samir Bouabdallah and Roland Siegwart. Full control of a quadrotor. In 2007 IEEE/RSJ
      International Conference on Intelligent Robots and Systems, pages 153–158, 2007.

[177] L. Luque-Vega, B. Castillo-Toledo, and Alexander G. Loukianov. Robust block second
      order sliding mode control for a quadrotor. Journal of the Franklin Institute, 349(2):719
      – 739, 2012.

[178] Bo Zheng and Yisheng Zhong. Robust attitude regulation of a 3-dof helicopter bench-
      mark: Theory and experiments. IEEE Transactions on Industrial Electronics, 58(2):660–
      670, 2011.

[179] Shafiqul Islam, Peter X. Liu, and Abdulmotaleb El Saddik. Robust control of four-rotor
      unmanned aerial vehicle with disturbance uncertainty. IEEE Transactions on Industrial
      Electronics, 62(3):1563–1571, 2015.

[180] Bo Zhao, Bin Xian, Yao Zhang, and Xu Zhang. Nonlinear robust adaptive tracking control
      of a quadrotor uav via immersion and invariance methodology. IEEE Transactions on
      Industrial Electronics, 62(5):2891–2902, 2015.

[181] Gabriel Hoffmann, Haomiao Huang, Steven Waslander, and Claire Tomlin. Quadro-
      tor helicopter flight dynamics and control: Theory and experiment. AIAA Guidance,
      Navigation and Control Conference and Exhibit, page p.82, 2007.

[182] Steven Waslander and Carlos Wang. Wind disturbance estimation and rejection for
      quadrotor position control. AIAA Infotech@Aerospace Conference, 2009.

                                                                                           181


Bibliography


[183] Xiwang Dong, Bocheng Yu, Zongying Shi, and Yisheng Zhong. Time-Varying Formation
      Control for Unmanned Aerial Vehicles: Theories and Applications. IEEE Transactions
      on Control Systems Technology, pages 1–1, 2014.

[184] Kooksun Lee, J. Back, and I. Choy. Nonlinear disturbance observer based robust attitude
      tracking controller for quadrotor uavs. International Journal of Control, Automation
      and Systems, 12:1266–1275, 2014.

[185] Ricardo Sanz, Pedro Garcia, Qing-Chang Zhong, and Pedro Albertos. Robust control
      of quadrotors based on an uncertainty and disturbance estimator. Journal of Dynamic
      Systems, Measurement, and Control, 138(7):71006, 2016.

[186] Qing-Chang Zhong and David Rees. Control of uncertain LTI systems based on an
      uncertainty and disturbance estimator. Journal of Dynamic Systems, Measurement,
      and Control(Transactions of the ASME), 126(4):905–910, 2004.

[187] Kamal Youcef-Toumi and Osamu Ito. A time delay controller for systems with unknown
      dynamics. Journal of dynamic systems, measurement, and control, 112(1):133–142,
      1990.

[188] Beibei Ren, Q.C. Zhong, and Jinhao C. Robust control for a class of nonaffine nonlinear
      systems based on the uncertainty and disturbance estimator. IEEE Transactions on
      Industrial Electronics, 62(9):5881–5888, 2015.

[189] D. Goldfarb and A. Idnani. A numerically stable dual method for solving strictly convex
      quadratic programs. Mathematical Programming, 27:1–33, 1983.

[190] Luca Di Gaspero and Angelo Furfaro. uQuadProg ppen source library. accessed: January.
      13, 2021. [online]., 2006, https://github.com/fx74/uQuadProg.




182
